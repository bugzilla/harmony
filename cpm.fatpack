#!/Users/dylan/.plenv/versions/5.34.0/bin/perl5.34.0

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/cpm.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM';
  package App::cpm;use strict;use warnings;our$VERSION='0.997007';our ($GIT_DESCRIBE,$GIT_URL);1;
APP_CPM

$fatpacked{"App/cpm/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_CLI';
  package App::cpm::CLI;use 5.008001;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::Distribution;use App::cpm::Logger::File;use App::cpm::Logger;use App::cpm::Master;use App::cpm::Requirement;use App::cpm::Resolver::Cascade;use App::cpm::Resolver::MetaCPAN;use App::cpm::Resolver::MetaDB;use App::cpm::Util qw(WIN32 determine_home maybe_abs);use App::cpm::Worker;use App::cpm::version;use App::cpm;use Config;use Cwd ();use File::Copy ();use File::Path ();use File::Spec;use Getopt::Long qw(:config no_auto_abbrev no_ignore_case bundling);use List::Util ();use Module::CPANfile;use Module::cpmfile;use Parallel::Pipes;use Pod::Text ();sub new {my ($class,%option)=@_;my$prebuilt=exists$ENV{PERL_CPM_PREBUILT}&&!$ENV{PERL_CPM_PREBUILT}? 0 : 1;bless {argv=>undef,home=>determine_home,cwd=>Cwd::cwd(),workers=>WIN32 ? 1 : 5,snapshot=>"cpanfile.snapshot",dependency_file=>undef,local_lib=>"local",cpanmetadb=>"https://cpanmetadb.plackperl.org/v1.0/",_default_mirror=>'https://cpan.metacpan.org/',retry=>1,configure_timeout=>60,build_timeout=>3600,test_timeout=>1800,with_requires=>1,with_recommends=>0,with_suggests=>0,with_configure=>0,with_build=>1,with_test=>1,with_runtime=>1,with_develop=>0,feature=>[],notest=>1,prebuilt=>$] >= 5.012 && $prebuilt,pureperl_only=>0,static_install=>1,%option },$class}sub parse_options {my$self=shift;local@ARGV=@_;my ($mirror,@resolver,@feature);my$with_option=sub {my$n=shift;("with-$n",\$self->{"with_$n"},"without-$n",sub {$self->{"with_$n"}=0})};my@type=qw(requires recommends suggests);my@phase=qw(configure build test runtime develop);GetOptions "L|local-lib-contained=s"=>\($self->{local_lib}),"color!"=>\($self->{color}),"g|global"=>\($self->{global}),"mirror=s"=>\$mirror,"v|verbose"=>\($self->{verbose}),"w|workers=i"=>\($self->{workers}),"target-perl=s"=>\my$target_perl,"test!"=>sub {$self->{notest}=$_[1]? 0 : 1},"cpanfile=s"=>sub {$self->{dependency_file}={type=>"cpanfile",path=>$_[1]}},"cpmfile=s"=>sub {$self->{dependency_file}={type=>"cpmfile",path=>$_[1]}},"snapshot=s"=>\($self->{snapshot}),"sudo"=>\($self->{sudo}),"r|resolver=s@"=>\@resolver,"mirror-only"=>\($self->{mirror_only}),"dev"=>\($self->{dev}),"man-pages"=>\($self->{man_pages}),"home=s"=>\($self->{home}),"retry!"=>\($self->{retry}),"exclude-vendor!"=>\($self->{exclude_vendor}),"configure-timeout=i"=>\($self->{configure_timeout}),"build-timeout=i"=>\($self->{build_timeout}),"test-timeout=i"=>\($self->{test_timeout}),"show-progress!"=>\($self->{show_progress}),"prebuilt!"=>\($self->{prebuilt}),"reinstall"=>\($self->{reinstall}),"pp|pureperl|pureperl-only"=>\($self->{pureperl_only}),"static-install!"=>\($self->{static_install}),"with-all"=>sub {map {$self->{"with_$_"}=1}@type,@phase},(map$with_option->($_),@type),(map$with_option->($_),@phase),"feature=s@"=>\@feature,"show-build-log-on-failure"=>\($self->{show_build_log_on_failure}),or return 0;$self->{local_lib}=maybe_abs($self->{local_lib},$self->{cwd})unless$self->{global};$self->{home}=maybe_abs($self->{home},$self->{cwd});$self->{resolver}=\@resolver;$self->{feature}=\@feature if@feature;$self->{mirror}=$self->normalize_mirror($mirror)if$mirror;$self->{color}=1 if!defined$self->{color}&& -t STDOUT;$self->{show_progress}=1 if!WIN32 &&!defined$self->{show_progress}&& -t STDOUT;if ($target_perl){die "--target-perl option conflicts with --global option\n" if$self->{global};die "--target-perl option can be used only if perl version >= 5.18.0\n" if $] < 5.018;$target_perl="v$target_perl" if$target_perl =~ /^5\.[1-9]\d*$/;$target_perl=sprintf '%0.6f',App::cpm::version->parse($target_perl)->numify;$target_perl='5.008' if$target_perl eq '5.008000';$self->{target_perl}=$target_perl}if (WIN32 and $self->{workers}!=1){die "The number of workers must be 1 under WIN32 environment.\n"}if ($self->{sudo}){!system "sudo",$^X,"-e1" or exit 1}if ($self->{pureperl_only}or $self->{sudo}or!$self->{notest}or $self->{man_pages}or $] < 5.012){$self->{prebuilt}=0}$App::cpm::Logger::COLOR=1 if$self->{color};$App::cpm::Logger::VERBOSE=1 if$self->{verbose};$App::cpm::Logger::SHOW_PROGRESS=1 if$self->{show_progress};if (@ARGV){if ($ARGV[0]eq "-"){my$argv=$self->read_argv_from_stdin;return -1 if @$argv==0;$self->{argv}=$argv}else {$self->{argv}=\@ARGV}}elsif (!$self->{dependency_file}){if (-f "cpm.yml"){$self->{dependency_file}={type=>"cpmfile",path=>"cpm.yml" }}elsif (-f "cpanfile"){$self->{dependency_file}={type=>"cpanfile",path=>"cpanfile" }}}return 1}sub read_argv_from_stdin {my$self=shift;my@argv;while (my$line=<STDIN>){next if$line !~ /\S/;next if$line =~ /^\s*#/;$line =~ s/^\s*//;$line =~ s/\s*$//;push@argv,split /\s+/,$line}return \@argv}sub _core_inc {my$self=shift;[(!$self->{exclude_vendor}? grep {$_}@Config{qw(vendorarch vendorlibexp)}: ()),@Config{qw(archlibexp privlibexp)},]}sub _search_inc {my$self=shift;return \@INC if$self->{global};my$base=$self->{local_lib};require local::lib;my@local_lib=(local::lib->resolve_path(local::lib->install_base_arch_path($base)),local::lib->resolve_path(local::lib->install_base_perl_path($base)),);if ($self->{target_perl}){return [@local_lib]}else {return [@local_lib,@{$self->_core_inc}]}}sub normalize_mirror {my ($self,$mirror)=@_;$mirror =~ s{/*$}{/};return$mirror if$mirror =~ m{^https?://};$mirror =~ s{^file://}{};die "$mirror: No such directory.\n" unless -d $mirror;"file://" .maybe_abs($mirror,$self->{cwd})}sub run {my ($self,@argv)=@_;my$cmd=shift@argv or die "Need subcommand, try `cpm --help`\n";$cmd="help" if$cmd =~ /^(-h|--help)$/;$cmd="version" if$cmd =~ /^(-V|--version)$/;if (my$sub=$self->can("cmd_$cmd")){return$self->$sub(@argv)if$cmd eq "exec";my$ok=$self->parse_options(@argv);return 1 if!$ok;return 0 if$ok==-1;return$self->$sub}else {my$message=$cmd =~ /^-/ ? "Missing subcommand" : "Unknown subcommand '$cmd'";die "$message, try `cpm --help`\n"}}sub cmd_help {open my$fh,">",\my$out;Pod::Text->new->parse_from_file($0,$fh);$out =~ s/^[ ]{6}/    /mg;print$out;return 0}sub cmd_version {print "cpm $App::cpm::VERSION ($0)\n";if ($App::cpm::GIT_DESCRIBE){print "This is a self-contained version, $App::cpm::GIT_DESCRIBE ($App::cpm::GIT_URL)\n"}printf "perl version v%vd ($^X)\n\n",$^V;print "  \%Config:\n";for my$key (qw(archname installsitelib installsitebin installman1dir installman3dir sitearchexp sitelibexp vendorarch vendorlibexp archlibexp privlibexp)){print "    $key=$Config{$key}\n" if$Config{$key}}print "  \%ENV:\n";for my$key (grep /^PERL/,sort keys%ENV){print "    $key=$ENV{$key}\n"}print "  \@INC:\n";for my$inc (@INC){print "    $inc\n" unless ref($inc)eq 'CODE'}return 0}sub cmd_install {my$self=shift;die "Need arguments or cpm.yml/cpanfile\n" if!$self->{argv}&&!$self->{dependency_file};local%ENV=%ENV;File::Path::mkpath($self->{home})unless -d $self->{home};my$logger=App::cpm::Logger::File->new("$self->{home}/build.log.@{[time]}");$logger->symlink_to("$self->{home}/build.log");$logger->log("Running cpm $App::cpm::VERSION ($0) on perl $Config{version} built for $Config{archname} ($^X)");$logger->log("This is a self-contained version, $App::cpm::GIT_DESCRIBE ($App::cpm::GIT_URL)")if$App::cpm::GIT_DESCRIBE;$logger->log("Command line arguments are: @ARGV");my$master=App::cpm::Master->new(logger=>$logger,core_inc=>$self->_core_inc,search_inc=>$self->_search_inc,global=>$self->{global},show_progress=>$self->{show_progress},(exists$self->{target_perl}? (target_perl=>$self->{target_perl}): ()),);my ($packages,$dists,$resolver)=$self->initial_task($master);return 0 unless$packages;my$worker=App::cpm::Worker->new(verbose=>$self->{verbose},home=>$self->{home},logger=>$logger,notest=>$self->{notest},sudo=>$self->{sudo},resolver=>$self->generate_resolver($resolver),man_pages=>$self->{man_pages},retry=>$self->{retry},prebuilt=>$self->{prebuilt},pureperl_only=>$self->{pureperl_only},static_install=>$self->{static_install},configure_timeout=>$self->{configure_timeout},build_timeout=>$self->{build_timeout},test_timeout=>$self->{test_timeout},($self->{global}? (): (local_lib=>$self->{local_lib})),);{last if $] >= 5.018;my$requirement=App::cpm::Requirement->new('ExtUtils::MakeMaker'=>'6.64','ExtUtils::ParseXS'=>'3.16');for my$name ('ExtUtils::MakeMaker','ExtUtils::ParseXS'){if (my ($i)=grep {$packages->[$_]{package}eq $name}0..$#{$packages}){$requirement->add($name,$packages->[$i]{version_range})or die sprintf "We have to install newer $name first: $@\n";splice @$packages,$i,1}}my ($is_satisfied,@need_resolve)=$master->is_satisfied($requirement->as_array);last if$is_satisfied;$master->add_task(type=>"resolve",%$_)for@need_resolve;$self->install($master,$worker,1);if (my$fail=$master->fail){local$App::cpm::Logger::VERBOSE=0;for my$type (qw(install resolve)){App::cpm::Logger->log(result=>"FAIL",type=>$type,message=>$_)for @{$fail->{$type}}}print STDERR "\r" if$self->{show_progress};warn sprintf "%d distribution%s installed.\n",$master->installed_distributions,$master->installed_distributions > 1 ? "s" : "";if ($self->{show_build_log_on_failure}){File::Copy::copy($logger->file,\*STDERR)}else {warn "See $self->{home}/build.log for details.\n";warn "You may want to execute cpm with --show-build-log-on-failure,\n";warn "so that the build.log is automatically dumped on failure.\n"}return 1}}$master->add_task(type=>"resolve",%$_)for @$packages;$master->add_distribution($_)for @$dists;$self->install($master,$worker,$self->{workers});my$fail=$master->fail;if ($fail){local$App::cpm::Logger::VERBOSE=0;for my$type (qw(install resolve)){App::cpm::Logger->log(result=>"FAIL",type=>$type,message=>$_)for @{$fail->{$type}}}}print STDERR "\r" if$self->{show_progress};warn sprintf "%d distribution%s installed.\n",$master->installed_distributions,$master->installed_distributions > 1 ? "s" : "";$self->cleanup;if ($fail){if ($self->{show_build_log_on_failure}){File::Copy::copy($logger->file,\*STDERR)}else {warn "See $self->{home}/build.log for details.\n";warn "You may want to execute cpm with --show-build-log-on-failure,\n";warn "so that the build.log is automatically dumped on failure.\n"}return 1}else {return 0}}sub install {my ($self,$master,$worker,$num)=@_;my$pipes=Parallel::Pipes->new($num,sub {my$task=shift;return$worker->work($task)});my$get_task;$get_task=sub {my$master=shift;if (my@task=$master->get_task){return@task}if (my@written=$pipes->is_written){my@ready=$pipes->is_ready(@written);$master->register_result($_->read)for@ready;return$master->$get_task}else {return}};while (my@task=$master->$get_task){my@ready=$pipes->is_ready;$master->register_result($_->read)for grep $_->is_written,@ready;for my$i (0 .. List::Util::min($#task,$#ready)){$task[$i]->in_charge(1);$ready[$i]->write($task[$i])}}$pipes->close}sub cleanup {my$self=shift;my$week=time - 7*24*60*60;my@entry=glob "$self->{home}/build.log.*";if (opendir my$dh,"$self->{home}/work"){push@entry,map File::Spec->catdir("$self->{home}/work",$_),grep!/^\.{1,2}$/,readdir$dh}for my$entry (@entry){my$mtime=(stat$entry)[9];if ($mtime < $week){if (-d $entry){File::Path::rmtree($entry)}else {unlink$entry}}}}sub initial_task {my ($self,$master)=@_;if (!$self->{argv}){my ($requirement,$reinstall,$resolver)=$self->load_dependency_file;my ($is_satisfied,@need_resolve)=$master->is_satisfied($requirement);if (!@$reinstall and $is_satisfied){warn "All requirements are satisfied.\n";return}elsif (!defined$is_satisfied){my ($req)=grep {$_->{package}eq "perl"}@$requirement;die sprintf "%s requires perl %s, but you have only %s\n",$self->{dependency_file}{path},$req->{version_range},$self->{target_perl}|| $]}my@package=(@need_resolve,@$reinstall);return (\@package,[],$resolver)}$self->{mirror}||= $self->{_default_mirror};my (@package,@dist);for (@{$self->{argv}}){my$arg=$_;my ($package,$dist);if (-d $arg || -f $arg || $arg =~ s{^file://}{}){$arg=maybe_abs($arg,$self->{cwd});$dist=App::cpm::Distribution->new(source=>"local",uri=>"file://$arg",provides=>[])}elsif ($arg =~ /(?:^git:|\.git(?:@.+)?$)/){my%ref=$arg =~ s/(?<=\.git)@(.+)$// ? (ref=>$1): ();$dist=App::cpm::Distribution->new(source=>"git",uri=>$arg,provides=>[],%ref)}elsif ($arg =~ m{^(https?|file)://}){my ($source,$distfile)=($1 eq "file" ? "local" : "http",undef);if (my$d=App::cpm::DistNotation->new_from_uri($arg)){($source,$distfile)=("cpan",$d->distfile)}$dist=App::cpm::Distribution->new(source=>$source,uri=>$arg,$distfile ? (distfile=>$distfile): (),provides=>[],)}elsif (my$d=App::cpm::DistNotation->new_from_dist($arg)){$dist=App::cpm::Distribution->new(source=>"cpan",uri=>$d->cpan_uri($self->{mirror}),distfile=>$d->distfile,provides=>[],)}else {my ($name,$version_range,$dev);$arg =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;if ($arg =~ /\~[v\d\._,\!<>= ]+$/){($name,$version_range)=split '~',$arg,2}else {$arg =~ s/[~@]dev$// and $dev++;$name=$arg}$package=+{package=>$name,version_range=>$version_range || 0,dev=>$dev,reinstall=>$self->{reinstall},}}push@package,$package if$package;push@dist,$dist if$dist}return (\@package,\@dist,undef)}sub load_dependency_file {my$self=shift;my$cpmfile;if ($self->{dependency_file}{type}eq "cpmfile"){$cpmfile=Module::cpmfile->load($self->{dependency_file}{path})}else {my$cpanfile=Module::CPANfile->load($self->{dependency_file}{path});$cpmfile=Module::cpmfile->from_cpanfile($cpanfile)}if (!$self->{mirror}){my$mirrors=$cpmfile->{_mirrors}|| [];if (@$mirrors){$self->{mirror}=$self->normalize_mirror($mirrors->[0])}else {$self->{mirror}=$self->{_default_mirror}}}my@phase=grep$self->{"with_$_"},qw(configure build test runtime develop);my@type=grep$self->{"with_$_"},qw(requires recommends suggests);my$reqs=$cpmfile->effective_requirements($self->{feature},\@phase,\@type);my (@package,@reinstall);for my$package (sort keys %$reqs){my$options=$reqs->{$package};my$req={package=>$package,version_range=>$options->{version},dev=>$options->{dev},reinstall=>$options->{git}? 1 : 0,};if ($options->{git}){push@reinstall,$req}else {push@package,$req}}require App::cpm::Resolver::Custom;my$resolver=App::cpm::Resolver::Custom->new(requirements=>$reqs,mirror=>$self->{mirror},from=>$self->{dependency_file}{type},);return (\@package,\@reinstall,$resolver->effective ? $resolver : undef)}sub generate_resolver {my ($self,$initial)=@_;my$cascade=App::cpm::Resolver::Cascade->new;$cascade->add($initial)if$initial;if (@{$self->{resolver}}){for (@{$self->{resolver}}){my ($klass,@arg)=split /,/,$_;my$resolver;if ($klass =~ /^metadb$/i){my ($uri,$mirror);if (@arg > 1){($uri,$mirror)=@arg}elsif (@arg==1){$mirror=$arg[0]}else {$mirror=$self->{mirror}}$resolver=App::cpm::Resolver::MetaDB->new($uri ? (uri=>$uri): (),mirror=>$self->normalize_mirror($mirror),)}elsif ($klass =~ /^metacpan$/i){$resolver=App::cpm::Resolver::MetaCPAN->new(dev=>$self->{dev})}elsif ($klass =~ /^02packages?$/i){require App::cpm::Resolver::02Packages;my ($path,$mirror);if (@arg > 1){($path,$mirror)=@arg}elsif (@arg==1){$mirror=$arg[0]}else {$mirror=$self->{mirror}}$resolver=App::cpm::Resolver::02Packages->new($path ? (path=>$path): (),cache=>"$self->{home}/sources",mirror=>$self->normalize_mirror($mirror),)}elsif ($klass =~ /^snapshot$/i){require App::cpm::Resolver::Snapshot;$resolver=App::cpm::Resolver::Snapshot->new(path=>$self->{snapshot},mirror=>@arg ? $self->normalize_mirror($arg[0]): $self->{mirror},)}else {my$full_klass=$klass =~ s/^\+// ? $klass : "App::cpm::Resolver::$klass";(my$file=$full_klass)=~ s{::}{/}g;require "$file.pm";$resolver=$full_klass->new(@arg)}$cascade->add($resolver)}return$cascade}if ($self->{mirror_only}){require App::cpm::Resolver::02Packages;my$resolver=App::cpm::Resolver::02Packages->new(mirror=>$self->{mirror},cache=>"$self->{home}/sources",);$cascade->add($resolver);return$cascade}if (!$self->{argv}and -f $self->{snapshot}){if (!eval {require App::cpm::Resolver::Snapshot}){die "To load $self->{snapshot}, you need to install Carton::Snapshot.\n"}warn "Loading distributions from $self->{snapshot}...\n";my$resolver=App::cpm::Resolver::Snapshot->new(path=>$self->{snapshot},mirror=>$self->{mirror},);$cascade->add($resolver)}my$resolver=App::cpm::Resolver::MetaCPAN->new($self->{dev}? (dev=>1): (only_dev=>1));$cascade->add($resolver);$resolver=App::cpm::Resolver::MetaDB->new(uri=>$self->{cpanmetadb},mirror=>$self->{mirror},);$cascade->add($resolver);if (!$self->{dev}){$resolver=App::cpm::Resolver::MetaCPAN->new;$cascade->add($resolver)}$cascade}1;
APP_CPM_CLI

$fatpacked{"App/cpm/CircularDependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_CIRCULARDEPENDENCY';
  package App::cpm::CircularDependency;use strict;use warnings;{package App::cpm::CircularDependency::OrderedSet;sub new {my$class=shift;bless {index=>0,hash=>+{}},$class}sub add {my ($self,$name)=@_;$self->{hash}{$name}=$self->{index}++}sub exists {my ($self,$name)=@_;exists$self->{hash}{$name}}sub values {my$self=shift;sort {$self->{hash}{$a}<=> $self->{hash}{$b}}keys %{$self->{hash}}}sub clone {my$self=shift;my$new=(ref$self)->new;$new->add($_)for$self->values;$new}}sub _uniq {my%u;grep!$u{$_}++,@_}sub new {my$class=shift;bless {_tmp=>{}},$class}sub add {my ($self,$distfile,$provides,$requirements)=@_;$self->{_tmp}{$distfile}=+{provides=>[map $_->{package},@$provides ],requirements=>[map $_->{package},@$requirements ],}}sub finalize {my$self=shift;for my$distfile (sort keys %{$self->{_tmp}}){$self->{$distfile}=[_uniq map$self->_find($_),@{$self->{_tmp}{$distfile}{requirements}}]}delete$self->{_tmp};return}sub _find {my ($self,$package)=@_;for my$distfile (sort keys %{$self->{_tmp}}){if (grep {$_ eq $package}@{$self->{_tmp}{$distfile}{provides}}){return$distfile}}return}sub detect {my$self=shift;my%result;for my$distfile (sort keys %$self){my$seen=App::cpm::CircularDependency::OrderedSet->new;$seen->add($distfile);if (my$detected=$self->_detect($distfile,$seen)){$result{$distfile}=$detected}}return \%result}sub _detect {my ($self,$distfile,$seen)=@_;for my$req (@{$self->{$distfile}}){if ($seen->exists($req)){return [$seen->values,$req]}my$clone=$seen->clone;$clone->add($req);if (my$detected=$self->_detect($req,$clone)){return$detected}}return}1;
APP_CPM_CIRCULARDEPENDENCY

$fatpacked{"App/cpm/DistNotation.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_DISTNOTATION';
  package App::cpm::DistNotation;use strict;use warnings;my$A1=q{[A-Z]};my$A2=q{[A-Z]{2}};my$AUTHOR=qr{[A-Z]{2}[\-A-Z0-9]*};our$CPAN_URI=qr{^(.*)/authors/id/($A1/$A2/$AUTHOR/.*)$}o;our$DISTFILE=qr{^(?:$A1/$A2/)?($AUTHOR)/(.*)$}o;sub new {my$class=shift;bless {mirror=>'',distfile=>'',},$class}sub new_from_dist {my$self=shift->new;my$dist=shift;if ($dist =~ $DISTFILE){my$author=$1;my$rest=$2;$self->{distfile}=sprintf "%s/%s/%s/%s",substr($author,0,1),substr($author,0,2),$author,$rest;return$self}return}sub new_from_uri {my$self=shift->new;my$uri=shift;if ($uri =~ $CPAN_URI){$self->{mirror}=$1;$self->{distfile}=$2;return$self}return}sub cpan_uri {my$self=shift;my$mirror=shift || $self->{mirror};$mirror =~ s{/+$}{};sprintf "%s/authors/id/%s",$mirror,$self->{distfile}}sub distfile {shift->{distfile}}1;
APP_CPM_DISTNOTATION

$fatpacked{"App/cpm/Distribution.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_DISTRIBUTION';
  package App::cpm::Distribution;use strict;use warnings;use App::cpm::Logger;use App::cpm::Requirement;use App::cpm::version;use CPAN::DistnameInfo;use constant STATE_REGISTERED=>0b000001;use constant STATE_DEPS_REGISTERED=>0b000010;use constant STATE_RESOLVED=>0b000100;use constant STATE_FETCHED=>0b001000;use constant STATE_CONFIGURED=>0b010000;use constant STATE_INSTALLED=>0b100000;sub new {my ($class,%option)=@_;my$uri=delete$option{uri};my$distfile=delete$option{distfile};my$source=delete$option{source}|| "cpan";my$provides=delete$option{provides}|| [];bless {%option,provides=>$provides,uri=>$uri,distfile=>$distfile,source=>$source,_state=>STATE_RESOLVED,requirements=>{},},$class}sub requirements {my ($self,$phase,$req)=@_;if (ref$phase){my$req=App::cpm::Requirement->new;for my$p (@$phase){if (my$r=$self->{requirements}{$p}){$req->merge($r)}}return$req}$self->{requirements}{$phase}=$req if$req;$self->{requirements}{$phase}|| App::cpm::Requirement->new}for my$attr (qw(source directory distdata meta uri provides ref static_builder prebuilt)){no strict 'refs';*$attr=sub {my$self=shift;$self->{$attr}=shift if @_;$self->{$attr}}}sub distfile {my$self=shift;$self->{distfile}=shift if @_;$self->{distfile}|| $self->{uri}}sub distvname {my$self=shift;$self->{distvname}||= do {CPAN::DistnameInfo->new($self->{distfile})->distvname || $self->distfile}}sub overwrite_provide {my ($self,$provide)=@_;my$overwrote;for my$exist (@{$self->{provides}}){if ($exist->{package}eq $provide->{package}){$exist=$provide;$overwrote++}}if (!$overwrote){push @{$self->{provides}},$provide}return 1}sub registered {my$self=shift;if (@_ && $_[0]){$self->{_state}|= STATE_REGISTERED}$self->{_state}& STATE_REGISTERED}sub deps_registered {my$self=shift;if (@_ && $_[0]){$self->{_state}|= STATE_DEPS_REGISTERED}$self->{_state}& STATE_DEPS_REGISTERED}sub resolved {my$self=shift;if (@_ && $_[0]){$self->{_state}=STATE_RESOLVED}$self->{_state}& STATE_RESOLVED}sub fetched {my$self=shift;if (@_ && $_[0]){$self->{_state}=STATE_FETCHED}$self->{_state}& STATE_FETCHED}sub configured {my$self=shift;if (@_ && $_[0]){$self->{_state}=STATE_CONFIGURED}$self->{_state}& STATE_CONFIGURED}sub installed {my$self=shift;if (@_ && $_[0]){$self->{_state}=STATE_INSTALLED}$self->{_state}& STATE_INSTALLED}sub providing {my ($self,$package,$version_range)=@_;for my$provide (@{$self->provides}){if ($provide->{package}eq $package){if (!$version_range or App::cpm::version->parse($provide->{version})->satisfy($version_range)){return 1}else {my$message=sprintf "%s provides %s (%s), but needs %s\n",$self->distfile,$package,$provide->{version}|| 0,$version_range;App::cpm::Logger->log(result=>"WARN",message=>$message);last}}}return}sub equals {my ($self,$that)=@_;$self->distfile && $that->distfile and $self->distfile eq $that->distfile}1;
APP_CPM_DISTRIBUTION

$fatpacked{"App/cpm/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_HTTP';
  package App::cpm::HTTP;use strict;use warnings;use App::cpm;use HTTP::Tinyish;sub create {my ($class,%args)=@_;my$wantarray=wantarray;my@try=$args{prefer}? @{$args{prefer}}: qw(HTTPTiny LWP Curl Wget);my ($backend,$tool,$desc);for my$try (map "HTTP::Tinyish::$_",@try){my$meta=HTTP::Tinyish->configure_backend($try)or next;$try->supports("https")or next;($tool)=sort keys %$meta;($desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$backend=$try,last}die "Couldn't find HTTP Clients that support https" unless$backend;my$http=$backend->new(agent=>"App::cpm/$App::cpm::VERSION",timeout=>60,verify_SSL=>1,%args,);my$keep_alive=exists$args{keep_alive}? $args{keep_alive}: 1;if ($keep_alive and $backend =~ /LWP$/){$http->{ua}->conn_cache({total_capacity=>1 })}$wantarray ? ($http,"$tool $desc"): $http}1;
APP_CPM_HTTP

$fatpacked{"App/cpm/Installer/Unpacker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_INSTALLER_UNPACKER';
  package App::cpm::Installer::Unpacker;use strict;use warnings;use File::Basename ();use File::Temp ();use File::Which ();use IPC::Run3 ();sub run3 {my ($cmd,$outfile)=@_;my$out;IPC::Run3::run3$cmd,\undef,($outfile ? $outfile : \$out),\my$err;return ($?,$out,$err)}sub new {my ($class,%argv)=@_;my$self=bless \%argv,$class;$self->_init_untar;$self->_init_unzip;$self}sub unpack {my ($self,$file)=@_;my$method=$file =~ /\.zip$/ ? $self->{method}{unzip}: $self->{method}{untar};$self->$method($file)}sub describe {my$self=shift;my%describe=(map {($_,$self->{$_})}grep$self->{$_},qw(gzip bzip2 Archive::Tar unzip Archive::Zip),);if ($self->{tar}){$describe{tar}=sprintf "%s (%s%s)",$self->{tar},$self->{tar_kind},$self->{tar_bad}? ", will be used together with gzip/bzip2" : "",}\%describe}sub _init_untar {my$self=shift;my$tar=$self->{tar}=File::Which::which('gtar')|| File::Which::which("tar");if ($tar){my ($exit,$out,$err)=run3 [$tar,'--version'];if ($out =~ /bsdtar/){$self->{tar_kind}='bsd'}elsif ($out =~ /GNU/){$self->{tar_kind}='gnu'}elsif ($^O eq 'openbsd'){$self->{tar_kind}='openbsd'}else {$self->{tar_kind}='unknown'}$self->{tar_bad}=1 if$out =~ /GNU.*1\.13/i || $^O eq 'MSWin32' || $^O eq 'solaris' || $^O eq 'hpux'}if ($tar and!$self->{tar_bad}){$self->{method}{untar}=*_untar;return if!$self->{_init_all}}my$gzip=$self->{gzip}=File::Which::which("gzip");my$bzip2=$self->{bzip2}=File::Which::which("bzip2");if ($tar && $gzip && $bzip2){$self->{method}{untar}=*_untar_bad;return if!$self->{_init_all}}if (eval {require Archive::Tar}){$self->{"Archive::Tar"}=Archive::Tar->VERSION;$self->{method}{untar}=*_untar_module;return if!$self->{_init_all}}return if$self->{_init_all};$self->{method}{untar}=sub {die "There is no backend for untar"}}sub _init_unzip {my$self=shift;my$unzip=$self->{unzip}=File::Which::which("unzip");if ($unzip){$self->{method}{unzip}=*_unzip;return if!$self->{_init_all}}if (eval {require Archive::Zip}){$self->{"Archive::Zip"}=Archive::Zip->VERSION;$self->{method}{unzip}=*_unzip_module;return if!$self->{_init_all}}return if$self->{_init_all};$self->{method}{unzip}=sub {die "There is no backend for unzip"}}sub _untar {my ($self,$file)=@_;my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? 'j' : 'z';($exit,$out,$err)=run3 [$self->{tar},"${ar}tf",$file];last if$exit!=0;my$root=$self->_find_tarroot(split /\r?\n/,$out);my@no_same_owner=$self->{tar_kind}eq 'openbsd' ? (): ('-o');($exit,$out,$err)=run3 [$self->{tar},"${ar}xf",$file,@no_same_owner];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_bad {my ($self,$file)=@_;my$wantarray=wantarray;my ($exit,$out,$err);{my$ar=$file =~ /\.bz2$/ ? $self->{bzip2}: $self->{gzip};my$temp=File::Temp->new(SUFFIX=>'.tar',EXLOCK=>0);($exit,$out,$err)=run3 [$ar,"-dc",$file],$temp->filename;last if$exit!=0;my@opt=$^O eq 'MSWin32' && $self->{tar_kind}ne "bsd" ? ('--force-local'): ();($exit,$out,$err)=run3 [$self->{tar},@opt,"-tf",$temp->filename];last if$exit!=0 ||!$out;my$root=$self->_find_tarroot(split /\r?\n/,$out);($exit,$out,$err)=run3 [$self->{tar},@opt,"-xf",$temp->filename,"-o"];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _untar_module {my ($self,$file)=@_;my$wantarray=wantarray;no warnings 'once';local$Archive::Tar::WARN=0;my$t=Archive::Tar->new;{my$ok=$t->read($file);last if!$ok;my$root=$self->_find_tarroot($t->list_files);my@file=$t->extract;return$root if@file and -d $root}return if!$wantarray;return (undef,$t->error)}sub _find_tarroot {my ($self,$root,@others)=@_;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length$root){$root=shift@others;redo FILE if$root}}$root}sub _unzip {my ($self,$file)=@_;my$wantarray=wantarray;my ($exit,$out,$err);{($exit,$out,$err)=run3 [$self->{unzip},'-t',$file];last if$exit!=0;my$root=$self->_find_ziproot(split /\r?\n/,$out);($exit,$out,$err)=run3 [$self->{unzip},'-q',$file];return$root if$exit==0 and -d $root}return if!$wantarray;return (undef,$err || $out)}sub _unzip_module {my ($self,$file)=@_;my$wantarray=wantarray;no warnings 'once';my$err='';local$Archive::Zip::ErrorHandler=sub {$err .= "@_"};my$zip=Archive::Zip->new;UNZIP: {my$status=$zip->read($file);last UNZIP if$status!=Archive::Zip::AZ_OK();for my$member ($zip->members){my$af=$member->fileName;next if$af =~ m!^(/|\.\./)!;my$status=$member->extractToFileNamed($af);last UNZIP if$status!=Archive::Zip::AZ_OK()}my ($root)=$zip->membersMatching(qr{^[^/]+/$});last UNZIP if!$root;$root=$root->fileName;$root =~ s{/$}{};return$root if -d $root}return if!$wantarray;return (undef,$err)}sub _find_ziproot {my ($self,undef,$root,@others)=@_;FILE: {chomp$root;if ($root !~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1}){$root=shift@others;redo FILE if$root}}$root}1;
APP_CPM_INSTALLER_UNPACKER

$fatpacked{"App/cpm/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_LOGGER';
  package App::cpm::Logger;use strict;use warnings;use App::cpm::Util 'WIN32';use List::Util 'max';our$COLOR;our$VERBOSE;our$SHOW_PROGRESS;my%color=(resolve=>33,fetch=>34,configure=>35,install=>36,FAIL=>31,DONE=>32,WARN=>33,);our$HAS_WIN32_COLOR;sub new {my$class=shift;bless {@_},$class}sub log {my ($self,%option)=@_;my$type=$option{type}|| "";my$message=$option{message};chomp$message;my$optional=$option{optional}? " ($option{optional})" : "";my$result=$option{result};my$is_color=ref$self ? $self->{color}: $COLOR;my$verbose=ref$self ? $self->{verbose}: $VERBOSE;my$show_progress=ref$self ? $self->{show_progress}: $SHOW_PROGRESS;if ($is_color and WIN32){if (!defined$HAS_WIN32_COLOR){$HAS_WIN32_COLOR=eval {require Win32::Console::ANSI;1}? 1 : 0}$is_color=0 unless$HAS_WIN32_COLOR}if ($is_color){$type="\e[$color{$type}m$type\e[m" if$type && $color{$type};$result="\e[$color{$result}m$result\e[m" if$result && $color{$result};$optional="\e[1;37m$optional\e[m" if$optional}my$r=$show_progress ? "\r" : "";if ($verbose){$type=$is_color && $type ? sprintf("%-17s",$type): sprintf("%-9s",$type || "");warn$r .sprintf "%d %s %s %s%s\n",$option{pid}|| $$,$result,$type,$message,$optional}else {warn$r .join(" ",$result,$type ? $type : (),$message .$optional)."\n"}}1;
APP_CPM_LOGGER

$fatpacked{"App/cpm/Logger/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_LOGGER_FILE';
  package App::cpm::Logger::File;use strict;use warnings;use App::cpm::Util 'WIN32';use File::Temp ();use POSIX ();sub new {my ($class,$file)=@_;my$fh;if (WIN32){require IO::File;$file ||= File::Temp::tmpnam()}elsif ($file){open$fh,">>:unix",$file or die "$file: $!"}else {($fh,$file)=File::Temp::tempfile(UNLINK=>1)}bless {context=>'',fh=>$fh,file=>$file,pid=>'',},$class}sub symlink_to {my ($self,$dest)=@_;unlink$dest;if (!eval {symlink$self->file,$dest}){$self->{file}=$dest}}sub file {shift->{file}}sub prefix {my$self=shift;my$pid=$self->{pid}|| $$;$self->{context}? "$pid,$self->{context}" : $pid}sub log {my ($self,@line)=@_;my$now=POSIX::strftime('%Y-%m-%dT%H:%M:%S',localtime);my$prefix=$self->prefix;local$self->{fh}=IO::File->new($self->{file},'a')if WIN32;for my$line (@line){chomp$line;print {$self->{fh}}"$now,$prefix| $_\n" for split /\n/,$line}}sub log_with_fh {my ($self,$fh)=@_;my$prefix=$self->prefix;local$self->{fh}=IO::File->new($self->{file},'a')if WIN32;while (my$line=<$fh>){chomp$line;print {$self->{fh}}"@{[POSIX::strftime('%Y-%m-%dT%H:%M:%S', localtime)]},$prefix| $line\n"}}1;
APP_CPM_LOGGER_FILE

$fatpacked{"App/cpm/Master.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_MASTER';
  package App::cpm::Master;use strict;use warnings;use App::cpm::CircularDependency;use App::cpm::Distribution;use App::cpm::Logger;use App::cpm::Task;use App::cpm::version;use CPAN::DistnameInfo;use IO::Handle;use Module::Metadata;sub new {my ($class,%option)=@_;my$self=bless {%option,installed_distributions=>0,tasks=>+{},distributions=>+{},_fail_resolve=>+{},_fail_install=>+{},_is_installed=>+{},},$class;if ($self->{target_perl}){require Module::CoreList;if (!exists$Module::CoreList::version{$self->{target_perl}}){die "Module::CoreList does not have target perl $self->{target_perl} entry, abort.\n"}if (!exists$Module::CoreList::version{$]}){die "Module::CoreList does not have our perl $] entry, abort.\n"}}if (!$self->{global}){if (eval {require Module::CoreList}){if (!exists$Module::CoreList::version{$]}){die "Module::CoreList does not have our perl $] entry, abort.\n"}$self->{_has_corelist}=1}else {my$msg="You don't have Module::CoreList. " ."The local-lib may result in incomplete self-contained directory.";App::cpm::Logger->log(result=>"WARN",message=>$msg)}}$self}sub fail {my$self=shift;my@fail_resolve=sort keys %{$self->{_fail_resolve}};my@fail_install=sort keys %{$self->{_fail_install}};my@not_installed=grep {!$self->{_fail_install}{$_->distfile}&&!$_->installed}$self->distributions;return if!@fail_resolve &&!@fail_install &&!@not_installed;my$detector=App::cpm::CircularDependency->new;for my$dist (@not_installed){my$req=$dist->requirements([qw(configure build test runtime)])->as_array;$detector->add($dist->distfile,$dist->provides,$req)}$detector->finalize;my$detected=$detector->detect;for my$distfile (sort keys %$detected){my$distvname=$self->distribution($distfile)->distvname;my@circular=@{$detected->{$distfile}};my$msg=join " -> ",map {$self->distribution($_)->distvname}@circular;local$self->{logger}{context}=$distvname;$self->{logger}->log("Detected circular dependencies $msg");$self->{logger}->log("Failed to install distribution")}for my$dist (sort {$a->distvname cmp $b->distvname}grep {!$detected->{$_->distfile}}@not_installed){local$self->{logger}{context}=$dist->distvname;$self->{logger}->log("Failed to install distribution, " ."because of installing some dependencies failed")}my@fail_install_name=map {CPAN::DistnameInfo->new($_)->distvname || $_}@fail_install;my@not_installed_name=map {$_->distvname}@not_installed;if (@fail_resolve || @fail_install_name){$self->{logger}->log("--");$self->{logger}->log("Installation failed. " ."The direct cause of the failure comes from the following packages/distributions; " ."you may want to grep this log file by them:");$self->{logger}->log(" * $_")for@fail_resolve,sort@fail_install_name}{resolve=>\@fail_resolve,install=>[sort@fail_install_name,@not_installed_name]}}sub tasks {values %{shift->{tasks}}}sub add_task {my ($self,%task)=@_;my$new=App::cpm::Task->new(%task);if (grep {$_->equals($new)}$self->tasks){return 0}else {$self->{tasks}{$new->uid}=$new;return 1}}sub get_task {my$self=shift;if (my@task=grep {!$_->in_charge}$self->tasks){return@task}$self->_calculate_tasks;return unless$self->tasks;if (my@task=grep {!$_->in_charge}$self->tasks){return@task}return}sub register_result {my ($self,$result)=@_;my ($task)=grep {$_->uid eq $result->{uid}}$self->tasks;die "Missing task that has uid=$result->{uid}" unless$task;%{$task}=%{$result};my$logged=$self->info($task);my$method="_register_@{[$task->{type}]}_result";$self->$method($task);$self->remove_task($task);$self->_show_progress if$logged && $self->{show_progress};return 1}sub info {my ($self,$task)=@_;my$type=$task->type;return if!$App::cpm::Logger::VERBOSE && $type ne "install";my$name=$task->distvname;my ($message,$optional);if ($type eq "resolve"){$message=$task->{package};$message .= " -> $name" .($task->{ref}? "\@$task->{ref}" : "")if$task->{ok};$optional="from $task->{from}" if$task->{ok}and $task->{from}}else {$message=$name;$optional="using cache" if$type eq "fetch" and $task->{using_cache};$optional="using prebuilt" if$task->{prebuilt}}my$elapsed=defined$task->{elapsed}? sprintf "(%.3fsec) ",$task->{elapsed}: "";App::cpm::Logger->log(pid=>$task->{pid},type=>$type,result=>$task->{ok}? "DONE" : "FAIL",message=>"$elapsed$message",optional=>$optional,);return 1}sub _show_progress {my$self=shift;my$all=keys %{$self->{distributions}};my$num=$self->installed_distributions;print STDERR "--- $num/$all ---";STDERR->flush}sub remove_task {my ($self,$task)=@_;delete$self->{tasks}{$task->uid}}sub distributions {values %{shift->{distributions}}}sub distribution {my ($self,$distfile)=@_;$self->{distributions}{$distfile}}sub _calculate_tasks {my$self=shift;my@distributions =grep {!$self->{_fail_install}{$_->distfile}}$self->distributions;if (my@dists=grep {$_->resolved &&!$_->registered}@distributions){for my$dist (@dists){$dist->registered(1);$self->add_task(type=>"fetch",distfile=>$dist->{distfile},source=>$dist->source,uri=>$dist->uri,ref=>$dist->ref,)}}if (my@dists=grep {$_->fetched &&!$_->registered}@distributions){for my$dist (@dists){local$self->{logger}->{context}=$dist->distvname;my$dist_requirements=$dist->requirements('configure')->as_array;my ($is_satisfied,@need_resolve)=$self->is_satisfied($dist_requirements);if ($is_satisfied){$dist->registered(1);$self->add_task(type=>"configure",meta=>$dist->meta,directory=>$dist->directory,distfile=>$dist->{distfile},source=>$dist->source,uri=>$dist->uri,distvname=>$dist->distvname,)}elsif (@need_resolve and!$dist->deps_registered){$dist->deps_registered(1);my$msg=sprintf "Found configure dependencies: %s",join(", ",map {sprintf "%s (%s)",$_->{package},$_->{version_range}|| 0}@need_resolve);$self->{logger}->log($msg);my$ok=$self->_register_resolve_task(@need_resolve);$self->{_fail_install}{$dist->distfile}++ unless$ok}elsif (!defined$is_satisfied){my ($req)=grep {$_->{package}eq "perl"}@$dist_requirements;my$msg=sprintf "%s requires perl %s, but you have only %s",$dist->distvname,$req->{version_range},$self->{target_perl}|| $];$self->{logger}->log($msg);App::cpm::Logger->log(result=>"FAIL",message=>$msg);$self->{_fail_install}{$dist->distfile}++}}}if (my@dists=grep {$_->configured &&!$_->registered}@distributions){for my$dist (@dists){local$self->{logger}->{context}=$dist->distvname;my@phase=qw(build test runtime);push@phase,'configure' if$dist->prebuilt;my$dist_requirements=$dist->requirements(\@phase)->as_array;my ($is_satisfied,@need_resolve)=$self->is_satisfied($dist_requirements);if ($is_satisfied){$dist->registered(1);$self->add_task(type=>"install",meta=>$dist->meta,distdata=>$dist->distdata,directory=>$dist->directory,distfile=>$dist->{distfile},uri=>$dist->uri,static_builder=>$dist->static_builder,prebuilt=>$dist->prebuilt,)}elsif (@need_resolve and!$dist->deps_registered){$dist->deps_registered(1);my$msg=sprintf "Found dependencies: %s",join(", ",map {sprintf "%s (%s)",$_->{package},$_->{version_range}|| 0}@need_resolve);$self->{logger}->log($msg);my$ok=$self->_register_resolve_task(@need_resolve);$self->{_fail_install}{$dist->distfile}++ unless$ok}elsif (!defined$is_satisfied){my ($req)=grep {$_->{package}eq "perl"}@$dist_requirements;my$msg=sprintf "%s requires perl %s, but you have only %s",$dist->distvname,$req->{version_range},$self->{target_perl}|| $];$self->{logger}->log($msg);App::cpm::Logger->log(result=>"FAIL",message=>$msg);$self->{_fail_install}{$dist->distfile}++}}}}sub _register_resolve_task {my ($self,@package)=@_;my$ok=1;for my$package (@package){if ($self->{_fail_resolve}{$package->{package}}|| $self->{_fail_install}{$package->{package}}){$ok=0;next}$self->add_task(type=>"resolve",package=>$package->{package},version_range=>$package->{version_range},)}return$ok}sub is_satisfied_perl_version {my ($self,$version_range)=@_;App::cpm::version->parse($self->{target_perl}|| $])->satisfy($version_range)}sub is_installed {my ($self,$package,$version_range)=@_;my$wantarray=wantarray;if (exists$self->{_is_installed}{$package}){if ($self->{_is_installed}{$package}->satisfy($version_range)){return$wantarray ? (1,$self->{_is_installed}{$package}): 1}}my$info=Module::Metadata->new_from_module($package,inc=>$self->{search_inc});return unless$info;if (!$self->{global}and $self->{_has_corelist}and $self->_in_core_inc($info->filename)){return if!exists$Module::CoreList::version{$]}{$info->name}}my$current_version=$self->{_is_installed}{$package}=App::cpm::version->parse($info->version);my$ok=$current_version->satisfy($version_range);$wantarray ? ($ok,$current_version): $ok}sub _in_core_inc {my ($self,$file)=@_;!!grep {$file =~ /^\Q$_/}@{$self->{core_inc}}}sub is_core {my ($self,$package,$version_range)=@_;my$target_perl=$self->{target_perl};if (exists$Module::CoreList::version{$target_perl}{$package}){if (!exists$Module::CoreList::version{$]}{$package}){if (!$self->{_removed_core}{$package}++){my$t=App::cpm::version->parse($target_perl)->normal;my$v=App::cpm::version->parse($])->normal;App::cpm::Logger->log(result=>"WARN",message=>"$package used to be core in $t, but not in $v, so will be installed",)}return}return 1 unless$version_range;my$core_version=$Module::CoreList::version{$target_perl}{$package};return App::cpm::version->parse($core_version)->satisfy($version_range)}return}sub is_satisfied {my ($self,$requirements)=@_;my$is_satisfied=1;my@need_resolve;my@distributions=$self->distributions;for my$req (@$requirements){my ($package,$version_range)=@{$req}{qw(package version_range)};if ($package eq "perl"){$is_satisfied=undef if!$self->is_satisfied_perl_version($version_range);next}next if$self->{target_perl}and $self->is_core($package,$version_range);next if$self->is_installed($package,$version_range);my ($resolved)=grep {$_->providing($package,$version_range)}@distributions;next if$resolved && $resolved->installed;$is_satisfied=0 if defined$is_satisfied;if (!$resolved){push@need_resolve,$req}}return ($is_satisfied,@need_resolve)}sub add_distribution {my ($self,$distribution)=@_;my$distfile=$distribution->distfile;if (my$already=$self->{distributions}{$distfile}){$already->overwrite_provide($_)for @{$distribution->provides};return 0}else {$self->{distributions}{$distfile}=$distribution;return 1}}sub _register_resolve_result {my ($self,$task)=@_;if (!$task->is_success){$self->{_fail_resolve}{$task->{package}}++;return}local$self->{logger}{context}=$task->{package};if ($task->{distfile}and $task->{distfile}=~ m{/perl-5[^/]+$}){my$message="Cannot upgrade core module $task->{package}.";$self->{logger}->log($message);App::cpm::Logger->log(result=>"FAIL",type=>"install",message=>$message,);$self->{_fail_install}{$task->{package}}++;return}if (!$task->{reinstall}){my$want=$task->{version_range}|| $task->{version};my ($ok,$local)=$self->is_installed($task->{package},$want);if ($ok){my$message=$task->{package}.(App::cpm::version->parse($task->{version})!=$local ? ", you already have $local" : " is up to date. ($local)");$self->{logger}->log($message);App::cpm::Logger->log(result=>"DONE",type=>"install",message=>$message,);return}}my$provides=$task->{provides};if (!$provides or @$provides==0){my$version=App::cpm::version->parse($task->{version})|| 0;$provides=[{package=>$task->{package},version=>$version}]}my$distribution=App::cpm::Distribution->new(source=>$task->{source},uri=>$task->{uri},provides=>$provides,distfile=>$task->{distfile},ref=>$task->{ref},);$self->add_distribution($distribution)}sub _register_fetch_result {my ($self,$task)=@_;if (!$task->is_success){$self->{_fail_install}{$task->distfile}++;return}my$distribution=$self->distribution($task->distfile);$distribution->directory($task->{directory});$distribution->meta($task->{meta});$distribution->provides($task->{provides});if ($task->{prebuilt}){$distribution->configured(1);$distribution->requirements($_=>$task->{requirements}{$_})for keys %{$task->{requirements}};$distribution->prebuilt(1);local$self->{logger}{context}=$distribution->distvname;my$msg=join ", ",map {sprintf "%s (%s)",$_->{package},$_->{version}|| 0}@{$distribution->provides};$self->{logger}->log("Distribution provides: $msg")}else {$distribution->fetched(1);$distribution->requirements($_=>$task->{requirements}{$_})for keys %{$task->{requirements}}}return 1}sub _register_configure_result {my ($self,$task)=@_;if (!$task->is_success){$self->{_fail_install}{$task->distfile}++;return}my$distribution=$self->distribution($task->distfile);$distribution->configured(1);$distribution->requirements($_=>$task->{requirements}{$_})for keys %{$task->{requirements}};$distribution->static_builder($task->{static_builder});$distribution->distdata($task->{distdata});my$p=$task->{distdata}{provides};my@provide=map +{package=>$_,version=>$p->{$_}{version}},sort keys %$p;$distribution->provides(\@provide);local$self->{logger}{context}=$distribution->distvname;my$msg=join ", ",map {sprintf "%s (%s)",$_->{package},$_->{version}|| 0}@{$distribution->provides};$self->{logger}->log("Distribution provides: $msg");return 1}sub _register_install_result {my ($self,$task)=@_;if (!$task->is_success){$self->{_fail_install}{$task->distfile}++;return}my$distribution=$self->distribution($task->distfile);$distribution->installed(1);$self->{installed_distributions}++;return 1}sub installed_distributions {shift->{installed_distributions}}1;
APP_CPM_MASTER

$fatpacked{"App/cpm/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_REQUIREMENT';
  package App::cpm::Requirement;use strict;use warnings;use App::cpm::version;sub new {my$class=shift;my$self=bless {requirement=>[]},$class;$self->add(@_)if @_;$self}sub empty {my$self=shift;@{$self->{requirement}}==0}sub has {my ($self,$package)=@_;my ($found)=grep {$_->{package}eq $package}@{$self->{requirement}};$found}sub add {my$self=shift;my%package=(@_,@_ % 2 ? (0): ());for my$package (sort keys%package){my$version_range=$package{$package};if (my ($found)=grep {$_->{package}eq $package}@{$self->{requirement}}){my$merged=eval {App::cpm::version::range_merge($found->{version_range},$version_range)};if (my$err=$@){if ($err =~ /illegal requirements/){$@="Couldn't merge version range '$version_range' with '$found->{version_range}' for package '$package'";warn $@;return}else {die$err}}$found->{version_range}=$merged}else {push @{$self->{requirement}},{package=>$package,version_range=>$version_range }}}return 1}sub merge {my ($self,$other)=@_;$self->add(map {($_->{package},$_->{version_range})}@{$other->as_array})}sub delete :method {my ($self,@package)=@_;for my$i (reverse 0 .. $#{$self->{requirement}}){my$current=$self->{requirement}[$i]{package};if (grep {$current eq $_}@package){splice @{$self->{requirement}},$i,1}}}sub as_array {my$self=shift;$self->{requirement}}1;
APP_CPM_REQUIREMENT

$fatpacked{"App/cpm/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER';
  package App::cpm::Resolver;use strict;use warnings;1;
APP_CPM_RESOLVER

$fatpacked{"App/cpm/Resolver/02Packages.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_02PACKAGES';
  package App::cpm::Resolver::02Packages;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::HTTP;use App::cpm::version;use CPAN::02Packages::Search;use Cwd ();use File::Basename ();use File::Copy ();use File::Path ();use File::Spec;use File::Which ();use IPC::Run3 ();sub new {my ($class,%option)=@_;my$cache_dir_base=$option{cache}or die "cache option is required\n";my$mirror=$option{mirror}or die "mirror option is required\n";$mirror =~ s{/*$}{/};my$path=$option{path}|| "${mirror}modules/02packages.details.txt.gz";my$cache_dir=$class->_cache_dir($mirror,$cache_dir_base);my$local_path=$class->_fetch($path=>$cache_dir);my$index=CPAN::02Packages::Search->new(file=>$local_path);bless {mirror=>$mirror,local_path=>$local_path,index=>$index },$class}sub _cache_dir {my ($class,$mirror,$base)=@_;if ($mirror !~ m{^https?://}){$mirror =~ s{^file://}{};$mirror=Cwd::abs_path($mirror);$mirror =~ s{^/}{}}$mirror =~ s{/$}{};$mirror =~ s/[^\w\.\-]+/%/g;my$dir="$base/$mirror";File::Path::mkpath([$dir],0,0777);return$dir}sub _fetch {my ($class,$path,$cache_dir)=@_;my$dest=File::Spec->catfile($cache_dir,File::Basename::basename($path));if ($path =~ m{^https?://}){my$res=App::cpm::HTTP->create->mirror($path=>$dest);die "$res->{status} $res->{reason}, $path\n" if!$res->{success}}else {$path =~ s{^file://}{};die "$path: No such file.\n" if!-f $path;if (!-f $dest or (stat$dest)[9]<= (stat$path)[9]){File::Copy::copy($path,$dest)or die "Copy $path $dest: $!\n";my$mtime=(stat$path)[9];utime$mtime,$mtime,$dest}}return$dest if$dest !~ /\.gz$/;my$plain=$dest;$plain =~ s/\.gz$//;if (!-f $plain or (stat$plain)[9]<= (stat$dest)[9]){my$gzip=File::Which::which('gzip');die "Need gzip command to decompress $dest\n" if!$gzip;my@cmd=($gzip,"-dc",$dest);IPC::Run3::run3 \@cmd,undef,$plain,\my$err;if ($?!=0){chomp$err;$err ||= "exit status $?";die "@cmd: $err\n"}}return$plain}sub resolve {my ($self,$task)=@_;my$res=$self->{index}->search($task->{package});if (!$res){return {error=>"not found, @{[$self->{local_path}]}" }}if (my$version_range=$task->{version_range}){my$version=$res->{version}|| 0;if (!App::cpm::version->parse($version)->satisfy($version_range)){return {error=>"found version $version, but it does not satisfy $version_range, @{[$self->{local_path}]}" }}}my$dist=App::cpm::DistNotation->new_from_dist($res->{path});return +{source=>"cpan",distfile=>$dist->distfile,uri=>$dist->cpan_uri($self->{mirror}),version=>$res->{version}|| 0,package=>$task->{package},}}1;
APP_CPM_RESOLVER_02PACKAGES

$fatpacked{"App/cpm/Resolver/Cascade.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_CASCADE';
  package App::cpm::Resolver::Cascade;use strict;use warnings;sub new {my$class=shift;bless {backends=>[]},$class}sub add {my ($self,$resolver)=@_;push @{$self->{backends}},$resolver;$self}sub resolve {my ($self,$task)=@_;my@error;for my$backend (@{$self->{backends}}){my$result=$backend->resolve($task);next unless$result;my$klass=ref$backend;$klass=$1 if$klass =~ /^App::cpm::Resolver::(.*)$/;if (my$error=$result->{error}){push@error,"$klass, $error"}else {$result->{from}=$klass;return$result}}return {error=>join("\n",@error)}}1;
APP_CPM_RESOLVER_CASCADE

$fatpacked{"App/cpm/Resolver/Custom.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_CUSTOM';
  package App::cpm::Resolver::Custom;use strict;use warnings;use App::cpm::DistNotation;sub new {my ($class,%argv)=@_;my$from=$argv{from};my$requirements=$argv{requirements};my$mirror=$argv{mirror}|| 'https://cpan.metacpan.org/';$mirror =~ s{/*$}{/};my$self=bless {from=>$from,mirror=>$mirror,requirements=>$requirements,},$class;$self->_load;$self}sub _load {my$self=shift;my%resolve;for my$package (sort keys %{$self->{requirements}}){my$options=$self->{requirements}{$package};my$uri;if ($uri=$options->{git}){$resolve{$package}={source=>'git',uri=>$uri,ref=>$options->{ref},provides=>[{package=>$package}],}}elsif ($uri=$options->{dist}){my$dist=App::cpm::DistNotation->new_from_dist($uri);die "Unsupported dist '$uri' found in $self->{from}\n" if!$dist;my$cpan_uri=$dist->cpan_uri($options->{mirror}|| $self->{mirror});$resolve{$package}={source=>'cpan',uri=>$cpan_uri,distfile=>$dist->distfile,provides=>[{package=>$package}],}}elsif ($uri=$options->{url}){die "Unsupported url '$uri' found in $self->{from}\n" if$uri !~ m{^(?:https?|file)://};my$dist=App::cpm::DistNotation->new_from_uri($uri);my$source=$dist ? 'cpan' : $uri =~ m{^file://} ? 'local' : 'http';$resolve{$package}={source=>$source,uri=>$dist ? $dist->cpan_uri : $uri,($dist ? (distfile=>$dist->distfile): ()),provides=>[{package=>$package}],}}}$self->{resolve}=\%resolve}sub effective {my$self=shift;%{$self->{resolve}}? 1 : 0}sub resolve {my ($self,$task)=@_;my$found=$self->{resolve}{$task->{package}};if (!$found){return {error=>"not found in $self->{from}" }}$found}1;
APP_CPM_RESOLVER_CUSTOM

$fatpacked{"App/cpm/Resolver/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_METACPAN';
  package App::cpm::Resolver::MetaCPAN;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::HTTP;use JSON::PP ();sub new {my ($class,%option)=@_;my$uri=$option{uri}|| "https://fastapi.metacpan.org/v1/download_url/";$uri =~ s{/*$}{/};my$http=App::cpm::HTTP->create;bless {%option,uri=>$uri,http=>$http },$class}sub _encode {my$str=shift;$str =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;$str}sub resolve {my ($self,$task)=@_;if ($self->{only_dev}and!$task->{dev}){return {error=>"skip, because MetaCPAN is configured to resolve dev releases only" }}my%query=((($self->{dev}|| $task->{dev})? (dev=>1): ()),($task->{version_range}? (version=>$task->{version_range}): ()),);my$query=join "&",map {"$_=" ._encode($query{$_})}sort keys%query;my$uri="$self->{uri}$task->{package}" .($query ? "?$query" : "");my$res;for (1..2){$res=$self->{http}->get($uri);last if$res->{success}or $res->{status}==404}if (!$res->{success}){my$error="$res->{status} $res->{reason}, $uri";$error .= ", $res->{content}" if$res->{status}==599;return {error=>$error }}my$hash=eval {JSON::PP::decode_json($res->{content})}or return;my$dist=App::cpm::DistNotation->new_from_uri($hash->{download_url});return {source=>"cpan",distfile=>$dist->distfile,package=>$task->{package},version=>$hash->{version}|| 0,uri=>$hash->{download_url},}}1;
APP_CPM_RESOLVER_METACPAN

$fatpacked{"App/cpm/Resolver/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_METADB';
  package App::cpm::Resolver::MetaDB;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::HTTP;use App::cpm::version;use CPAN::Meta::YAML;sub new {my ($class,%option)=@_;my$uri=$option{uri}|| "https://cpanmetadb.plackperl.org/v1.0/";my$mirror=$option{mirror}|| "https://cpan.metacpan.org/";s{/*$}{/} for$uri,$mirror;my$http=App::cpm::HTTP->create;bless {%option,http=>$http,uri=>$uri,mirror=>$mirror,},$class}sub _get {my ($self,$uri)=@_;my$res;for (1..2){$res=$self->{http}->get($uri);last if$res->{success}or $res->{status}==404}$res}sub _uniq {my%x;grep {!$x{$_ || ""}++}@_}sub resolve {my ($self,$task)=@_;if (defined$task->{version_range}and $task->{version_range}=~ /(?:<|!=|==)/){my$uri="$self->{uri}history/$task->{package}";my$res=$self->_get($uri);if (!$res->{success}){my$error="$res->{status} $res->{reason}, $uri";$error .= ", $res->{content}" if$res->{status}==599;return {error=>$error }}my@found;for my$line (split /\r?\n/,$res->{content}){if ($line =~ /^$task->{package}\s+(\S+)\s+(\S+)$/){push@found,{version=>$1,version_o=>App::cpm::version->parse($1),distfile=>$2,}}}$found[-1]->{latest}=1;my$match;for my$try (sort {$b->{version_o}<=> $a->{version_o}}@found){if ($try->{version_o}->satisfy($task->{version_range})){$match=$try,last}}if ($match){my$dist=App::cpm::DistNotation->new_from_dist($match->{distfile});return {source=>"cpan",package=>$task->{package},version=>$match->{version},uri=>$dist->cpan_uri($self->{mirror}),distfile=>$dist->distfile,}}else {return {error=>"found versions @{[join ',', _uniq map $_->{version}, @found]}, but they do not satisfy $task->{version_range}, $uri" }}}else {my$uri="$self->{uri}package/$task->{package}";my$res=$self->_get($uri);if (!$res->{success}){my$error="$res->{status} $res->{reason}, $uri";$error .= ", $res->{content}" if$res->{status}==599;return {error=>$error }}my$yaml=CPAN::Meta::YAML->read_string($res->{content});my$meta=$yaml->[0];if (!App::cpm::version->parse($meta->{version})->satisfy($task->{version_range})){return {error=>"found version $meta->{version}, but it does not satisfy $task->{version_range}, $uri" }}my@provides=map {my$package=$_;my$version=$meta->{provides}{$_};$version=undef if$version eq "undef";+{package=>$package,version=>$version }}sort keys %{$meta->{provides}};my$dist=App::cpm::DistNotation->new_from_dist($meta->{distfile});return {source=>"cpan",distfile=>$dist->distfile,uri=>$dist->cpan_uri($self->{mirror}),version=>$meta->{version},provides=>\@provides,}}return}1;
APP_CPM_RESOLVER_METADB

$fatpacked{"App/cpm/Resolver/Snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_RESOLVER_SNAPSHOT';
  package App::cpm::Resolver::Snapshot;use strict;use warnings;use App::cpm::DistNotation;use App::cpm::version;use Carton::Snapshot;sub new {my ($class,%option)=@_;my$snapshot=Carton::Snapshot->new(path=>$option{path}|| "cpanfile.snapshot");$snapshot->load;my$mirror=$option{mirror}|| "https://cpan.metacpan.org/";$mirror =~ s{/*$}{/};bless {%option,mirror=>$mirror,snapshot=>$snapshot },$class}sub snapshot {shift->{snapshot}}sub resolve {my ($self,$task)=@_;my$package=$task->{package};my$found=$self->snapshot->find($package);if (!$found){return {error=>"not found, @{[$self->snapshot->path]}" }}my$version=$found->version_for($package);if (my$version_range=$task->{version_range}){if (!App::cpm::version->parse($version)->satisfy($version_range)){return {error=>"found version $version, but it does not satisfy $version_range, @{[$self->snapshot->path]}" }}}my@provides=map {my$package=$_;my$version=$found->provides->{$_}{version};+{package=>$package,version=>$version }}sort keys %{$found->provides};my$dist=App::cpm::DistNotation->new_from_dist($found->distfile);return {source=>"cpan",distfile=>$dist->distfile,uri=>$dist->cpan_uri($self->{mirror}),version=>$version || 0,provides=>\@provides,}}1;
APP_CPM_RESOLVER_SNAPSHOT

$fatpacked{"App/cpm/Task.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_TASK';
  package App::cpm::Task;use strict;use warnings;use CPAN::DistnameInfo;sub new {my ($class,%option)=@_;my$self=bless {%option},$class;$self->{uid}=$self->_uid;$self}sub uid {shift->{uid}}sub _uid {my$self=shift;my$type=$self->type;if (grep {$type eq $_}qw(fetch configure install)){"$type " .$self->distfile}elsif ($type eq "resolve"){"$type " .$self->{package}}else {die "unknown type: " .($type || "(undef)")}}sub distfile {my$self=shift;$self->{distfile}|| $self->{uri}}sub distvname {my$self=shift;return$self->{_distvname}if$self->{_distvname};if ($self->{distfile}){$self->{_distvname}||= CPAN::DistnameInfo->new($self->{distfile})->distvname}elsif ($self->{uri}){$self->{uri}}elsif ($self->{package}){$self->{package}}else {"UNKNOWN"}}sub distname {my$self=shift;$self->{_distname}||= CPAN::DistnameInfo->new($self->distfile)->dist || 'UNKNOWN'}sub cpanid {my$self=shift;$self->{_cpanid}||= CPAN::DistnameInfo->new($self->distfile)->cpanid || 'UNKNOWN'}sub type {my$self=shift;$self->{type}}sub in_charge {my$self=shift;@_ ? $self->{in_charge}=shift : $self->{in_charge}}sub is_success {my$self=shift;$self->{ok}}sub equals {my ($self,$that)=@_;$self->uid eq $that->uid}sub merge {my ($self,$that)=@_;for my$key (keys %$that){$self->{$key}=$that->{$key}}$self}1;
APP_CPM_TASK

$fatpacked{"App/cpm/Tutorial.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_TUTORIAL';
  package App::cpm::Tutorial;use strict;use warnings;1;
APP_CPM_TUTORIAL

$fatpacked{"App/cpm/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_UTIL';
  package App::cpm::Util;use strict;use warnings;use Config;use Cwd ();use Digest::MD5 ();use File::Spec;use Exporter 'import';our@EXPORT_OK=qw(perl_identity maybe_abs WIN32 determine_home);use constant WIN32=>$^O eq 'MSWin32';sub perl_identity {my$digest=Digest::MD5::md5_hex($Config{perlpath}.Config->myconfig);$digest=substr$digest,0,8;join '-',$Config{version},$Config{archname},$digest}sub maybe_abs {my$path=shift;if (File::Spec->file_name_is_absolute($path)){return$path}my$cwd=shift || Cwd::cwd();File::Spec->canonpath(File::Spec->catdir($cwd,$path))}sub determine_home {my$homedir=$ENV{HOME}|| eval {require File::HomeDir;File::HomeDir->my_home}|| join('',@ENV{qw(HOMEDRIVE HOMEPATH)});if (WIN32){require Win32;$homedir=Win32::GetShortPathName($homedir)}File::Spec->catdir($homedir,".perl-cpm")}1;
APP_CPM_UTIL

$fatpacked{"App/cpm/Worker.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER';
  package App::cpm::Worker;use strict;use warnings;use App::cpm::Logger::File;use App::cpm::Util;use App::cpm::Worker::Installer;use App::cpm::Worker::Resolver;use Config;use File::Path ();use File::Spec;use Time::HiRes qw(gettimeofday tv_interval);sub new {my ($class,%option)=@_;my$home=$option{home};my$logger=$option{logger}|| App::cpm::Logger::File->new("$home/build.log.@{[time]}");my$prebuilt_base;if ($option{prebuilt}){$prebuilt_base=$class->prebuilt_base($home);File::Path::mkpath($prebuilt_base)if!-d $prebuilt_base;my$file="$prebuilt_base/version";if (!-f $file){open my$fh,">",$file or die "$file: $!";print {$fh}"$Config{perlpath}\n"}}%option=(%option,logger=>$logger,base=>"$home/work/" .time .".$$",cache=>"$home/cache",$prebuilt_base ? (prebuilt_base=>$prebuilt_base): (),);my$installer=App::cpm::Worker::Installer->new(%option);my$resolver=App::cpm::Worker::Resolver->new(%option,impl=>$option{resolver});bless {%option,installer=>$installer,resolver=>$resolver },$class}sub prebuilt_base {my ($class,$home)=@_;my$identity=App::cpm::Util::perl_identity;File::Spec->catdir($home,"builds",$identity)}sub work {my ($self,$task)=@_;my$type=$task->{type}|| "(undef)";my$result;my$start=$self->{verbose}? [gettimeofday]: undef;if (grep {$type eq $_}qw(fetch configure install)){$result=eval {$self->{installer}->work($task)};warn $@ if $@}elsif ($type eq "resolve"){$result=eval {$self->{resolver}->work($task)};warn $@ if $@}else {die "Unknown type: $type\n"}my$elapsed=$start ? tv_interval($start): undef;$result ||= {ok=>0 };$task->merge({%$result,pid=>$$,elapsed=>$elapsed});return$task}1;
APP_CPM_WORKER

$fatpacked{"App/cpm/Worker/Installer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER_INSTALLER';
  package App::cpm::Worker::Installer;use strict;use warnings;use App::cpm::Logger::File;use App::cpm::Requirement;use App::cpm::Worker::Installer::Menlo;use App::cpm::Worker::Installer::Prebuilt;use App::cpm::version;use CPAN::DistnameInfo;use CPAN::Meta;use Config;use ExtUtils::Install ();use ExtUtils::InstallPaths ();use File::Basename 'basename';use File::Copy ();use File::Copy::Recursive ();use File::Path qw(mkpath rmtree);use File::Spec;use File::Temp ();use File::pushd 'pushd';use JSON::PP ();use Time::HiRes ();use constant NEED_INJECT_TOOLCHAIN_REQUIREMENTS=>$] < 5.018;my$TRUSTED_MIRROR=sub {my$uri=shift;!!($uri =~ m{^https?://(?:www.cpan.org|backpan.perl.org|cpan.metacpan.org)})};sub work {my ($self,$task)=@_;my$type=$task->{type}|| "(undef)";local$self->{logger}{context}=$task->distvname;if ($type eq "fetch"){if (my$result=$self->fetch($task)){return +{ok=>1,directory=>$result->{directory},meta=>$result->{meta},requirements=>$result->{requirements},provides=>$result->{provides},using_cache=>$result->{using_cache},prebuilt=>$result->{prebuilt},}}else {$self->{logger}->log("Failed to fetch/configure distribution")}}elsif ($type eq "configure"){if (my$result=$self->configure($task)){return +{ok=>1,distdata=>$result->{distdata},requirements=>$result->{requirements},static_builder=>$result->{static_builder},}}else {$self->{logger}->log("Failed to configure distribution")}}elsif ($type eq "install"){my$ok=$self->install($task);my$message=$ok ? "Successfully installed distribution" : "Failed to install distribution";$self->{logger}->log($message);return {ok=>$ok,directory=>$task->{directory}}}else {die "Unknown type: $type\n"}return {ok=>0 }}sub new {my ($class,%option)=@_;$option{logger}||= App::cpm::Logger::File->new;$option{base}or die "base option is required\n";$option{cache}or die "cache option is required\n";mkpath $_ for grep!-d,$option{base},$option{cache};$option{logger}->log("Work directory is $option{base}");my$menlo=App::cpm::Worker::Installer::Menlo->new(static_install=>$option{static_install},base=>$option{base},logger=>$option{logger},quiet=>1,pod2man=>$option{man_pages},notest=>$option{notest},sudo=>$option{sudo},mirrors=>["https://cpan.metacpan.org/"],configure_timeout=>$option{configure_timeout},build_timeout=>$option{build_timeout},test_timeout=>$option{test_timeout},);if ($option{local_lib}){my$local_lib=$option{local_lib}=$menlo->maybe_abs($option{local_lib});$menlo->{self_contained}=1;$menlo->log("Setup local::lib $local_lib");$menlo->setup_local_lib($local_lib)}$menlo->log("--",`$^X -V`,"--");$option{prebuilt}=App::cpm::Worker::Installer::Prebuilt->new if$option{prebuilt};bless {%option,menlo=>$menlo },$class}sub menlo {shift->{menlo}}sub _fetch_git {my ($self,$uri,$ref)=@_;my$basename=File::Basename::basename($uri);$basename =~ s/\.git$//;$basename =~ s/[^a-zA-Z0-9_.-]/-/g;my$dir=File::Temp::tempdir("$basename-XXXXX",CLEANUP=>0,DIR=>$self->menlo->{base},);$self->menlo->mask_output(diag_progress=>"Cloning $uri");$self->menlo->run_command(['git','clone',$uri,$dir ]);unless (-e "$dir/.git"){$self->menlo->diag_fail("Failed cloning git repository $uri",1);return}my$guard=pushd$dir;if ($ref){unless ($self->menlo->run_command(['git','checkout',$ref ])){$self->menlo->diag_fail("Failed to checkout '$ref' in git repository $uri\n");return}}$self->menlo->diag_ok;chomp(my$rev=`git rev-parse --short HEAD`);($dir,$rev)}sub enable_prebuilt {my ($self,$uri)=@_;$self->{prebuilt}&&!$self->{prebuilt}->skip($uri)&& $TRUSTED_MIRROR->($uri)}sub fetch {my ($self,$task)=@_;my$guard=pushd;my$source=$task->{source};my$distfile=$task->{distfile};my$uri=$task->{uri};if ($self->enable_prebuilt($uri)){if (my$result=$self->find_prebuilt($uri)){$self->{logger}->log("Using prebuilt $result->{directory}");return$result}}my ($dir,$rev,$using_cache);if ($source eq "git"){($dir,$rev)=$self->_fetch_git($uri,$task->{ref})}elsif ($source eq "local"){$self->{logger}->log("Copying $uri");$uri =~ s{^file://}{};$uri=$self->menlo->maybe_abs($uri);my$basename=basename$uri;my$g=pushd$self->menlo->{base};if (-d $uri){my$dest=File::Temp::tempdir("$basename-XXXXX",CLEANUP=>0,DIR=>$self->menlo->{base},);File::Copy::Recursive::dircopy($uri,$dest);$dir=$dest}elsif (-f $uri){my$dest=$basename;File::Copy::copy($uri,$dest);$dir=$self->menlo->unpack($basename);$dir=File::Spec->catdir($self->menlo->{base},$dir)if$dir}}elsif ($source =~ /^(?:cpan|https?)$/){my$g=pushd$self->menlo->{base};FETCH: {my$basename=basename$uri;if ($uri =~ s{^file://}{}){$self->{logger}->log("Copying $uri");File::Copy::copy($uri,$basename)or last FETCH;$dir=$self->menlo->unpack($basename)}else {local$self->menlo->{save_dists};if ($distfile and $TRUSTED_MIRROR->($uri)){my$cache=File::Spec->catfile($self->{cache},"authors/id/$distfile");if (-f $cache){$self->{logger}->log("Using cache $cache");File::Copy::copy($cache,$basename);$dir=$self->menlo->unpack($basename);if ($dir){$using_cache++;last FETCH}unlink$cache}$self->menlo->{save_dists}=$self->{cache}}$dir=$self->menlo->fetch_module({uris=>[$uri],pathname=>$distfile})}}$dir=File::Spec->catdir($self->menlo->{base},$dir)if$dir}return unless$dir;chdir$dir or die;my$meta=$self->_load_metafile($distfile,'META.json','META.yml');if (!$meta){$self->{logger}->log("Distribution does not have META.json nor META.yml");return}my$p=$meta->{provides}|| $self->menlo->extract_packages($meta,".");my$provides=[map +{package=>$_,version=>$p->{$_}{version}},sort keys %$p ];my$req={configure=>App::cpm::Requirement->new };if ($self->menlo->opts_in_static_install($meta)){$self->{logger}->log("Distribution opts in x_static_install: $meta->{x_static_install}")}else {$req={configure=>$self->_extract_configure_requirements($meta,$distfile)}}return +{directory=>$dir,meta=>$meta,requirements=>$req,provides=>$provides,using_cache=>$using_cache,}}sub find_prebuilt {my ($self,$uri)=@_;my$info=CPAN::DistnameInfo->new($uri);my$dir=File::Spec->catdir($self->{prebuilt_base},$info->cpanid,$info->distvname);return unless -f File::Spec->catfile($dir,".prebuilt");my$guard=pushd$dir;my$meta=$self->_load_metafile($uri,'META.json','META.yml');my$mymeta=$self->_load_metafile($uri,'blib/meta/MYMETA.json');my$phase=$self->{notest}? [qw(build runtime)]: [qw(build test runtime)];my%req;if (!$self->menlo->opts_in_static_install($meta)){%req=(configure=>$self->_extract_configure_requirements($meta,$uri))}%req=(%req,%{$self->_extract_requirements($mymeta,$phase)});my$provides=do {open my$fh,"<",'blib/meta/install.json' or die;my$json=JSON::PP::decode_json(do {local $/;<$fh>});my$provides=$json->{provides};[map +{package=>$_,version=>$provides->{$_}{version}},sort keys %$provides ]};return +{directory=>$dir,meta=>$meta->as_struct,provides=>$provides,prebuilt=>1,requirements=>\%req,}}sub save_prebuilt {my ($self,$task)=@_;my$dir=File::Spec->catdir($self->{prebuilt_base},$task->cpanid,$task->distvname);if (-d $dir and!File::Path::rmtree($dir)){return}my$parent=File::Basename::dirname($dir);for (1..3){last if -d $parent;eval {File::Path::mkpath($parent)}}return unless -d $parent;$self->{logger}->log("Saving the build $task->{directory} in $dir");if (File::Copy::Recursive::dircopy($task->{directory},$dir)){open my$fh,">",File::Spec->catfile($dir,".prebuilt")or die $!}else {warn "dircopy $task->{directory} $dir: $!"}}sub _inject_toolchain_requirements {my ($self,$distfile,$requirement)=@_;$distfile ||= "";if (-f "Makefile.PL" and!$requirement->has('ExtUtils::MakeMaker')and!-f "Build.PL" and $distfile !~ m{/ExtUtils-MakeMaker-[0-9v]}){$requirement->add('ExtUtils::MakeMaker')}if ($requirement->has('Module::Build')){$requirement->add('ExtUtils::Install')}my%inject=('Module::Build'=>'0.38','ExtUtils::MakeMaker'=>'6.64','ExtUtils::Install'=>'1.46',);for my$package (sort keys%inject){$requirement->has($package)or next;$requirement->add($package,$inject{$package})}$requirement}sub _load_metafile {my ($self,$distfile,@file)=@_;my$meta;if (my ($file)=grep -f,@file){$meta=eval {CPAN::Meta->load_file($file)};$self->{logger}->log("Invalid $file: $@")if $@}if (!$meta and $distfile){my$d=CPAN::DistnameInfo->new($distfile);$meta=CPAN::Meta->new({name=>$d->dist,version=>$d->version})}$meta}sub _extract_configure_requirements {my ($self,$meta,$distfile)=@_;my$requirement=$self->_extract_requirements($meta,[qw(configure)])->{configure};if ($requirement->empty and -f "Build.PL" and ($distfile || "")!~ m{/Module-Build-[0-9v]}){$requirement->add("Module::Build"=>"0.38")}if (NEED_INJECT_TOOLCHAIN_REQUIREMENTS){$self->_inject_toolchain_requirements($distfile,$requirement)}return$requirement}sub _extract_requirements {my ($self,$meta,$phases)=@_;$phases=[$phases]unless ref$phases;my$hash=$meta->effective_prereqs->as_string_hash;my%req;for my$phase (@$phases){my$req=App::cpm::Requirement->new;my$from=($hash->{$phase}|| +{})->{requires}|| +{};for my$package (sort keys %$from){$req->add($package,$from->{$package})}$req{$phase}=$req}\%req}sub _retry {my ($self,$sub)=@_;return 1 if$sub->();return unless$self->{retry};Time::HiRes::sleep(0.1);$self->{logger}->log("! Retrying (you can turn off this behavior by --no-retry)");return$sub->()}sub configure {my ($self,$task)=@_;my ($dir,$distfile,$meta,$source)=@{$task}{qw(directory distfile meta source)};my$guard=pushd$dir;my$menlo=$self->menlo;my$menlo_dist={meta=>$meta,cpanmeta=>$meta };$self->{logger}->log("Configuring distribution");my ($static_builder,$configure_ok);{if ($menlo->opts_in_static_install($meta)){my$state={};$menlo->static_install_configure($state,$menlo_dist,1);$static_builder=$state->{static_install};++$configure_ok and last}if (-f 'Build.PL'){my@cmd=($menlo->{perl},'Build.PL');push@cmd,'--pureperl-only' if$self->{pureperl_only};$self->_retry(sub {$menlo->configure(\@cmd,$menlo_dist,1);-f 'Build'})and ++$configure_ok and last}if (-f 'Makefile.PL'){my@cmd=($menlo->{perl},'Makefile.PL');push@cmd,'PUREPERL_ONLY=1' if$self->{pureperl_only};$self->_retry(sub {$menlo->configure(\@cmd,$menlo_dist,1);-f 'Makefile'})and ++$configure_ok and last}}return unless$configure_ok;my$distdata=$self->_build_distdata($source,$distfile,$meta);my$phase=$self->{notest}? [qw(build runtime)]: [qw(build test runtime)];my$mymeta=$self->_load_metafile($distfile,'MYMETA.json','MYMETA.yml');my$req=$self->_extract_requirements($mymeta,$phase);return +{distdata=>$distdata,requirements=>$req,static_builder=>$static_builder,}}sub _build_distdata {my ($self,$source,$distfile,$meta)=@_;my$menlo=$self->menlo;my$fake_state={configured_ok=>1,use_module_build=>-f "Build" };my$module_name=$menlo->find_module_name($fake_state)|| $meta->{name};$module_name =~ s/-/::/g;my$distvname=CPAN::DistnameInfo->new($distfile)->distvname;my$provides=$meta->{provides}|| $menlo->extract_packages($meta,".");+{distvname=>$distvname,pathname=>$distfile,provides=>$provides,version=>$meta->{version}|| 0,source=>$source,module_name=>$module_name,}}sub install {my ($self,$task)=@_;return$self->install_prebuilt($task)if$task->{prebuilt};my ($dir,$distdata,$static_builder,$distvname,$meta)=@{$task}{qw(directory distdata static_builder distvname meta)};my$guard=pushd$dir;my$menlo=$self->menlo;my$menlo_dist={meta=>$meta };$self->{logger}->log("Building " .($menlo->{notest}? "" : "and testing ")."distribution");my$installed;if ($static_builder){$menlo->build(sub {$static_builder->build},$distvname,$menlo_dist)&& $menlo->test(sub {$static_builder->build("test")},$distvname,$menlo_dist)&& $menlo->install(sub {$static_builder->build("install")},[],$distvname,$menlo_dist)&& $installed++}elsif (-f 'Build'){$self->_retry(sub {$menlo->build([$menlo->{perl},"./Build" ],$distvname,$menlo_dist)})&& $self->_retry(sub {$menlo->test([$menlo->{perl},"./Build","test" ],$distvname,$menlo_dist)})&& $self->_retry(sub {$menlo->install([$menlo->{perl},"./Build","install" ],[],$distvname,$menlo_dist)})&& $installed++}else {$self->_retry(sub {$menlo->build([$menlo->{make}],$distvname,$menlo_dist)})&& $self->_retry(sub {$menlo->test([$menlo->{make},"test" ],$distvname,$menlo_dist)})&& $self->_retry(sub {$menlo->install([$menlo->{make},"install" ],[],$distvname,$menlo_dist)})&& $installed++}if ($installed && $distdata){$menlo->save_meta($distdata->{module_name},$distdata,$distdata->{module_name},);$self->save_prebuilt($task)if$self->enable_prebuilt($task->{uri})}return$installed}sub install_prebuilt {my ($self,$task)=@_;my$install_base=$self->{local_lib};if (!$install_base && ($ENV{PERL_MM_OPT}|| '')=~ /INSTALL_BASE=(\S+)/){$install_base=$1}$self->{logger}->log("Copying prebuilt $task->{directory}/blib");my$guard=pushd$task->{directory};my$paths=ExtUtils::InstallPaths->new(dist_name=>$task->distname,$install_base ? (install_base=>$install_base): (),);my$install_base_meta=$install_base ? "$install_base/lib/perl5" : $Config{sitelibexp};my$distvname=$task->distvname;open my$fh,">",\my$stdout;{local*STDOUT=$fh;ExtUtils::Install::install([from_to=>$paths->install_map,verbose=>0,dry_run=>0,uninstall_shadows=>0,skip=>undef,always_copy=>1,result=>\my%result,]);ExtUtils::Install::install({'blib/meta'=>"$install_base_meta/$Config{archname}/.meta/$distvname",})}$self->{logger}->log($stdout);return 1}1;
APP_CPM_WORKER_INSTALLER

$fatpacked{"App/cpm/Worker/Installer/Menlo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER_INSTALLER_MENLO';
  package App::cpm::Worker::Installer::Menlo;use strict;use warnings;use parent 'Menlo::CLI::Compat';use App::cpm::HTTP;use App::cpm::Installer::Unpacker;use App::cpm::Logger::File;use App::cpm::Util 'WIN32';use Command::Runner;use Config;use File::Which ();use Menlo::Builder::Static;sub new {my ($class,%option)=@_;$option{log}||= $option{logger}->file;my$self=$class->SUPER::new(%option);if ($self->{make}=File::Which::which($Config{make})){$self->{logger}->log("You have make $self->{make}")}{my ($http,$desc)=App::cpm::HTTP->create;$self->{http}=$http;$self->{logger}->log("You have $desc")}{$self->{unpacker}=App::cpm::Installer::Unpacker->new;my$desc=$self->{unpacker}->describe;for my$key (sort keys %$desc){$self->{logger}->log("You have $key $desc->{$key}")}}$self->{initialized}=1;$self}sub unpack {my ($self,$file)=@_;$self->{logger}->log("Unpacking $file");my ($dir,$err)=$self->{unpacker}->unpack($file);$self->{logger}->log($err)if!$dir && $err;$dir}sub mirror {my ($self,$uri,$local)=@_;if ($uri =~ /^file:/){return$self->file_mirror($uri,$local)}my$res=$self->{http}->mirror($uri,$local);$self->{logger}->log($res->{status}.($res->{reason}? " $res->{reason}" : ""));return 1 if$res->{success};unlink$local;$self->{logger}->log($res->{content})if$res->{status}==599;return}sub log {my$self=shift;$self->{logger}->log(@_)}sub run_command {my ($self,$cmd)=@_;$self->run_timeout($cmd,0)}sub run_timeout {my ($self,$cmd,$timeout)=@_;my$str=ref$cmd eq 'CODE' ? '' : ref$cmd eq 'ARRAY' ? "@$cmd" : $cmd;$self->{logger}->log("Executing $str")if$str;my$runner=Command::Runner->new(command=>$cmd,keep=>0,redirect=>1,timeout=>$timeout,stdout=>sub {$self->log(@_)},);my$res=$runner->run;if ($res->{timeout}){$self->diag_fail("Timed out (> ${timeout}s).");return}my$result=$res->{result};ref$cmd eq 'CODE' ? $result : $result==0}1;
APP_CPM_WORKER_INSTALLER_MENLO

$fatpacked{"App/cpm/Worker/Installer/Prebuilt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER_INSTALLER_PREBUILT';
  package App::cpm::Worker::Installer::Prebuilt;use strict;use warnings;my@SKIP=(qr{/XML-SAX-v?[0-9\.]+\.tar\.gz$},);sub new {my$class=shift;bless {},$class}sub skip {my ($self,$uri)=@_;!!grep {$uri =~ $_}@SKIP}1;
APP_CPM_WORKER_INSTALLER_PREBUILT

$fatpacked{"App/cpm/Worker/Resolver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_WORKER_RESOLVER';
  package App::cpm::Worker::Resolver;use strict;use warnings;use App::cpm::Logger::File;sub new {my ($class,%option)=@_;my$logger=$option{logger}|| App::cpm::Logger::File->new;bless {impl=>$option{impl},logger=>$logger },$class}sub work {my ($self,$task)=@_;local$self->{logger}->{context}=$task->{package};my$result=$self->{impl}->resolve($task);if ($result and!$result->{error}){$result->{ok}=1;my$msg=sprintf "Resolved %s (%s) -> %s",$task->{package},$task->{version_range}|| 0,$result->{uri}.($result->{from}? " from $result->{from}" : "");$self->{logger}->log($msg);return$result}else {$self->{logger}->log($result->{error})if$result and $result->{error};$self->{logger}->log(sprintf "Failed to resolve %s",$task->{package});return {ok=>0 }}}1;
APP_CPM_WORKER_RESOLVER

$fatpacked{"App/cpm/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_CPM_VERSION';
  package App::cpm::version;use strict;use warnings;use CPAN::Meta::Requirements;use parent 'version';sub satisfy {my ($self,$version_range)=@_;return 1 unless$version_range;return$self >= (ref$self)->parse($version_range)if$version_range =~ /^v?[\d_.]+$/;my$requirements=CPAN::Meta::Requirements->new;$requirements->add_string_requirement('DummyModule',$version_range);$requirements->accepts_module('DummyModule',$self->numify)}sub numify {local$SIG{__WARN__}=sub {};shift->SUPER::numify(@_)}sub parse {local$SIG{__WARN__}=sub {};shift->SUPER::parse(@_)}sub range_merge {my ($range1,$range2)=@_;my$req=CPAN::Meta::Requirements->new;$req->add_string_requirement('DummyModule',$_)for$range1,$range2;$req->requirements_for_module('DummyModule')}1;
APP_CPM_VERSION

$fatpacked{"CPAN/02Packages/Search.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_02PACKAGES_SEARCH';
  package CPAN::02Packages::Search;use strict;use warnings;use IO::Handle;use Search::Dict ();use Tie::Handle::SkipHeader;our$VERSION='0.001';sub new {my ($class,%argv)=@_;my$file=$argv{file};my$skip_header=exists$argv{skip_header}? $argv{skip_header}: 1;my$self=bless {file=>$file,skip_header=>$skip_header },$class;$self->_fh;$self}sub _fh {my$self=shift;return$self->{fh}if defined$self->{pid}&& $self->{pid}==$$;my$file=$self->{file};if ($self->{skip_header}){my$fh=IO::Handle->new;tie *$fh,'Tie::Handle::SkipHeader','<',$file or die "$!: $file\n";$self->{fh}=$fh}else {open my$fh,"<",$file or die "$!: $file\n";$self->{fh}=$fh}$self->{pid}=$$;$self->{fh}}sub search {my ($self,$package)=@_;my$fh=$self->_fh;seek$fh,0,0;my$pos=Search::Dict::look$fh,$package,{xfrm=>\&_xform_package,fold=>1 };return if$pos==-1 || eof$fh;while (my$line=<$fh>){last if$line !~ /\A\Q$package\E\s+/i;chomp$line;my ($_package,$version,$path)=split /\s+/,$line,4;if ($package eq $_package){$version=undef if$version eq 'undef';return {version=>$version,path=>$path }}}return}sub _xform_package {(split " ",$_[0],2)[0]}1;
CPAN_02PACKAGES_SEARCH

$fatpacked{"CPAN/Common/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index;our$VERSION='0.010';use Carp ();use Class::Tiny;sub index_age {time}sub refresh_index {1}sub attributes {{}}sub validate_attributes {1}1;
CPAN_COMMON_INDEX

$fatpacked{"CPAN/Common/Index/LocalPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_LOCALPACKAGE';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::LocalPackage;our$VERSION='0.010';use parent 'CPAN::Common::Index::Mirror';use Class::Tiny qw/source/;use Carp;use File::Basename ();use File::Copy ();use File::Spec;use File::stat ();sub BUILD {my$self=shift;my$file=$self->source;if (!defined$file){Carp::croak("'source' parameter must be provided")}elsif (!-f $file){Carp::croak("index file '$file' does not exist")}return}sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($self->source));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub refresh_index {my ($self)=@_;my$source=$self->source;my$basename=File::Basename::basename($source);if ($source =~ /\.gz$/){Carp::croak "can't load gz source files without IO::Uncompress::Gunzip\n" unless$CPAN::Common::Index::Mirror::HAS_IO_UNCOMPRESS_GUNZIP;(my$uncompressed=$basename)=~ s/\.gz$//;$uncompressed=File::Spec->catfile($self->cache,$uncompressed);if (!-f $uncompressed or File::stat::stat($source)->mtime > File::stat::stat($uncompressed)->mtime){no warnings 'once';IO::Uncompress::Gunzip::gunzip(map {"$_"}$source,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}else {my$dest=File::Spec->catfile($self->cache,$basename);File::Copy::copy($source,$dest)if!-e $dest || File::stat::stat($source)->mtime > File::stat::stat($dest)->mtime}return 1}sub search_authors {return};1;
CPAN_COMMON_INDEX_LOCALPACKAGE

$fatpacked{"CPAN/Common/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_METADB';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::MetaDB;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless keys %$args==1 && exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}return}sub index_age {return time};sub search_authors {return};1;
CPAN_COMMON_INDEX_METADB

$fatpacked{"CPAN/Common/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MIRROR';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mirror;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/cache mirror/;use Carp;use CPAN::DistnameInfo;use File::Basename ();use File::Fetch;use File::Temp 0.19;use Search::Dict 1.07;use Tie::Handle::SkipHeader;use URI;our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};sub BUILD {my$self=shift;my$cache=$self->cache;$cache=File::Temp->newdir unless defined$cache;if (!-d $cache){Carp::croak("Cache directory '$cache' does not exist")}$self->cache($cache);my$mirror=$self->mirror;$mirror="http://www.cpan.org/" unless defined$mirror;$mirror =~ s{/?$}{/};$self->mirror($mirror);return}my%INDICES=(mailrc=>'authors/01mailrc.txt.gz',packages=>'modules/02packages.details.txt.gz',);my%TEST_GENERATORS=(regexp_nocase=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/i;return sub {$_[0]=~ $re}},regexp=>sub {my$arg=shift;my$re=ref$arg eq 'Regexp' ? $arg : qr/\A\Q$arg\E\z/;return sub {$_[0]=~ $re}},version=>sub {my$arg=shift;my$v=version->parse($arg);return sub {eval {version->parse($_[0])==$v}}},);my%QUERY_TYPES=(package=>'regexp',version=>'version',dist=>'regexp',id=>'regexp_nocase',fullname=>'regexp_nocase',email=>'regexp_nocase',);sub cached_package {my ($self)=@_;my$package=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{packages}));$package =~ s/\.gz$//;$self->refresh_index unless -r $package;return$package}sub cached_mailrc {my ($self)=@_;my$mailrc=File::Spec->catfile($self->cache,File::Basename::basename($INDICES{mailrc}));$mailrc =~ s/\.gz$//;$self->refresh_index unless -r $mailrc;return$mailrc}sub refresh_index {my ($self)=@_;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$ff=File::Fetch->new(uri=>$remote);my$where=$ff->fetch(to=>$self->cache)or Carp::croak($ff->error);if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$where)=~ s/\.gz$//;no warnings 'once';IO::Uncompress::Gunzip::gunzip($where,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}return 1}sub index_age {my ($self)=@_;my$package=$self->cached_package;return (-r $package ? (stat($package))[9]: 0)}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_package;die "Can't read $index_path" unless -r $index_path;my$fh=IO::Handle->new;tie *$fh,'Tie::Handle::SkipHeader',"<",$index_path or die "Can't tie $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{package}and ref$args->{package}eq ''){my$pos=look$fh,$args->{package},{xfrm=>\&_xform_package,fold=>1 };return if$pos==-1;LINE: while (my$line=<$fh>){last unless$line =~ /\A\Q$args->{package}\E\s+/i;push@found,_match_package_line($line,$rules)}}else {LINE: while (my$line=<$fh>){push@found,_match_package_line($line,$rules)}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my$index_path=$self->cached_mailrc;die "Can't read $index_path" unless -r $index_path;open my$fh,$index_path or die "Can't open $index_path: $!";my$rules;while (my ($k,$v)=each %$args){$rules->{$k}=_rulify($k,$v)}my@found;if ($args->{id}and ref$args->{id}eq ''){my$pos=look$fh,$args->{id},{xfrm=>\&_xform_mailrc,fold=>1 };return if$pos==-1;my$line=<$fh>;push@found,_match_mailrc_line($line,$rules)}else {LINE: while (my$line=<$fh>){push@found,_match_mailrc_line($line,$rules)}}return wantarray ? @found : $found[0]}sub _rulify {my ($key,$arg)=@_;return$arg if ref($arg)eq 'CODE';return$TEST_GENERATORS{$QUERY_TYPES{$key}}->($arg)}sub _xform_package {my@fields=split " ",$_[0],2;return$fields[0]}sub _xform_mailrc {my@fields=split " ",$_[0],3;return$fields[1]}sub _match_package_line {my ($line,$rules)=@_;return unless defined$line;my ($mod,$version,$dist,$comment)=split " ",$line,4;if ($rules->{package}){return unless$rules->{package}->($mod)}if ($rules->{version}){return unless$rules->{version}->($version)}if ($rules->{dist}){return unless$rules->{dist}->($dist)}$dist =~ s{\A./../}{};return {package=>$mod,version=>$version,uri=>"cpan:///distfile/$dist",}}sub _match_mailrc_line {my ($line,$rules)=@_;return unless defined$line;my ($id,$address)=$line =~ m{\Aalias\s+(\S+)\s+"(.*)"};my ($fullname,$email)=$address =~ m{([^<]+)<([^>]+)>};$fullname =~ s/\s*$//;if ($rules->{id}){return unless$rules->{id}->($id)}if ($rules->{fullname}){return unless$rules->{fullname}->($fullname)}if ($rules->{email}){return unless$rules->{email}->($email)}return {id=>$id,fullname=>$fullname,email=>$email,}}1;
CPAN_COMMON_INDEX_MIRROR

$fatpacked{"CPAN/Common/Index/Mux/Ordered.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_COMMON_INDEX_MUX_ORDERED';
  use 5.008001;use strict;use warnings;package CPAN::Common::Index::Mux::Ordered;our$VERSION='0.010';use parent 'CPAN::Common::Index';use Class::Tiny qw/resolvers/;use Module::Load ();sub BUILD {my$self=shift;my$resolvers=$self->resolvers;$resolvers=[]unless defined$resolvers;if (ref$resolvers ne 'ARRAY'){Carp::croak("The 'resolvers' argument must be an array reference")}for my$r (@$resolvers){if (!eval {$r->isa("CPAN::Common::Index")}){Carp::croak("Resolver '$r' is not a CPAN::Common::Index object")}}$self->resolvers($resolvers);return}sub assemble {my ($class,@backends)=@_;my@resolvers;while (@backends){my ($subclass,$config)=splice@backends,0,2;my$full_class="CPAN::Common::Index::${subclass}";eval {Module::Load::load($full_class);1}or Carp::croak($@);my$object=$full_class->new($config);push@resolvers,$object}return$class->new({resolvers=>\@resolvers })}sub validate_attributes {my ($self)=@_;my$resolvers=$self->resolvers;return 1}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_packages($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_packages($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}sub search_authors {my ($self,$args)=@_;Carp::croak("Argument to search_authors must be hash reference")unless ref$args eq 'HASH';my@found;if ($args->{name}and ref$args->{name}eq ''){for my$source (@{$self->resolvers}){if (my@result=$source->search_authors($args)){push@found,@result;last}}}else {my%seen;for my$source (@{$self->resolvers}){my@result=$source->search_authors($args);push@found,grep {!$seen{$_->{package}}++}@result}}return wantarray ? @found : $found[0]}1;
CPAN_COMMON_INDEX_MUX_ORDERED

$fatpacked{"CPAN/DistnameInfo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_DISTNAMEINFO';
  package CPAN::DistnameInfo;$VERSION="0.12";use strict;sub distname_info {my$file=shift or return;my ($dist,$version)=$file =~ /^
      ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
       (?:
  	[A-Za-z](?=[^A-Za-z]|$)
  	|
  	\d(?=-)
       )(?<![._-][vV])
      )+)(.*)
    $/xs or return ($file,undef,undef);if ($dist =~ /-undef\z/ and!length$version){$dist =~ s/-undef\z//}$version =~ s/-withoutworldwriteables$//;if ($version =~ /^(-[Vv].*)-(\d.*)/){$dist .= $1;$version=$2}if ($version =~ /(.+_.*)-(\d.*)/){$dist .= $1;$version=$2}$dist =~ s{\.pm$}{};$version=$1 if!length$version and $dist =~ s/-(\d+\w)$//;$version=$1 .$version if$version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;if ($version =~ /\d\.\d/){$version =~ s/^[-_.]+//}else {$version =~ s/^[-_]+//}my$dev;if (length$version){if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/){$dev=1 if (($1 > 6 and $1 & 1)or ($2 and $2 >= 50))or $3}elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/){$dev=1}}else {$version=undef}($dist,$version,$dev)}sub new {my$class=shift;my$distfile=shift;$distfile =~ s,//+,/,g;my%info=(pathname=>$distfile);($info{filename}=$distfile)=~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,, and $info{cpanid}=$6;if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i){$info{distvname}=$1;$info{extension}=$2}@info{qw(dist version beta)}=distname_info($info{distvname});$info{maturity}=delete$info{beta}? 'developer' : 'released';return bless \%info,$class}sub dist {shift->{dist}}sub version {shift->{version}}sub maturity {shift->{maturity}}sub filename {shift->{filename}}sub cpanid {shift->{cpanid}}sub distvname {shift->{distvname}}sub extension {shift->{extension}}sub pathname {shift->{pathname}}sub properties {%{$_[0]}}1;
CPAN_DISTNAMEINFO

$fatpacked{"CPAN/Meta/Check.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CPAN_META_CHECK';
  package CPAN::Meta::Check;$CPAN::Meta::Check::VERSION='0.014';use strict;use warnings;use base 'Exporter';our@EXPORT=qw//;our@EXPORT_OK=qw/check_requirements requirements_for verify_dependencies/;our%EXPORT_TAGS=(all=>[@EXPORT,@EXPORT_OK ]);use CPAN::Meta::Prereqs '2.132830';use CPAN::Meta::Requirements 2.121;use Module::Metadata 1.000023;sub _check_dep {my ($reqs,$module,$dirs)=@_;$module eq 'perl' and return ($reqs->accepts_module($module,$])? (): sprintf "Your Perl (%s) is not in the range '%s'",$],$reqs->requirements_for_module($module));my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return "Module '$module' is not installed" if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is not in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if not $reqs->accepts_module($module,$version || 0);return}sub _check_conflict {my ($reqs,$module,$dirs)=@_;my$metadata=Module::Metadata->new_from_module($module,inc=>$dirs);return if not defined$metadata;my$version=eval {$metadata->version};return sprintf 'Installed version (%s) of %s is in range \'%s\'',(defined$version ? $version : 'undef'),$module,$reqs->requirements_for_module($module)if$reqs->accepts_module($module,$version);return}sub requirements_for {my ($meta,$phases,$type)=@_;my$prereqs=ref($meta)eq 'CPAN::Meta' ? $meta->effective_prereqs : $meta;return$prereqs->merged_requirements(ref($phases)? $phases : [$phases ],[$type ])}sub check_requirements {my ($reqs,$type,$dirs)=@_;return +{map {$_=>$type ne 'conflicts' ? scalar _check_dep($reqs,$_,$dirs): scalar _check_conflict($reqs,$_,$dirs)}$reqs->required_modules }}sub verify_dependencies {my ($meta,$phases,$type,$dirs)=@_;my$reqs=requirements_for($meta,$phases,$type);my$issues=check_requirements($reqs,$type,$dirs);return grep {defined}values %{$issues}}1;
CPAN_META_CHECK

$fatpacked{"Capture/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CAPTURE_TINY';
  use 5.006;use strict;use warnings;package Capture::Tiny;our$VERSION='0.48';use Carp ();use Exporter ();use IO::Handle ();use File::Spec ();use File::Temp qw/tempfile tmpnam/;use Scalar::Util qw/reftype blessed/;BEGIN {local $@;eval {require PerlIO;PerlIO->can('get_layers')}or *PerlIO::get_layers=sub {return ()}}my%api=(capture=>[1,1,0,0],capture_stdout=>[1,0,0,0],capture_stderr=>[0,1,0,0],capture_merged=>[1,1,1,0],tee=>[1,1,0,1],tee_stdout=>[1,0,0,1],tee_stderr=>[0,1,0,1],tee_merged=>[1,1,1,1],);for my$sub (keys%api){my$args=join q{, },@{$api{$sub}};eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"}our@ISA=qw/Exporter/;our@EXPORT_OK=keys%api;our%EXPORT_TAGS=('all'=>\@EXPORT_OK);my$IS_WIN32=$^O eq 'MSWin32';our$TIMEOUT=30;my@cmd=($^X,'-C0','-e',<<'HERE');sub _relayer {my ($fh,$apply_layers)=@_;binmode($fh,":raw");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")}my@to_apply=@$apply_layers;shift@to_apply;binmode($fh,":" .join(":",@to_apply))}sub _name {my$glob=shift;no strict 'refs';return *{$glob}{NAME}}sub _open {open $_[0],$_[1]or Carp::confess "Error from open(" .join(q{, },@_)."): $!"}sub _close {close $_[0]or Carp::confess "Error from close(" .join(q{, },@_)."): $!"}my%dup;my%proxy_count;sub _proxy_std {my%proxies;if (!defined fileno STDIN){$proxy_count{stdin}++;if (defined$dup{stdin}){_open \*STDIN,"<&=" .fileno($dup{stdin})}else {_open \*STDIN,"<" .File::Spec->devnull;_open$dup{stdin}=IO::Handle->new,"<&=STDIN"}$proxies{stdin}=\*STDIN;binmode(STDIN,':utf8')if $] >= 5.008}if (!defined fileno STDOUT){$proxy_count{stdout}++;if (defined$dup{stdout}){_open \*STDOUT,">&=" .fileno($dup{stdout})}else {_open \*STDOUT,">" .File::Spec->devnull;_open$dup{stdout}=IO::Handle->new,">&=STDOUT"}$proxies{stdout}=\*STDOUT;binmode(STDOUT,':utf8')if $] >= 5.008}if (!defined fileno STDERR){$proxy_count{stderr}++;if (defined$dup{stderr}){_open \*STDERR,">&=" .fileno($dup{stderr})}else {_open \*STDERR,">" .File::Spec->devnull;_open$dup{stderr}=IO::Handle->new,">&=STDERR"}$proxies{stderr}=\*STDERR;binmode(STDERR,':utf8')if $] >= 5.008}return%proxies}sub _unproxy {my (%proxies)=@_;for my$p (keys%proxies){$proxy_count{$p}--;if (!$proxy_count{$p}){_close$proxies{$p};_close$dup{$p}unless $] < 5.008;delete$dup{$p}}}}sub _copy_std {my%handles;for my$h (qw/stdout stderr stdin/){next if$h eq 'stdin' &&!$IS_WIN32;my$redir=$h eq 'stdin' ? "<&" : ">&";_open$handles{$h}=IO::Handle->new(),$redir .uc($h)}return \%handles}sub _open_std {my ($handles)=@_;_open \*STDIN,"<&" .fileno$handles->{stdin}if defined$handles->{stdin};_open \*STDOUT,">&" .fileno$handles->{stdout}if defined$handles->{stdout};_open \*STDERR,">&" .fileno$handles->{stderr}if defined$handles->{stderr}}sub _start_tee {my ($which,$stash)=@_;$stash->{$_}{$which}=IO::Handle->new for qw/tee reader/;pipe$stash->{reader}{$which},$stash->{tee}{$which};select((select($stash->{tee}{$which}),$|=1)[0]);$stash->{new}{$which}=$stash->{tee}{$which};$stash->{child}{$which}={stdin=>$stash->{reader}{$which},stdout=>$stash->{old}{$which},stderr=>$stash->{capture}{$which},};$stash->{flag_files}{$which}=scalar(tmpnam()).$$;if ($IS_WIN32){my$old_eval_err=$@;undef $@;eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";my$os_fhandle=GetOsFHandle($stash->{tee}{$which});my$result=SetHandleInformation($os_fhandle,HANDLE_FLAG_INHERIT(),0);_open_std($stash->{child}{$which});$stash->{pid}{$which}=system(1,@cmd,$stash->{flag_files}{$which});$@=$old_eval_err}else {_fork_exec($which,$stash)}}sub _fork_exec {my ($which,$stash)=@_;my$pid=fork;if (not defined$pid){Carp::confess "Couldn't fork(): $!"}elsif ($pid==0){untie*STDIN;untie*STDOUT;untie*STDERR;_close$stash->{tee}{$which};_open_std($stash->{child}{$which});exec@cmd,$stash->{flag_files}{$which}}$stash->{pid}{$which}=$pid}my$have_usleep=eval "use Time::HiRes 'usleep'; 1";sub _files_exist {return 1 if @_==grep {-f}@_;Time::HiRes::usleep(1000)if$have_usleep;return 0}sub _wait_for_tees {my ($stash)=@_;my$start=time;my@files=values %{$stash->{flag_files}};my$timeout=defined$ENV{PERL_CAPTURE_TINY_TIMEOUT}? $ENV{PERL_CAPTURE_TINY_TIMEOUT}: $TIMEOUT;1 until _files_exist(@files)|| ($timeout && (time - $start > $timeout));Carp::confess "Timed out waiting for subprocesses to start" if!_files_exist(@files);unlink $_ for@files}sub _kill_tees {my ($stash)=@_;if ($IS_WIN32){close($_)for values %{$stash->{tee}};my$start=time;1 until wait==-1 || (time - $start > 30)}else {_close $_ for values %{$stash->{tee}};waitpid $_,0 for values %{$stash->{pid}}}}sub _slurp {my ($name,$stash)=@_;my ($fh,$pos)=map {$stash->{$_}{$name}}qw/capture pos/;seek($fh,$pos,0)or die "Couldn't seek on capture handle for $name\n";my$text=do {local $/;scalar readline$fh};return defined($text)? $text : ""}sub _capture_tee {my ($do_stdout,$do_stderr,$do_merge,$do_tee,$code,@opts)=@_;my%do=($do_stdout ? (stdout=>1): (),$do_stderr ? (stderr=>1): ());Carp::confess("Custom capture options must be given as key/value pairs\n")unless@opts % 2==0;my$stash={capture=>{@opts }};for (keys %{$stash->{capture}}){my$fh=$stash->{capture}{$_};Carp::confess "Custom handle for $_ must be seekable\n" unless ref($fh)eq 'GLOB' || (blessed($fh)&& $fh->isa("IO::Seekable"))}local*CT_ORIG_STDIN=*STDIN ;local*CT_ORIG_STDOUT=*STDOUT;local*CT_ORIG_STDERR=*STDERR;my%layers=(stdin=>[PerlIO::get_layers(\*STDIN)],stdout=>[PerlIO::get_layers(\*STDOUT,output=>1)],stderr=>[PerlIO::get_layers(\*STDERR,output=>1)],);$layers{stdout}=[PerlIO::get_layers(tied*STDOUT)]if tied(*STDOUT)&& (reftype tied*STDOUT eq 'GLOB');$layers{stderr}=[PerlIO::get_layers(tied*STDERR)]if tied(*STDERR)&& (reftype tied*STDERR eq 'GLOB');my%localize;$localize{stdin}++,local(*STDIN)if grep {$_ eq 'scalar'}@{$layers{stdin}};$localize{stdout}++,local(*STDOUT)if$do_stdout && grep {$_ eq 'scalar'}@{$layers{stdout}};$localize{stderr}++,local(*STDERR)if ($do_stderr || $do_merge)&& grep {$_ eq 'scalar'}@{$layers{stderr}};$localize{stdin}++,local(*STDIN),_open(\*STDIN,"<&=0")if tied*STDIN && $] >= 5.008;$localize{stdout}++,local(*STDOUT),_open(\*STDOUT,">&=1")if$do_stdout && tied*STDOUT && $] >= 5.008;$localize{stderr}++,local(*STDERR),_open(\*STDERR,">&=2")if ($do_stderr || $do_merge)&& tied*STDERR && $] >= 5.008;my%proxy_std=_proxy_std();$layers{stdout}=[PerlIO::get_layers(\*STDOUT,output=>1)]if$proxy_std{stdout};$layers{stderr}=[PerlIO::get_layers(\*STDERR,output=>1)]if$proxy_std{stderr};$stash->{old}=_copy_std();$stash->{new}={%{$stash->{old}}};for (keys%do){$stash->{new}{$_}=($stash->{capture}{$_}||= File::Temp->new);seek($stash->{capture}{$_},0,2)or die "Could not seek on capture handle for $_\n";$stash->{pos}{$_}=tell$stash->{capture}{$_};_start_tee($_=>$stash)if$do_tee}_wait_for_tees($stash)if$do_tee;$stash->{new}{stderr}=$stash->{new}{stdout}if$do_merge;_open_std($stash->{new});my ($exit_code,$inner_error,$outer_error,$orig_pid,@result);{$orig_pid=$$;local*STDIN=*CT_ORIG_STDIN if$localize{stdin};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;my$old_eval_err=$@;undef $@;eval {@result=$code->();$inner_error=$@};$exit_code=$?;$outer_error=$@;STDOUT->flush if$do_stdout;STDERR->flush if$do_stderr;$@=$old_eval_err}_open_std($stash->{old});_close($_)for values %{$stash->{old}};_relayer(\*STDOUT,$layers{stdout})if$do_stdout;_relayer(\*STDERR,$layers{stderr})if$do_stderr;_unproxy(%proxy_std);_kill_tees($stash)if$do_tee;my%got;if ($orig_pid==$$ and (defined wantarray or ($do_tee && keys%localize))){for (keys%do){_relayer($stash->{capture}{$_},$layers{$_});$got{$_}=_slurp($_,$stash)}print CT_ORIG_STDOUT$got{stdout}if$do_stdout && $do_tee && $localize{stdout};print CT_ORIG_STDERR$got{stderr}if$do_stderr && $do_tee && $localize{stderr}}$?=$exit_code;$@=$inner_error if$inner_error;die$outer_error if$outer_error;return unless defined wantarray;my@return;push@return,$got{stdout}if$do_stdout;push@return,$got{stderr}if$do_stderr &&!$do_merge;push@return,@result;return wantarray ? @return : $return[0]}1;
  use Fcntl;
  $SIG{HUP}=sub{exit};
  if ( my $fn=shift ) {
      sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
      print {$fh} $$;
      close $fh;
  }
  my $buf; while (sysread(STDIN, $buf, 2048)) {
      syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
  }
  HERE
CAPTURE_TINY

$fatpacked{"Carton.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON';
  package Carton;use strict;use 5.008_005;use version;our$VERSION=version->declare("v1.0.34");1;
CARTON

$fatpacked{"Carton/Builder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_BUILDER';
  package Carton::Builder;use strict;use Class::Tiny {mirror=>undef,index=>undef,cascade=>sub {1},without=>sub {[]},cpanfile=>undef,};sub effective_mirrors {my$self=shift;my@mirrors=($self->mirror);push@mirrors,Carton::Mirror->default if$self->custom_mirror;push@mirrors,Carton::Mirror->new('http://backpan.perl.org/');@mirrors}sub custom_mirror {my$self=shift;!$self->mirror->is_default}sub bundle {my($self,$path,$cache_path,$snapshot)=@_;for my$dist ($snapshot->distributions){my$source=$path->child("cache/authors/id/" .$dist->pathname);my$target=$cache_path->child("authors/id/" .$dist->pathname);if ($source->exists){warn "Copying ",$dist->pathname,"\n";$target->parent->mkpath;$source->copy($target)or warn "$target: $!"}else {warn "Couldn't find @{[ $dist->pathname ]}\n"}}my$has_io_gzip=eval {require IO::Compress::Gzip;1};my$ext=$has_io_gzip ? ".txt.gz" : ".txt";my$index=$cache_path->child("modules/02packages.details$ext");$index->parent->mkpath;warn "Writing $index\n";my$out=$index->openw;if ($has_io_gzip){$out=IO::Compress::Gzip->new($out)or die "gzip failed: $IO::Compress::Gzip::GzipError"}$snapshot->index->write($out);close$out;unless ($has_io_gzip){unlink "$index.gz";!system 'gzip',$index or die "Running gzip command failed: $!"}}sub install {my($self,$path)=@_;$self->run_install("-L",$path,(map {("--mirror",$_->url)}$self->effective_mirrors),($self->index ? ("--mirror-index",$self->index): ()),($self->cascade ? "--cascade-search" : ()),($self->custom_mirror ? "--mirror-only" : ()),"--save-dists","$path/cache",$self->groups,"--cpanfile",$self->cpanfile,"--installdeps",$self->cpanfile->dirname,)or die "Installing modules failed\n"}sub groups {my$self=shift;my@options=('--with-all-features','--with-develop');for my$group (@{$self->without}){push@options,'--without-develop' if$group eq 'develop';push@options,"--without-feature=$group"}return@options}sub update {my($self,$path,@modules)=@_;$self->run_install("-L",$path,(map {("--mirror",$_->url)}$self->effective_mirrors),($self->custom_mirror ? "--mirror-only" : ()),"--save-dists","$path/cache",@modules)or die "Updating modules failed\n"}sub run_install {my($self,@args)=@_;require Menlo::CLI::Compat;local$ENV{PERL_CPANM_OPT};my$cli=Menlo::CLI::Compat->new;$cli->parse_options("--quiet","--notest",@args);$cli->run;!$cli->status}1;
CARTON_BUILDER

$fatpacked{"Carton/CLI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CLI';
  package Carton::CLI;use strict;use warnings;use Config;use Getopt::Long;use Path::Tiny;use Try::Tiny;use Module::CoreList;use Scalar::Util qw(blessed);use Carton;use Carton::Builder;use Carton::Mirror;use Carton::Snapshot;use Carton::Util;use Carton::Environment;use Carton::Error;use constant {SUCCESS=>0,INFO=>1,WARN=>2,ERROR=>3 };our$UseSystem=0;use Class::Tiny {verbose=>undef,carton=>sub {$_[0]->_build_carton},mirror=>sub {$_[0]->_build_mirror},};sub _build_mirror {my$self=shift;Carton::Mirror->new($ENV{PERL_CARTON_MIRROR}|| $Carton::Mirror::DefaultMirror)}sub run {my($self,@args)=@_;my@commands;my$p=Getopt::Long::Parser->new(config=>["no_ignore_case","pass_through" ],);$p->getoptionsfromarray(\@args,"h|help"=>sub {unshift@commands,'help'},"v|version"=>sub {unshift@commands,'version'},"verbose!"=>sub {$self->verbose($_[1])},);push@commands,@args;my$cmd=shift@commands || 'install';my$code=try {my$call=$self->can("cmd_$cmd")or Carton::Error::CommandNotFound->throw(error=>"Could not find command '$cmd'");$self->$call(@commands);return 0}catch {die $_ unless blessed $_ && $_->can('rethrow');if ($_->isa('Carton::Error::CommandExit')){return $_->code || 255}elsif ($_->isa('Carton::Error::CommandNotFound')){warn $_->error,"\n\n";$self->cmd_usage;return 255}elsif ($_->isa('Carton::Error')){warn $_->error,"\n";return 255}};return$code}sub commands {my$self=shift;no strict 'refs';map {s/^cmd_//;$_}grep {/^cmd_.*/ && $self->can($_)}sort keys %{__PACKAGE__."::"}}sub cmd_usage {my$self=shift;$self->print(<<HELP)}sub parse_options {my($self,$args,@spec)=@_;my$p=Getopt::Long::Parser->new(config=>["no_auto_abbrev","no_ignore_case" ],);$p->getoptionsfromarray($args,@spec)}sub parse_options_pass_through {my($self,$args,@spec)=@_;my$p=Getopt::Long::Parser->new(config=>["no_auto_abbrev","no_ignore_case","pass_through" ],);$p->getoptionsfromarray($args,@spec);shift @$args if$args->[0]&& $args->[0]eq '--'}sub printf {my$self=shift;my$type=pop;my($temp,@args)=@_;$self->print(sprintf($temp,@args),$type)}sub print {my($self,$msg,$type)=@_;my$fh=$type && $type >= WARN ? *STDERR : *STDOUT;print {$fh}$msg}sub error {my($self,$msg)=@_;$self->print($msg,ERROR);Carton::Error::CommandExit->throw}sub cmd_help {my$self=shift;my$module=$_[0]? ("Carton::Doc::" .ucfirst $_[0]): "Carton.pm";system "perldoc",$module}sub cmd_version {my$self=shift;$self->print("carton $Carton::VERSION\n")}sub cmd_bundle {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;$self->print("Bundling modules using @{[$env->cpanfile]}\n");my$builder=Carton::Builder->new(mirror=>$self->mirror,cpanfile=>$env->cpanfile,);$builder->bundle($env->install_path,$env->vendor_cache,$env->snapshot);$self->printf("Complete! Modules were bundled into %s\n",$env->vendor_cache,SUCCESS)}sub cmd_fatpack {my($self,@args)=@_;my$env=Carton::Environment->build;require Carton::Packer;Carton::Packer->new->fatpack_carton($env->vendor_bin)}sub cmd_install {my($self,@args)=@_;my($install_path,$cpanfile_path,@without);$self->parse_options(\@args,"p|path=s"=>\$install_path,"cpanfile=s"=>\$cpanfile_path,"without=s"=>sub {push@without,split /,/,$_[1]},"deployment!"=>\my$deployment,"cached!"=>\my$cached,);my$env=Carton::Environment->build($cpanfile_path,$install_path);$env->snapshot->load_if_exists;if ($deployment &&!$env->snapshot->loaded){$self->error("--deployment requires cpanfile.snapshot: Run `carton install` and make sure cpanfile.snapshot is checked into your version control.\n")}my$builder=Carton::Builder->new(cascade=>1,mirror=>$self->mirror,without=>\@without,cpanfile=>$env->cpanfile,);if ($deployment){$self->print("Installing modules using @{[$env->cpanfile]} (deployment mode)\n");$builder->cascade(0)}else {$self->print("Installing modules using @{[$env->cpanfile]}\n")}if ($env->snapshot->loaded){my$index_file=$env->install_path->child("cache/modules/02packages.details.txt");$index_file->parent->mkpath;$env->snapshot->write_index($index_file);$builder->index($index_file)}if ($cached){$builder->mirror(Carton::Mirror->new($env->vendor_cache))}$builder->install($env->install_path);unless ($deployment){$env->cpanfile->load;$env->snapshot->find_installs($env->install_path,$env->cpanfile->requirements);$env->snapshot->save}$self->print("Complete! Modules were installed into @{[$env->install_path]}\n",SUCCESS)}sub cmd_show {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;for my$module (@args){my$dist=$env->snapshot->find($module)or $self->error("Couldn't locate $module in cpanfile.snapshot\n");$self->print($dist->name ."\n")}}sub cmd_list {my($self,@args)=@_;my$format='name';$self->parse_options(\@args,"distfile"=>sub {$format='distfile'},);my$env=Carton::Environment->build;$env->snapshot->load;for my$dist ($env->snapshot->distributions){$self->print($dist->$format ."\n")}}sub cmd_tree {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;$env->cpanfile->load;my%seen;my$dumper=sub {my($dependency,$reqs,$level)=@_;return if$level==0;return Carton::Tree::STOP if$dependency->dist->is_core;return Carton::Tree::STOP if$seen{$dependency->distname}++;$self->printf("%s%s (%s)\n"," " x ($level - 1),$dependency->module,$dependency->distname,INFO)};$env->tree->walk_down($dumper)}sub cmd_check {my($self,@args)=@_;my$cpanfile_path;$self->parse_options(\@args,"cpanfile=s"=>\$cpanfile_path,);my$env=Carton::Environment->build($cpanfile_path);$env->snapshot->load;$env->cpanfile->load;my$merged_reqs=$env->tree->merged_requirements;my@missing;for my$module ($merged_reqs->required_modules){my$install=$env->snapshot->find_or_core($module);if ($install){unless ($merged_reqs->accepts_module($module=>$install->version_for($module))){push@missing,[$module,1,$install->version_for($module)]}}else {push@missing,[$module,0 ]}}if (@missing){$self->print("Following dependencies are not satisfied.\n",INFO);for my$missing (@missing){my($module,$unsatisfied,$version)=@$missing;if ($unsatisfied){$self->printf("  %s has version %s. Needs %s\n",$module,$version,$merged_reqs->requirements_for_module($module),INFO)}else {$self->printf("  %s is not installed. Needs %s\n",$module,$merged_reqs->requirements_for_module($module),INFO)}}$self->printf("Run `carton install` to install them.\n",INFO);Carton::Error::CommandExit->throw}else {$self->print("cpanfile's dependencies are satisfied.\n",INFO)}}sub cmd_update {my($self,@args)=@_;my$env=Carton::Environment->build;$env->cpanfile->load;my$cpanfile=Module::CPANfile->load($env->cpanfile);@args=grep {$_ ne 'perl'}$env->cpanfile->required_modules unless@args;$env->snapshot->load;my@modules;for my$module (@args){my$dist=$env->snapshot->find_or_core($module)or $self->error("Could not find module $module.\n");next if$dist->is_core;push@modules,"$module~" .$env->cpanfile->requirements_for_module($module)}return unless@modules;my$builder=Carton::Builder->new(mirror=>$self->mirror,cpanfile=>$env->cpanfile,);$builder->update($env->install_path,@modules);$env->snapshot->find_installs($env->install_path,$env->cpanfile->requirements);$env->snapshot->save}sub cmd_run {my($self,@args)=@_;local$UseSystem=1;$self->cmd_exec(@args)}sub cmd_exec {my($self,@args)=@_;my$env=Carton::Environment->build;$env->snapshot->load;@args=map {/^(-[I])(.+)/ ? ($1,$2): $_}@args;while (@args){if ($args[0]eq '-I'){warn "exec -Ilib is deprecated. You might want to run: carton exec perl -Ilib ...\n";splice(@args,0,2)}else {last}}$self->parse_options_pass_through(\@args);unless (@args){$self->error("carton exec needs a command to run.\n")}my$path=$env->install_path;local$ENV{PERL5LIB}="$path/lib/perl5";local$ENV{PATH}="$path/bin:$ENV{PATH}";if ($UseSystem){system@args}else {exec@args;exit 127}}1;
  Usage: carton <command>
  
  where <command> is one of:
    @{[ join ", ", $self->commands ]}
  
  Run carton -h <command> for help.
  HELP
CARTON_CLI

$fatpacked{"Carton/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_CPANFILE';
  package Carton::CPANfile;use Path::Tiny ();use Module::CPANfile;use overload q{""}=>sub {$_[0]->stringify},fallback=>1;use subs 'path';use Class::Tiny {path=>undef,_cpanfile=>undef,requirements=>sub {$_[0]->_build_requirements},};sub stringify {shift->path->stringify(@_)}sub dirname {shift->path->dirname(@_)}sub prereqs {shift->_cpanfile->prereqs(@_)}sub required_modules {shift->requirements->required_modules(@_)}sub requirements_for_module {shift->requirements->requirements_for_module(@_)}sub path {my$self=shift;if (@_){$self->{path}=Path::Tiny->new($_[0])}else {$self->{path}}}sub load {my$self=shift;$self->_cpanfile(Module::CPANfile->load($self->path))}sub _build_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;$reqs->add_requirements($self->prereqs->requirements_for($_,'requires'))for qw(configure build runtime test develop);$reqs->clear_requirement('perl');$reqs}1;
CARTON_CPANFILE

$fatpacked{"Carton/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DEPENDENCY';
  package Carton::Dependency;use strict;use Class::Tiny {module=>undef,requirement=>undef,dist=>undef,};sub requirements {shift->dist->requirements(@_)}sub distname {my$self=shift;$self->dist->name}sub version {my$self=shift;$self->dist->version_for($self->module)}1;
CARTON_DEPENDENCY

$fatpacked{"Carton/Dist.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST';
  package Carton::Dist;use strict;use Class::Tiny {name=>undef,pathname=>undef,provides=>sub {+{}},requirements=>sub {$_[0]->_build_requirements},};use CPAN::Meta;sub add_string_requirement {shift->requirements->add_string_requirement(@_)}sub required_modules {shift->requirements->required_modules(@_)}sub requirements_for_module {shift->requirements->requirements_for_module(@_)}sub is_core {0}sub distfile {my$self=shift;$self->pathname}sub _build_requirements {CPAN::Meta::Requirements->new}sub provides_module {my($self,$module)=@_;exists$self->provides->{$module}}sub version_for {my($self,$module)=@_;$self->provides->{$module}{version}}1;
CARTON_DIST

$fatpacked{"Carton/Dist/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_DIST_CORE';
  package Carton::Dist::Core;use strict;use parent 'Carton::Dist';use Class::Tiny qw(module_version);sub BUILDARGS {my($class,%args)=@_;$args{name}=~ s/::/-/g;\%args}sub is_core {1}sub version_for {my($self,$module)=@_;$self->module_version}1;
CARTON_DIST_CORE

$fatpacked{"Carton/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ENVIRONMENT';
  package Carton::Environment;use strict;use Carton::CPANfile;use Carton::Snapshot;use Carton::Error;use Carton::Tree;use Path::Tiny;use Class::Tiny {cpanfile=>undef,snapshot=>sub {$_[0]->_build_snapshot},install_path=>sub {$_[0]->_build_install_path},vendor_cache=>sub {$_[0]->_build_vendor_cache},tree=>sub {$_[0]->_build_tree},};sub _build_snapshot {my$self=shift;Carton::Snapshot->new(path=>$self->cpanfile .".snapshot")}sub _build_install_path {my$self=shift;if ($ENV{PERL_CARTON_PATH}){return Path::Tiny->new($ENV{PERL_CARTON_PATH})}else {return$self->cpanfile->path->parent->child("local")}}sub _build_vendor_cache {my$self=shift;Path::Tiny->new($self->install_path->dirname ."/vendor/cache")}sub _build_tree {my$self=shift;Carton::Tree->new(cpanfile=>$self->cpanfile,snapshot=>$self->snapshot)}sub vendor_bin {my$self=shift;$self->vendor_cache->parent->child('bin')}sub build_with {my($class,$cpanfile)=@_;$cpanfile=Path::Tiny->new($cpanfile)->absolute;if ($cpanfile->is_file){return$class->new(cpanfile=>Carton::CPANfile->new(path=>$cpanfile))}else {Carton::Error::CPANfileNotFound->throw(error=>"Can't locate cpanfile: $cpanfile")}}sub build {my($class,$cpanfile_path,$install_path)=@_;my$self=$class->new;$cpanfile_path &&= Path::Tiny->new($cpanfile_path)->absolute;my$cpanfile=$self->locate_cpanfile($cpanfile_path || $ENV{PERL_CARTON_CPANFILE});if ($cpanfile && $cpanfile->is_file){$self->cpanfile(Carton::CPANfile->new(path=>$cpanfile))}else {Carton::Error::CPANfileNotFound->throw(error=>"Can't locate cpanfile: (@{[ $cpanfile_path || 'cpanfile' ]})")}$self->install_path(Path::Tiny->new($install_path)->absolute)if$install_path;$self}sub locate_cpanfile {my($self,$path)=@_;if ($path){return Path::Tiny->new($path)->absolute}my$current=Path::Tiny->cwd;my$previous='';until ($current eq '/' or $current eq $previous){my$try=$current->child('cpanfile');if ($try->is_file){return$try->absolute}($previous,$current)=($current,$current->parent)}return}1;
CARTON_ENVIRONMENT

$fatpacked{"Carton/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_ERROR';
  package Carton::Error;use strict;use overload '""'=>sub {$_[0]->error};use Carp;sub throw {my($class,@args)=@_;die$class->new(@args)}sub rethrow {die $_[0]}sub new {my($class,%args)=@_;bless \%args,$class}sub error {$_[0]->{error}|| ref $_[0]}package Carton::Error::CommandNotFound;use parent 'Carton::Error';package Carton::Error::CommandExit;use parent 'Carton::Error';sub code {$_[0]->{code}}package Carton::Error::CPANfileNotFound;use parent 'Carton::Error';package Carton::Error::SnapshotParseError;use parent 'Carton::Error';sub path {$_[0]->{path}}package Carton::Error::SnapshotNotFound;use parent 'Carton::Error';sub path {$_[0]->{path}}1;
CARTON_ERROR

$fatpacked{"Carton/Index.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_INDEX';
  package Carton::Index;use strict;use Class::Tiny {_packages=>sub {+{}},generator=>sub {require Carton;"Carton $Carton::VERSION"},};sub add_package {my($self,$package)=@_;$self->_packages->{$package->name}=$package}sub count {my$self=shift;scalar keys %{$self->_packages}}sub packages {my$self=shift;sort {lc$a->name cmp lc$b->name}values %{$self->_packages}}sub write {my($self,$fh)=@_;print$fh <<EOF;for my$p ($self->packages){print$fh $self->_format_line($p->name,$p->version_format,$p->pathname)}}sub _format_line {my($self,@row)=@_;my$one=30;my$two=8;if (length$row[0]> $one){$one += 8 - length$row[1];$two=length$row[1]}sprintf "%-${one}s %${two}s  %s\n",@row}sub pad {my($str,$len,$left)=@_;my$howmany=$len - length($str);return$str if$howmany <= 0;my$pad=" " x $howmany;return$left ? "$pad$str" : "$str$pad"}1;
  File:         02packages.details.txt
  URL:          http://www.perl.com/CPAN/modules/02packages.details.txt
  Description:  Package names found in cpanfile.snapshot
  Columns:      package name, version, path
  Intended-For: Automated fetch routines, namespace documentation.
  Written-By:   @{[ $self->generator ]}
  Line-Count:   @{[ $self->count ]}
  Last-Updated: @{[ scalar localtime ]}
  
  EOF
CARTON_INDEX

$fatpacked{"Carton/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_MIRROR';
  package Carton::Mirror;use strict;use Class::Tiny qw(url);our$DefaultMirror='http://cpan.metacpan.org/';sub BUILDARGS {my($class,$url)=@_;return {url=>$url }}sub default {my$class=shift;$class->new($DefaultMirror)}sub is_default {my$self=shift;$self->url eq $DefaultMirror}1;
CARTON_MIRROR

$fatpacked{"Carton/Package.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKAGE';
  package Carton::Package;use strict;use Class::Tiny qw(name version pathname);sub BUILDARGS {my($class,@args)=@_;return {name=>$args[0],version=>$args[1],pathname=>$args[2]}}sub version_format {my$self=shift;defined$self->version ? $self->version : 'undef'}1;
CARTON_PACKAGE

$fatpacked{"Carton/Packer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_PACKER';
  package Carton::Packer;use Class::Tiny;use warnings NONFATAL=>'all';use App::FatPacker;use File::pushd ();use Path::Tiny ();use CPAN::Meta ();use File::Find ();sub fatpack_carton {my($self,$dir)=@_;my$temp=Path::Tiny->tempdir;my$pushd=File::pushd::pushd$temp;my$file=$temp->child('carton.pre.pl');$file->spew(<<'EOF');my$fatpacked=$self->do_fatpack($file);my$executable=$dir->child('carton');warn "Bundling $executable\n";$dir->mkpath;$executable->spew($fatpacked);chmod 0755,$executable}sub do_fatpack {my($self,$file)=@_;my$packer=App::FatPacker->new;my@modules=split /\r?\n/,$packer->trace(args=>[$file],use=>$self->required_modules);my@packlists=$packer->packlists_containing(\@modules);$packer->packlists_to_tree(Path::Tiny->new('fatlib')->absolute,\@packlists);my$fatpacked=do {local$SIG{__WARN__}=sub {};$packer->fatpack_file($file)};use Config;$fatpacked =~ s/\$fatpacked\{"$Config{archname}\/(Cwd|File)/\$fatpacked{"$1/g;$fatpacked}sub required_modules {my$self=shift;my%requirements;for my$dist (qw(Carton Menlo-Legacy Menlo)){$requirements{$_}=1 for$self->required_modules_for($dist)}my@extra=qw(Menlo::Index::Mirror);[keys%requirements,@extra ]}sub required_modules_for {my($self,$dist)=@_;my$meta=$self->installed_meta($dist)or die "Couldn't find install metadata for $dist";my%excludes=(perl=>1,'ExtUtils::MakeMaker'=>1,'Module::Build'=>1,);grep!$excludes{$_},$meta->effective_prereqs->requirements_for('runtime','requires')->required_modules}sub installed_meta {my($self,$dist)=@_;my@meta;my$finder=sub {if (m!\b$dist-.*[\\/]MYMETA.json!){my$meta=CPAN::Meta->load_file($_);push@meta,$meta if$meta->name eq $dist}};my@meta_dirs=grep -d,map "$_/.meta",@INC;File::Find::find({wanted=>$finder,no_chdir=>1 },@meta_dirs)if@meta_dirs;@meta=sort {version->new($b->version)cmp version->new($a->version)}@meta;return$meta[0]}1;
  #!/usr/bin/env perl
  use strict;
  use 5.008001;
  use Carton::CLI;
  $Carton::Fatpacked = 1;
  exit Carton::CLI->new->run(@ARGV);
  EOF
CARTON_PACKER

$fatpacked{"Carton/Snapshot.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT';
  package Carton::Snapshot;use strict;use Config;use Carton::Dist;use Carton::Dist::Core;use Carton::Error;use Carton::Package;use Carton::Index;use Carton::Util;use Carton::Snapshot::Emitter;use Carton::Snapshot::Parser;use CPAN::Meta;use CPAN::Meta::Requirements;use File::Find ();use Try::Tiny;use Path::Tiny ();use Module::CoreList;use constant CARTON_SNAPSHOT_VERSION=>'1.0';use subs 'path';use Class::Tiny {path=>undef,version=>sub {CARTON_SNAPSHOT_VERSION},loaded=>undef,_distributions=>sub {+[]},};sub BUILD {my$self=shift;$self->path($self->{path})}sub path {my$self=shift;if (@_){$self->{path}=Path::Tiny->new($_[0])}else {$self->{path}}}sub load_if_exists {my$self=shift;$self->load if$self->path->is_file}sub load {my$self=shift;return 1 if$self->loaded;if ($self->path->is_file){my$parser=Carton::Snapshot::Parser->new;$parser->parse($self->path->slurp_utf8,$self);$self->loaded(1);return 1}else {Carton::Error::SnapshotNotFound->throw(error=>"Can't find cpanfile.snapshot: Run `carton install` to build the snapshot file.",path=>$self->path,)}}sub save {my$self=shift;$self->path->spew_utf8(Carton::Snapshot::Emitter->new->emit($self))}sub find {my($self,$module)=@_;(grep $_->provides_module($module),$self->distributions)[0]}sub find_or_core {my($self,$module)=@_;$self->find($module)|| $self->find_in_core($module)}sub find_in_core {my($self,$module)=@_;if (exists$Module::CoreList::version{$]}{$module}){my$version=$Module::CoreList::version{$]}{$module};return Carton::Dist::Core->new(name=>$module,module_version=>$version)}return}sub index {my$self=shift;my$index=Carton::Index->new;for my$package ($self->packages){$index->add_package($package)}return$index}sub distributions {@{$_[0]->_distributions}}sub add_distribution {my($self,$dist)=@_;push @{$self->_distributions},$dist}sub packages {my$self=shift;my@packages;for my$dist ($self->distributions){while (my($package,$provides)=each %{$dist->provides}){push@packages,Carton::Package->new($package,$provides->{version},$dist->pathname)}}return@packages}sub write_index {my($self,$file)=@_;open my$fh,">",$file or die $!;$self->index->write($fh)}sub find_installs {my($self,$path,$reqs)=@_;my$libdir="$path/lib/perl5/$Config{archname}/.meta";return {}unless -e $libdir;my@installs;my$wanted=sub {if ($_ eq 'install.json'){push@installs,[$File::Find::name,"$File::Find::dir/MYMETA.json" ]}};File::Find::find($wanted,$libdir);my%installs;my$accepts=sub {my$module=shift;return 0 unless$reqs->accepts_module($module->{name},$module->{provides}{$module->{name}}{version});if (my$exist=$installs{$module->{name}}){my$old_ver=version::->new($exist->{provides}{$module->{name}}{version});my$new_ver=version::->new($module->{provides}{$module->{name}}{version});return$new_ver >= $old_ver}else {return 1}};for my$file (@installs){my$module=Carton::Util::load_json($file->[0]);my$prereqs=-f $file->[1]? CPAN::Meta->load_file($file->[1])->effective_prereqs : CPAN::Meta::Prereqs->new;my$reqs=CPAN::Meta::Requirements->new;$reqs->add_requirements($prereqs->requirements_for($_,'requires'))for qw(configure build runtime);if ($accepts->($module)){$installs{$module->{name}}=Carton::Dist->new(name=>$module->{dist},pathname=>$module->{pathname},provides=>$module->{provides},version=>$module->{version},requirements=>$reqs,)}}my@new_dists;for my$module (sort keys%installs){push@new_dists,$installs{$module}}$self->_distributions(\@new_dists)}1;
CARTON_SNAPSHOT

$fatpacked{"Carton/Snapshot/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_EMITTER';
  package Carton::Snapshot::Emitter;use Class::Tiny;use warnings NONFATAL=>'all';sub emit {my($self,$snapshot)=@_;my$data='';$data .= "# carton snapshot format: version @{[$snapshot->version]}\n";$data .= "DISTRIBUTIONS\n";for my$dist (sort {$a->name cmp $b->name}$snapshot->distributions){$data .= "  @{[$dist->name]}\n";$data .= "    pathname: @{[$dist->pathname]}\n";$data .= "    provides:\n";for my$package (sort keys %{$dist->provides}){my$version=$dist->provides->{$package}{version};$version='undef' unless defined$version;$data .= "      $package $version\n"}$data .= "    requirements:\n";for my$module (sort$dist->required_modules){$data .= "      $module @{[ $dist->requirements_for_module($module) || '0' ]}\n"}}$data}1;
CARTON_SNAPSHOT_EMITTER

$fatpacked{"Carton/Snapshot/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_SNAPSHOT_PARSER';
  package Carton::Snapshot::Parser;use Class::Tiny;use warnings NONFATAL=>'all';use Carton::Dist;use Carton::Error;my$machine={init=>[{re=>qr/^\# carton snapshot format: version (1\.0)/,code=>sub {my($stash,$snapshot,$ver)=@_;$snapshot->version($ver)},goto=>'section',},],section=>[{re=>qr/^DISTRIBUTIONS$/,goto=>'dists',},{re=>qr/^__EOF__$/,done=>1,},],dists=>[{re=>qr/^  (\S+)$/,code=>sub {$_[0]->{dist}=Carton::Dist->new(name=>$1)},goto=>'distmeta',},{re=>qr/^\S/,goto=>'section',redo=>1,},],distmeta=>[{re=>qr/^    pathname: (.*)$/,code=>sub {$_[0]->{dist}->pathname($1)},},{re=>qr/^\s{4}provides:$/,code=>sub {$_[0]->{property}='provides'},goto=>'properties',},{re=>qr/^\s{4}requirements:$/,code=>sub {$_[0]->{property}='requirements'},goto=>'properties',},{re=>qr/^\s{0,2}\S/,code=>sub {my($stash,$snapshot)=@_;$snapshot->add_distribution($stash->{dist});%$stash=()},goto=>'dists',redo=>1,},],properties=>[{re=>qr/^\s{6}([0-9A-Za-z_:]+) ([v0-9\._,=\!<>\s]+|undef)/,code=>sub {my($stash,$snapshot,$module,$version)=@_;if ($stash->{property}eq 'provides'){$stash->{dist}->provides->{$module}={version=>$version }}else {$stash->{dist}->add_string_requirement($module,$version)}},},{re=>qr/^\s{0,4}\S/,goto=>'distmeta',redo=>1,},],};sub parse {my($self,$data,$snapshot)=@_;my@lines=split /\r?\n/,$data;my$state=$machine->{init};my$stash={};LINE: for my$line (@lines,'__EOF__'){last LINE unless @$state;STATE: {for my$trans (@{$state}){if (my@match=$line =~ $trans->{re}){if (my$code=$trans->{code}){$code->($stash,$snapshot,@match)}if (my$goto=$trans->{goto}){$state=$machine->{$goto};if ($trans->{redo}){redo STATE}else {next LINE}}last STATE}}Carton::Error::SnapshotParseError->throw(error=>"Could not parse snapshot file: $line")}}}1;
CARTON_SNAPSHOT_PARSER

$fatpacked{"Carton/Tree.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_TREE';
  package Carton::Tree;use strict;use Carton::Dependency;use Class::Tiny qw(cpanfile snapshot);use constant STOP=>-1;sub walk_down {my($self,$cb)=@_;my$dumper;$dumper=sub {my($dependency,$reqs,$level,$parent)=@_;my$ret=$cb->($dependency,$reqs,$level);return if$ret && $ret==STOP;local$parent->{$dependency->distname}=1 if$dependency;for my$module (sort$reqs->required_modules){my$dependency=$self->dependency_for($module,$reqs);if ($dependency->dist){next if$parent->{$dependency->distname};$dumper->($dependency,$dependency->requirements,$level + 1,$parent)}else {}}};$dumper->(undef,$self->cpanfile->requirements,0,{});undef$dumper}sub dependency_for {my($self,$module,$reqs)=@_;my$requirement=$reqs->requirements_for_module($module);my$dep=Carton::Dependency->new;$dep->module($module);$dep->requirement($requirement);if (my$dist=$self->snapshot->find_or_core($module)){$dep->dist($dist)}return$dep}sub merged_requirements {my$self=shift;my$merged_reqs=CPAN::Meta::Requirements->new;my%seen;$self->walk_down(sub {my($dependency,$reqs,$level)=@_;return Carton::Tree::STOP if$dependency && $seen{$dependency->distname}++;$merged_reqs->add_requirements($reqs)});$merged_reqs->clear_requirement('perl');$merged_reqs->finalize;$merged_reqs}1;
CARTON_TREE

$fatpacked{"Carton/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CARTON_UTIL';
  package Carton::Util;use strict;use warnings;sub load_json {my$file=shift;open my$fh,"<",$file or die "$file: $!";from_json(join '',<$fh>)}sub dump_json {my($data,$file)=@_;open my$fh,">",$file or die "$file: $!";binmode$fh;print$fh to_json($data)}sub from_json {require JSON::PP;JSON::PP->new->utf8->decode($_[0])}sub to_json {my($data)=@_;require JSON::PP;JSON::PP->new->utf8->pretty->canonical->encode($data)}1;
CARTON_UTIL

$fatpacked{"Class/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_TINY';
  use 5.006;use strict;no strict 'refs';use warnings;package Class::Tiny;our$VERSION='1.008';use Carp ();require($] >= 5.010 ? "mro.pm" : "MRO/Compat.pm");my%CLASS_ATTRIBUTES;sub import {my$class=shift;my$pkg=caller;$class->prepare_class($pkg);$class->create_attributes($pkg,@_)if @_}sub prepare_class {my ($class,$pkg)=@_;@{"${pkg}::ISA"}="Class::Tiny::Object" unless @{"${pkg}::ISA"}}sub create_attributes {my ($class,$pkg,@spec)=@_;my%defaults=map {ref $_ eq 'HASH' ? %$_ : ($_=>undef)}@spec;my@attr=grep {defined and!ref and /^[^\W\d]\w*$/s or Carp::croak "Invalid accessor name '$_'"}keys%defaults;$CLASS_ATTRIBUTES{$pkg}{$_}=$defaults{$_}for@attr;$class->_gen_accessor($pkg,$_)for grep {!*{"$pkg\::$_"}{CODE}}@attr;Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub _gen_accessor {my ($class,$pkg,$name)=@_;my$outer_default=$CLASS_ATTRIBUTES{$pkg}{$name};my$sub=$class->__gen_sub_body($name,defined($outer_default),ref($outer_default));eval "package $pkg; my \$default=\$outer_default; $sub";Carp::croak("Failed to generate attributes for $pkg: $@\n")if $@}sub __gen_sub_body {my ($self,$name,$has_default,$default_type)=@_;if ($has_default && $default_type eq 'CODE'){return << "HERE"}elsif ($has_default){return << "HERE"}else {return << "HERE"}}sub get_all_attributes_for {my ($class,$pkg)=@_;my%attr=map {$_=>undef}map {keys %{$CLASS_ATTRIBUTES{$_}|| {}}}@{mro::get_linear_isa($pkg)};return keys%attr}sub get_all_attribute_defaults_for {my ($class,$pkg)=@_;my$defaults={};for my$p (reverse @{mro::get_linear_isa($pkg)}){while (my ($k,$v)=each %{$CLASS_ATTRIBUTES{$p}|| {}}){$defaults->{$k}=$v}}return$defaults}package Class::Tiny::Object;our$VERSION='1.008';my (%HAS_BUILDARGS,%BUILD_CACHE,%DEMOLISH_CACHE,%ATTR_CACHE);my$_PRECACHE=sub {no warnings 'once';my ($class)=@_;my$linear_isa=@{"$class\::ISA"}==1 && ${"$class\::ISA"}[0]eq "Class::Tiny::Object" ? [$class]: mro::get_linear_isa($class);$DEMOLISH_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::DEMOLISH"}@$linear_isa ];$BUILD_CACHE{$class}=[map {(*{$_}{CODE})? (*{$_}{CODE}): ()}map {"$_\::BUILD"}reverse @$linear_isa ];$HAS_BUILDARGS{$class}=$class->can("BUILDARGS");return$ATTR_CACHE{$class}={map {$_=>1}Class::Tiny->get_all_attributes_for($class)}};sub new {my$class=shift;my$valid_attrs=$ATTR_CACHE{$class}|| $_PRECACHE->($class);my$args;if ($HAS_BUILDARGS{$class}){$args=$class->BUILDARGS(@_)}else {if (@_==1 && ref $_[0]){my%copy=eval {%{$_[0]}};Carp::croak("Argument to $class->new() could not be dereferenced as a hash")if $@;$args=\%copy}elsif (@_ % 2==0){$args={@_}}else {Carp::croak("$class->new() got an odd number of elements")}}my$self=bless {map {$_=>$args->{$_}}grep {exists$valid_attrs->{$_}}keys %$args },$class;$self->BUILDALL($args)if!delete$args->{__no_BUILD__}&& @{$BUILD_CACHE{$class}};return$self}sub BUILDALL {$_->(@_)for @{$BUILD_CACHE{ref $_[0]}}}require Devel::GlobalDestruction unless defined ${^GLOBAL_PHASE};sub DESTROY {my$self=shift;my$class=ref$self;my$in_global_destruction=defined ${^GLOBAL_PHASE} ? ${^GLOBAL_PHASE} eq 'DESTRUCT' : Devel::GlobalDestruction::in_global_destruction();for my$demolisher (@{$DEMOLISH_CACHE{$class}}){my$e=do {local ($?,$@);eval {$demolisher->($self,$in_global_destruction)};$@};no warnings 'misc';die$e if$e}}1;
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default->( \$_[0] ) )
      );
  }
  HERE
  sub $name {
      return (
            ( \@_ == 1 && exists \$_[0]{$name} )
          ? ( \$_[0]{$name} )
          : ( \$_[0]{$name} = ( \@_ == 2 ) ? \$_[1] : \$default )
      );
  }
  HERE
  sub $name {
      return \@_ == 1 ? \$_[0]{$name} : ( \$_[0]{$name} =  \$_[1] );
  }
  HERE
CLASS_TINY

$fatpacked{"Command/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER';
  package Command::Runner;use strict;use warnings;use Capture::Tiny ();use Command::Runner::Format ();use Command::Runner::LineBuffer;use Command::Runner::Quote ();use Command::Runner::Timeout;use Config ();use IO::Select;use POSIX ();use Time::HiRes ();use constant WIN32=>$^O eq 'MSWin32';our$VERSION='0.103';our$TICK=0.02;sub new {my ($class,%option)=@_;my$command=delete$option{command};my$commandf=delete$option{commandf};die "Cannot specify both command and commandf" if$command && $commandf;if (!$command && $commandf){$command=Command::Runner::Format::commandf @$commandf}bless {keep=>1,_buffer=>{},%option,($command ? (command=>$command): ()),},$class}for my$attr (qw(command redirect timeout keep stdout stderr env)){no strict 'refs';*$attr=sub {my$self=shift;$self->{$attr}=$_[0];$self}}sub commandf {my ($self,$format,@args)=@_;$self->{command}=Command::Runner::Format::commandf$format,@args;$self}sub run {my$self=shift;local%ENV=%{$self->{env}}if$self->{env};my$command=$self->{command};if (ref$command eq 'CODE'){$self->_wrap(sub {$self->_run_code($command)})}elsif (WIN32){$self->_wrap(sub {$self->_system_win32($command)})}else {$self->_exec($command)}}sub _wrap {my ($self,$code)=@_;my ($stdout,$stderr,$res);if ($self->{redirect}){($stdout,$res)=&Capture::Tiny::capture_merged($code)}else {($stdout,$stderr,$res)=&Capture::Tiny::capture($code)}if (length$stdout and my$sub=$self->{stdout}){my$buffer=Command::Runner::LineBuffer->new(buffer=>$stdout);my@line=$buffer->get(1);$sub->($_)for@line}if (!$self->{redirect}and length$stderr and my$sub=$self->{stderr}){my$buffer=Command::Runner::LineBuffer->new(buffer=>$stderr);my@line=$buffer->get(1);$sub->($_)for@line}if ($self->{keep}){$res->{stdout}=$stdout;$res->{stderr}=$stderr}return$res}sub _run_code {my ($self,$code)=@_;if (!$self->{timeout}){my$result=$code->();return {pid=>$$,result=>$result }}my ($result,$err);{local$SIG{__DIE__}='DEFAULT';local$SIG{ALRM}=sub {die "__TIMEOUT__\n"};eval {alarm$self->{timeout};$result=$code->()};$err=$@;alarm 0}if (!$err){return {pid=>$$,result=>$result,}}elsif ($err eq "__TIMEOUT__\n"){return {pid=>$$,result=>$result,timeout=>1 }}else {die$err}}sub _system_win32 {my ($self,$command)=@_;my$pid;if (ref$command){my@cmd=map {Command::Runner::Quote::quote_win32($_)}@$command;$pid=system {$command->[0]}1,@cmd}else {$pid=system 1,$command}my$timeout=$self->{timeout}? Command::Runner::Timeout->new($self->{timeout},1): undef;my$INT;local$SIG{INT}=sub {$INT++};my$result;while (1){if ($INT){kill INT=>$pid;$INT=0}my$res=waitpid$pid,POSIX::WNOHANG();if ($res==-1){warn "waitpid($pid, POSIX::WNOHANG()) returns unexpectedly -1";last}elsif ($res > 0){$result=$?;last}else {if ($timeout and my$signal=$timeout->signal){kill$signal=>$pid}Time::HiRes::sleep($TICK)}}return {pid=>$pid,result=>$result,timeout=>$timeout && $timeout->signaled }}sub _exec {my ($self,$command)=@_;pipe my$stdout_read,my$stdout_write;$self->{_buffer}{stdout}=Command::Runner::LineBuffer->new(keep=>$self->{keep});my ($stderr_read,$stderr_write);if (!$self->{redirect}){pipe$stderr_read,$stderr_write;$self->{_buffer}{stderr}=Command::Runner::LineBuffer->new(keep=>$self->{keep})}my$pid=fork;die "fork: $!" unless defined$pid;if ($pid==0){close $_ for grep $_,$stdout_read,$stderr_read;open STDOUT,">&",$stdout_write;if ($self->{redirect}){open STDERR,">&",\*STDOUT}else {open STDERR,">&",$stderr_write}if ($Config::Config{d_setpgrp}){POSIX::setpgid(0,0)or die "setpgid: $!"}if (ref$command){exec {$command->[0]}@$command}else {exec$command}exit 127}close $_ for grep $_,$stdout_write,$stderr_write;my$signal_pid=$Config::Config{d_setpgrp}? -$pid : $pid;my$INT;local$SIG{INT}=sub {$INT++};my$timeout=$self->{timeout}? Command::Runner::Timeout->new($self->{timeout},1): undef;my$select=IO::Select->new(grep $_,$stdout_read,$stderr_read);while ($select->count){if ($INT){kill INT=>$signal_pid;$INT=0}if ($timeout and my$signal=$timeout->signal){kill$signal=>$signal_pid}for my$ready ($select->can_read($TICK)){my$type=$ready==$stdout_read ? "stdout" : "stderr";my$len=sysread$ready,my$buf,64*1024;if ($len){my$buffer=$self->{_buffer}{$type};$buffer->add($buf);next unless my@line=$buffer->get;next unless my$sub=$self->{$type};$sub->($_)for@line}else {warn "sysread $type pipe failed: $!" unless defined$len;$select->remove($ready);close$ready}}}for my$type (qw(stdout stderr)){next unless my$sub=$self->{$type};my$buffer=$self->{_buffer}{$type}or next;my@line=$buffer->get(1)or next;$sub->($_)for@line}close $_ for$select->handles;waitpid$pid,0;my$res={pid=>$pid,result=>$?,timeout=>$timeout && $timeout->signaled,stdout=>$self->{_buffer}{stdout}? $self->{_buffer}{stdout}->raw : "",stderr=>$self->{_buffer}{stderr}? $self->{_buffer}{stderr}->raw : "",};$self->{_buffer}=+{};return$res}1;
COMMAND_RUNNER

$fatpacked{"Command/Runner/Format.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_FORMAT';
  package Command::Runner::Format;use strict;use warnings;use Command::Runner::Quote 'quote';use Exporter 'import';our@EXPORT_OK=qw(commandf);my$regex=qr/
                 (%             # leading '%'                    $1
                  (-)?          # left-align, rather than right  $2
                  (\d*)?        # (optional) minimum field width $3
                  (?:\.(\d*))?  # (optional) maximum field width $4
                  (\{.*?\})?    # (optional) stuff inside        $5
                  (\S)          # actual format character        $6
               )/x;sub commandf {my ($format,@args)=@_;my$i=0;$format =~ s{$regex}{
          $6 eq '%' ? '%' : _replace($args[$i++], $1, $6)
      }ge;$format}sub _replace {my ($arg,$all,$char)=@_;if ($char eq 'q'){return quote$arg}else {return sprintf$all,$arg}}1;
COMMAND_RUNNER_FORMAT

$fatpacked{"Command/Runner/LineBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_LINEBUFFER';
  package Command::Runner::LineBuffer;use strict;use warnings;sub new {my ($class,%args)=@_;my$buffer=exists$args{buffer}? $args{buffer}: "";bless {buffer=>$buffer,$args{keep}? (keep=>$buffer): (),},$class}sub raw {my$self=shift;exists$self->{keep}? $self->{keep}: undef}sub add {my ($self,$buffer)=@_;$self->{buffer}.= $buffer;$self->{keep}.= $buffer if exists$self->{keep};$self}sub get {my ($self,$drain)=@_;if ($drain){if (length$self->{buffer}){my@line=$self->get;if (length$self->{buffer}and $self->{buffer}ne "\x0d"){$self->{buffer}=~ s/[\x0d\x0a]+\z//;push@line,$self->{buffer}}$self->{buffer}="";return@line}else {return}}my@line;while ($self->{buffer}=~ s/\A(.*?(?:\x0d\x0a|\x0d|\x0a))//sm){my$line=$1;next if$line eq "\x0d";$line =~ s/[\x0d\x0a]+\z//;push@line,$line}return@line}1;
COMMAND_RUNNER_LINEBUFFER

$fatpacked{"Command/Runner/Quote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_QUOTE';
  package Command::Runner::Quote;use strict;use warnings;use Win32::ShellQuote ();use String::ShellQuote ();use Exporter 'import';our@EXPORT_OK=qw(quote quote_win32 quote_unix);sub quote_win32 {my$str=shift;Win32::ShellQuote::quote_literal($str,1)}sub quote_unix {my$str=shift;String::ShellQuote::shell_quote_best_effort($str)}if ($^O eq 'MSWin32'){*quote=\&quote_win32}else {*quote=\&quote_unix}1;
COMMAND_RUNNER_QUOTE

$fatpacked{"Command/Runner/Timeout.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'COMMAND_RUNNER_TIMEOUT';
  package Command::Runner::Timeout;use strict;use warnings;use Time::HiRes ();sub new {my ($class,$at,$kill)=@_;my$now=Time::HiRes::time();bless {signaled=>0,at=>$now + $at,at_kill=>$now + $at + $kill },$class}sub signal {my$self=shift;return if!$self->{at}&&!$self->{at_kill};my$now=Time::HiRes::time();if ($self->{at}and $now >= $self->{at}){$self->{at}=undef;$self->{signaled}=1;return 'TERM'}if ($now >= $self->{at_kill}){$self->{at_kill}=undef;$self->{signaled}=1;return 'KILL'}return}sub signaled {my$self=shift;$self->{signaled}}1;
COMMAND_RUNNER_TIMEOUT

$fatpacked{"Devel/InnerPackage.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;use strict;use Exporter 5.57 'import';use vars qw($VERSION @EXPORT_OK);use if $] > 5.017,'deprecate';$VERSION='0.4';@EXPORT_OK=qw(list_packages);sub list_packages {my$pack=shift;$pack .= "::" unless$pack =~ m!::$!;no strict 'refs';my@packs;my@stuff=grep!/^(main|)::$/,keys %{$pack};for my$cand (grep /::$/,@stuff){$cand =~ s!::$!!;my@children=list_packages($pack.$cand);push@packs,"$pack$cand" unless$cand =~ /^::/ || !__PACKAGE__->_loaded($pack.$cand);push@packs,@children}return grep {$_ !~ /::(::ISA::CACHE|SUPER)/}@packs}sub _loaded {my ($class,$name)=@_;no strict 'refs';return 1 if defined ${"${name}::VERSION"};return 1 if @{"${name}::ISA"};for (keys %{"${name}::"}){next if substr($_,-2,2)eq '::';return 1 if defined &{"${name}::$_"}}my$filename=join('/',split /(?:'|::)/,$name).'.pm';return 1 if defined$INC{$filename};''}1;
DEVEL_INNERPACKAGE

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.012';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$dirs)=@_;my%localdir_for;if ($dirs && %$dirs){%localdir_for=%$dirs}else {for my$type ($self->install_types){$localdir_for{$type}=File::Spec->catdir('blib',$type)}}my (%map,@skipping);for my$type (keys%localdir_for){next if not -e $localdir_for{$type};if (my$dest=$self->install_destination($type)){$map{$localdir_for{$type}}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"ExtUtils/MakeMaker/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_MAKEMAKER_CPANFILE';
  package ExtUtils::MakeMaker::CPANfile;use strict;use warnings;use ExtUtils::MakeMaker ();use File::Spec::Functions qw/catfile rel2abs/;use Module::CPANfile;use version;our$VERSION="0.09";sub import {my$class=shift;my$orig=\&ExtUtils::MakeMaker::WriteMakefile;my$writer=sub {my%params=@_;my ($caller,$file,$line)=caller;(my$root=rel2abs($file))=~ s/Makefile\.PL$//i or return;if (my$file=eval {Module::CPANfile->load(catfile($root,"cpanfile"))}){my$prereqs=$file->prereqs;_merge(\%params,_get($prereqs,'runtime','requires'),'PREREQ_PM',);_merge(\%params,_get($prereqs,'build','requires'),_eumm('6.56')? 'BUILD_REQUIRES' : 'PREREQ_PM',);_merge(\%params,_get($prereqs,'test','requires'),_eumm('6.63_03')? 'TEST_REQUIRES' : _eumm('6.56')? 'BUILD_REQUIRES' : 'PREREQ_PM',);_merge(\%params,_get($prereqs,'configure','requires'),_eumm('6.52')? 'CONFIGURE_REQUIRES' : undef,);_merge(\%params,{'ExtUtils::MakeMaker::CPANfile'=>$VERSION},_eumm('6.52')? 'CONFIGURE_REQUIRES' : undef,);if (!exists$params{META_ADD}{dynamic_config}&& !exists$params{META_MERGE}{dynamic_config}){$params{META_MERGE}{dynamic_config}=0}my$requires_2_0;for my$type (qw/recommends suggests conflicts/){for my$phase (qw/configure build test runtime develop/){my%tmp=%{$params{META_MERGE}{prereqs}{$phase}|| {}};_merge(\%tmp,_get($prereqs,$phase,$type),$type,);if ($tmp{$type}){$params{META_MERGE}{prereqs}{$phase}=\%tmp;$requires_2_0=1}}}if ($requires_2_0){my$tmp_prereqs=delete$params{META_MERGE}{prereqs};require CPAN::Meta::Converter;for my$key (qw/META_ADD META_MERGE/){next unless %{$params{$key}|| {}};my$converter=CPAN::Meta::Converter->new($params{$key},default_version=>1.4);$params{$key}=$converter->upgrade_fragment}if ($params{META_MERGE}{prereqs}){require CPAN::Meta::Requirements;for my$phase (keys %{$tmp_prereqs || {}}){for my$rel (keys %{$tmp_prereqs->{$phase}|| {}}){my$req1=CPAN::Meta::Requirements->from_string_hash($tmp_prereqs->{$phase}{$rel});my$req2=CPAN::Meta::Requirements->from_string_hash($params{META_MERGE}{prereqs}{$phase}{$rel});$req1->add_requirements($req2);$params{META_MERGE}{prereqs}{$phase}=$req1->as_string_hash}}}else {$params{META_MERGE}{prereqs}=$tmp_prereqs}}{last if _eumm('6.66_03');if (my$r=delete$params{TEST_REQUIRES}){_merge(\%params,$r,'BUILD_REQUIRES')}last if _eumm('6.56');if (my$r=delete$params{BUILD_REQUIRES}){_merge(\%params,$r,'PREREQ_PM')}last if _eumm('6.52');delete$params{CONFIGURE_REQUIRES};last if _eumm('6.47_01');delete$params{MIN_PERL_VERSION};last if _eumm('6.45_01');delete$params{META_ADD};delete$params{META_MERGE};last if _eumm('6.30_01');delete$params{LICENSE}}}else {print "cpanfile is not available: $@\n";exit 0}$orig->(%params)};{no warnings 'redefine';*main::WriteMakefile=*ExtUtils::MakeMaker::WriteMakefile=$writer}}sub _eumm {my$version=shift;eval {ExtUtils::MakeMaker->VERSION($version)}? 1 : 0}sub _get {my$prereqs=shift;eval {$prereqs->requirements_for(@_)->as_string_hash}}sub _merge {my ($params,$requires,$key)=@_;return unless$key;for (keys %{$requires || {}}){my$version=_normalize_version($requires->{$_});next unless defined$version;if (not exists$params->{$key}{$_}){$params->{$key}{$_}=$version}else {my$prev=$params->{$key}{$_};if (version->parse($prev)< version->parse($version)){$params->{$key}{$_}=$version}}}}sub _normalize_version {my$version=shift;return unless defined$version;return$version unless$version =~ /\s/;$version =~ s/(?:>=|==)\s*//;$version =~ s/,.+$//;return$version unless$version =~ /\s/;return}1;
EXTUTILS_MAKEMAKER_CPANFILE

$fatpacked{"File/Copy/Recursive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_COPY_RECURSIVE';
  package File::Copy::Recursive;use strict;BEGIN {$INC{'warnings.pm'}="fake warnings entry for < 5.6 perl ($])" if $] < 5.006}use warnings;use Carp;use File::Copy;use File::Spec;use Cwd ();use vars qw(@ISA @EXPORT_OK $VERSION $MaxDepth $KeepMode $CPRFComp $CopyLink $PFSCheck $RemvBase $NoFtlPth $ForcePth $CopyLoop $RMTrgFil $RMTrgDir $CondCopy $BdTrgWrn $SkipFlop $DirPerms);require Exporter;@ISA=qw(Exporter);@EXPORT_OK=qw(fcopy rcopy dircopy fmove rmove dirmove pathmk pathrm pathempty pathrmdir rcopy_glob rmove_glob);$VERSION='0.45';$MaxDepth=0;$KeepMode=1;$CPRFComp=0;$CopyLink=eval {local$SIG{'__DIE__'};symlink '','';1}|| 0;$PFSCheck=1;$RemvBase=0;$NoFtlPth=0;$ForcePth=0;$CopyLoop=0;$RMTrgFil=0;$RMTrgDir=0;$CondCopy={};$BdTrgWrn=0;$SkipFlop=0;$DirPerms=0777;my$samecheck=sub {return 1 if $^O eq 'MSWin32';return if @_!=2 ||!defined $_[0]||!defined $_[1];return if $_[0]eq $_[1];my$one='';if ($PFSCheck){$one=join('-',(stat $_[0])[0,1 ])|| '';my$two=join('-',(stat $_[1])[0,1 ])|| '';if ($one eq $two && $one){carp "$_[0] and $_[1] are identical";return}}if (-d $_[0]&&!$CopyLoop){$one=join('-',(stat $_[0])[0,1 ])if!$one;my$abs=File::Spec->rel2abs($_[1]);my@pth=File::Spec->splitdir($abs);while (@pth){if ($pth[-1]eq '..'){pop@pth;pop@pth unless -l File::Spec->catdir(@pth);next}my$cur=File::Spec->catdir(@pth);last if!$cur;my$two=join('-',(stat$cur)[0,1 ])|| '';if ($one eq $two && $one){carp "Caught Deep Recursion Condition: $_[0] contains $_[1]";return}pop@pth}}return 1};my$glob=sub {my ($do,$src_glob,@args)=@_;local$CPRFComp=1;require File::Glob;my@rt;for my$path (File::Glob::bsd_glob($src_glob)){my@call=[$do->($path,@args)]or return;push@rt,\@call}return@rt};my$move=sub {my$fl=shift;my@x;if ($fl){@x=fcopy(@_)or return}else {@x=dircopy(@_)or return}if (@x){if ($fl){unlink $_[0]or return}else {pathrmdir($_[0])or return}if ($RemvBase){my ($volm,$path)=File::Spec->splitpath($_[0]);pathrm(File::Spec->catpath($volm,$path,''),$ForcePth,$NoFtlPth)or return}}return wantarray ? @x : $x[0]};my$ok_todo_asper_condcopy=sub {my$org=shift;my$copy=1;if (exists$CondCopy->{$org}){if ($CondCopy->{$org}{'md5'}){}if ($copy){}}return$copy};sub fcopy {$samecheck->(@_)or return;if ($RMTrgFil && (-d $_[1]|| -e $_[1])){my$trg=$_[1];if (-d $trg){my@trgx=File::Spec->splitpath($_[0]);$trg=File::Spec->catfile($_[1],$trgx[$#trgx])}$samecheck->($_[0],$trg)or return;if (-e $trg){if ($RMTrgFil==1){unlink$trg or carp "\$RMTrgFil failed: $!"}else {unlink$trg or return}}}my ($volm,$path)=File::Spec->splitpath($_[1]);if ($path &&!-d $path){pathmk(File::Spec->catpath($volm,$path,''),$NoFtlPth)}if (-l $_[0]&& $CopyLink){my$target=readlink(shift());($target)=$target =~ m/(.*)/;carp "Copying a symlink ($_[0]) whose target does not exist" if!-e $target && $BdTrgWrn;my$new=shift();unlink$new if -l $new;symlink($target,$new)or return}elsif (-d $_[0]&& -f $_[1]){return}else {return if -d $_[0];copy(@_)or return;my@base_file=File::Spec->splitpath($_[0]);my$mode_trg=-d $_[1]? File::Spec->catfile($_[1],$base_file[$#base_file]): $_[1];chmod scalar((stat($_[0]))[2]),$mode_trg if$KeepMode}return wantarray ? (1,0,0): 1}sub rcopy {if (-l $_[0]&& $CopyLink){goto&fcopy}goto&dircopy if -d $_[0]|| substr($_[0],(1 * -1),1)eq '*';goto&fcopy}sub rcopy_glob {$glob->(\&rcopy,@_)}sub dircopy {if ($RMTrgDir && -d $_[1]){if ($RMTrgDir==1){pathrmdir($_[1])or carp "\$RMTrgDir failed: $!"}else {pathrmdir($_[1])or return}}my$globstar=0;my$_zero=$_[0];my$_one=$_[1];if (substr($_zero,(1 * -1),1)eq '*'){$globstar=1;$_zero=substr($_zero,0,(length($_zero)- 1))}$samecheck->($_zero,$_[1])or return;if (!-d $_zero || (-e $_[1]&&!-d $_[1])){$!=20;return}if (!-d $_[1]){pathmk($_[1],$NoFtlPth)or return}else {if ($CPRFComp &&!$globstar){my@parts=File::Spec->splitdir($_zero);while ($parts[$#parts]eq ''){pop@parts}$_one=File::Spec->catdir($_[1],$parts[$#parts])}}my$baseend=$_one;my$level=0;my$filen=0;my$dirn=0;my$recurs;$recurs=sub {my ($str,$end,$buf)=@_;$filen++ if$end eq $baseend;$dirn++ if$end eq $baseend;$DirPerms=oct($DirPerms)if substr($DirPerms,0,1)eq '0';mkdir($end,$DirPerms)or return if!-d $end;if ($MaxDepth && $MaxDepth =~ m/^\d+$/ && $level >= $MaxDepth){chmod scalar((stat($str))[2]),$end if$KeepMode;return ($filen,$dirn,$level)if wantarray;return$filen}$level++;my@files;if ($] < 5.006){opendir(STR_DH,$str)or return;@files=grep($_ ne '.' && $_ ne '..',readdir(STR_DH));closedir STR_DH}else {opendir(my$str_dh,$str)or return;@files=grep($_ ne '.' && $_ ne '..',readdir($str_dh));closedir$str_dh}for my$file (@files){my ($file_ut)=$file =~ m{ (.*) }xms;my$org=File::Spec->catfile($str,$file_ut);my$new=File::Spec->catfile($end,$file_ut);if (-l $org && $CopyLink){my$target=readlink($org);($target)=$target =~ m/(.*)/;carp "Copying a symlink ($org) whose target does not exist" if!-e $target && $BdTrgWrn;unlink$new if -l $new;symlink($target,$new)or return}elsif (-d $org){my$rc;if (!-w $org && $KeepMode){local$KeepMode=0;$rc=$recurs->($org,$new,$buf)if defined$buf;$rc=$recurs->($org,$new)if!defined$buf;chmod scalar((stat($org))[2]),$new}else {$rc=$recurs->($org,$new,$buf)if defined$buf;$rc=$recurs->($org,$new)if!defined$buf}if (!$rc){if ($SkipFlop){next}else {return}}$filen++;$dirn++}else {if ($ok_todo_asper_condcopy->($org)){if ($SkipFlop){fcopy($org,$new,$buf)or next if defined$buf;fcopy($org,$new)or next if!defined$buf}else {fcopy($org,$new,$buf)or return if defined$buf;fcopy($org,$new)or return if!defined$buf}chmod scalar((stat($org))[2]),$new if$KeepMode;$filen++}}}$level--;chmod scalar((stat($str))[2]),$end if$KeepMode;1};$recurs->($_zero,$_one,$_[2])or return;return wantarray ? ($filen,$dirn,$level): $filen}sub fmove {$move->(1,@_)}sub rmove {if (-l $_[0]&& $CopyLink){goto&fmove}goto&dirmove if -d $_[0]|| substr($_[0],(1 * -1),1)eq '*';goto&fmove}sub rmove_glob {$glob->(\&rmove,@_)}sub dirmove {$move->(0,@_)}sub pathmk {my ($vol,$dir,$file)=File::Spec->splitpath(shift());my$nofatal=shift;$DirPerms=oct($DirPerms)if substr($DirPerms,0,1)eq '0';if (defined($dir)){my (@dirs)=File::Spec->splitdir($dir);for (my$i=0;$i < scalar(@dirs);$i++ ){my$newdir=File::Spec->catdir(@dirs[0 .. $i ]);my$newpth=File::Spec->catpath($vol,$newdir,"");mkdir($newpth,$DirPerms)or return if!-d $newpth &&!$nofatal;mkdir($newpth,$DirPerms)if!-d $newpth && $nofatal}}if (defined($file)){my$newpth=File::Spec->catpath($vol,$dir,$file);mkdir($newpth,$DirPerms)or return if!-d $newpth &&!$nofatal;mkdir($newpth,$DirPerms)if!-d $newpth && $nofatal}1}sub pathempty {my$pth=shift;my ($orig_dev,$orig_ino)=(lstat$pth)[0,1 ];return 2 if!-d _ ||!defined($orig_dev)|| ($^O ne 'MSWin32' &&!$orig_ino);my$starting_point=Cwd::cwd();my ($starting_dev,$starting_ino)=(lstat$starting_point)[0,1 ];chdir($pth)or Carp::croak("Failed to change directory to $pth: $!");$pth='.';_bail_if_changed($pth,$orig_dev,$orig_ino);my@names;my$pth_dh;if ($] < 5.006){opendir(PTH_DH,$pth)or return;@names=grep!/^\.\.?$/,readdir(PTH_DH);closedir PTH_DH}else {opendir($pth_dh,$pth)or return;@names=grep!/^\.\.?$/,readdir($pth_dh);closedir$pth_dh}_bail_if_changed($pth,$orig_dev,$orig_ino);for my$name (@names){my ($name_ut)=$name =~ m{ (.*) }xms;my$flpth=File::Spec->catdir($pth,$name_ut);if (-l $flpth){_bail_if_changed($pth,$orig_dev,$orig_ino);unlink$flpth or return}elsif (-d $flpth){_bail_if_changed($pth,$orig_dev,$orig_ino);pathrmdir($flpth)or return}else {_bail_if_changed($pth,$orig_dev,$orig_ino);unlink$flpth or return}}chdir($starting_point)or Carp::croak("Failed to change directory to $starting_point: $!");_bail_if_changed(".",$starting_dev,$starting_ino);return 1}sub pathrm {my ($path,$force,$nofail)=@_;my ($orig_dev,$orig_ino)=(lstat$path)[0,1 ];return 2 if!-d _ ||!defined($orig_dev)||!$orig_ino;if ($force && File::Spec->file_name_is_absolute($path)){Carp::croak("pathrm() w/ force on abspath is not allowed")}my@pth=File::Spec->splitdir($path);my%fs_check;my$aggregate_path;for my$part (@pth){$aggregate_path=defined$aggregate_path ? File::Spec->catdir($aggregate_path,$part): $part;$fs_check{$aggregate_path}=[(lstat$aggregate_path)[0,1 ]]}while (@pth){my$cur=File::Spec->catdir(@pth);last if!$cur;if ($force){_bail_if_changed($cur,$fs_check{$cur}->[0],$fs_check{$cur}->[1]);if (!pathempty($cur)){return unless$nofail}}_bail_if_changed($cur,$fs_check{$cur}->[0],$fs_check{$cur}->[1]);if ($nofail){rmdir$cur}else {rmdir$cur or return}pop@pth}return 1}sub pathrmdir {my$dir=shift;if (-e $dir){return if!-d $dir}else {return 2}my ($orig_dev,$orig_ino)=(lstat$dir)[0,1 ];return 2 if!defined($orig_dev)|| ($^O ne 'MSWin32' &&!$orig_ino);pathempty($dir)or return;_bail_if_changed($dir,$orig_dev,$orig_ino);rmdir$dir or return;return 1}sub _bail_if_changed {my ($path,$orig_dev,$orig_ino)=@_;my ($cur_dev,$cur_ino)=(lstat$path)[0,1 ];if (!defined$cur_dev ||!defined$cur_ino){$cur_dev ||= "undef(path went away?)";$cur_ino ||= "undef(path went away?)"}else {$path=Cwd::abs_path($path)}if ($orig_dev ne $cur_dev || $orig_ino ne $cur_ino){local$Carp::CarpLevel += 1;Carp::croak("directory $path changed: expected dev=$orig_dev ino=$orig_ino, actual dev=$cur_dev ino=$cur_ino, aborting")}}1;
FILE_COPY_RECURSIVE

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use base qw(Exporter);use File::Spec ();our$VERSION='1.27';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_WIN=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_DOS=>IS_WIN();use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');our$IMPLICIT_CURRENT_DIR=IS_WIN || IS_VMS || IS_MAC;my@PATHEXT=('');if (IS_WIN){if ($ENV{PATHEXT}){push@PATHEXT,split /;/,$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_WIN and $exec =~ /\// and -f $exec and -x $exec;my@path;if($^O eq 'MSWin32'){@path=split /;/,$ENV{PATH};s/"//g for@path;@path=grep length,@path}else {@path=File::Spec->path}if ($IMPLICIT_CURRENT_DIR){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_WIN or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.016';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::pushd in void context');return}my ($target_dir,$options)=@_;$options->{untaint_pattern}||= qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {unless (defined wantarray){warnings::warnif(void=>'Useless use of File::pushd::tempd in void context');return}my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;$dir->{_owner}=$$;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& $self->{_owner}==$$ &&!$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"HTTP/Tinyish.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH';
  package HTTP::Tinyish;use strict;use warnings;use Carp ();our$VERSION='0.17';our$PreferredBackend;our@Backends=map "HTTP::Tinyish::$_",qw(LWP HTTPTiny Curl Wget);my%configured;sub new {my($class,%attr)=@_;bless \%attr,$class}for my$method (qw/get head put post delete mirror patch/){no strict 'refs';eval <<"HERE"}sub request {my$self=shift;$self->_backend_for($_[1])->request(@_)}sub _backend_for {my($self,$url)=@_;my($scheme)=$url =~ m!^(https?):!;Carp::croak "URL Scheme '$url' not supported." unless$scheme;for my$backend ($self->backends){$self->configure_backend($backend)or next;if ($backend->supports($scheme)){return$backend->new(%$self)}}Carp::croak "No backend configured for scheme $scheme"}sub backends {$PreferredBackend ? ($PreferredBackend): @Backends}sub configure_backend {my($self,$backend)=@_;unless (exists$configured{$backend}){$configured{$backend}=eval {require_module($backend);$backend->configure}}$configured{$backend}}sub require_module {local $_=shift;s!::!/!g;require "$_.pm"}1;
      sub $method {
          my \$self = shift;
          \$self->_backend_for(\$_[0])->$method(\@_);
      }
  HERE
HTTP_TINYISH

$fatpacked{"HTTP/Tinyish/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_BASE';
  package HTTP::Tinyish::Base;use strict;use warnings;for my$sub_name (qw/get head put post delete patch/){my$req_method=uc$sub_name;eval <<"HERE"}sub parse_http_header {my($self,$header,$res)=@_;$header =~ s/.*^(HTTP\/\d(?:\.\d)?)/$1/ms;if ($header =~ /^(.*?\x0d?\x0a\x0d?\x0a)/){$header=$1}my@header=split /\x0d?\x0a/,$header;my$status_line=shift@header;my@out;for (@header){if(/^[ \t]+/){return -1 unless@out;$out[-1].= $_}else {push@out,$_}}my($proto,$status,$reason)=split / /,$status_line,3;return unless$proto and $proto =~ /^HTTP\/(\d+)(\.(\d+))?$/i;$res->{status}=$status;$res->{reason}=$reason;$res->{success}=$status =~ /^(?:2|304)/;$res->{protocol}=$proto;my$token=qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;my$k;for my$header (@out){if ($header =~ s/^($token): ?//){$k=lc $1}elsif ($header =~ /^\s+/){}else {return -1}if (exists$res->{headers}{$k}){$res->{headers}{$k}=[$res->{headers}{$k}]unless ref$res->{headers}{$k};push @{$res->{headers}{$k}},$header}else {$res->{headers}{$k}=$header}}}sub internal_error {my($self,$url,$message)=@_;return {content=>$message,headers=>{"content-length"=>length($message),"content-type"=>"text/plain" },reason=>"Internal Exception",status=>599,success=>"",url=>$url,}}1;
      sub $sub_name {
          my (\$self, \$url, \$args) = \@_;
          \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
          or Carp::croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
          return \$self->request('$req_method', \$url, \$args || {});
      }
  
  HERE
HTTP_TINYISH_BASE

$fatpacked{"HTTP/Tinyish/Curl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_CURL';
  package HTTP::Tinyish::Curl;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);use File::Temp ();my%supports;my$curl;sub _slurp {open my$fh,"<",shift or die $!;local $/;<$fh>}sub configure {my$class=shift;my%meta;$curl=which('curl');eval {run3([$curl,'--version'],\undef,\my$version,\my$error);if ($version =~ /^Protocols: (.*)/m){my%protocols=map {$_=>1}split /\s/,$1;$supports{http}=1 if$protocols{http};$supports{https}=1 if$protocols{https}}$meta{$curl}=$version};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,'-X',$method,($method eq 'HEAD' ? ('--head'): ()),$self->build_options($url,$opts),'--dump-header',$temp,$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my(undef,$temp)=File::Temp::tempfile(UNLINK=>1);my($output,$error);eval {run3 [$curl,$self->build_options($url,$opts),'-z',$file,'-o',$file,'--dump-header',$temp,'--remote-time',$url,],\undef,\$output,\$error};if ($@ or $?){return$self->internal_error($url,$@ || $error)}my$res={url=>$url,content=>$output };$self->parse_http_header(_slurp($temp),$res);$res}sub build_options {my($self,$url,$opts)=@_;my@options=('--location','--silent','--show-error','--max-time',($self->{timeout}|| 60),'--max-redirs',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);unless ($self->{verify_SSL}){push@options,'--insecure'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}push@options,'--data',$content}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,map {('-H',"$field:$_")}@$value}else {push @$options,'-H',"$field:$value"}}}1;
HTTP_TINYISH_CURL

$fatpacked{"HTTP/Tinyish/HTTPTiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_HTTPTINY';
  package HTTP::Tinyish::HTTPTiny;use strict;use parent qw(HTTP::Tinyish::Base);use HTTP::Tiny;my%supports=(http=>1);sub configure {my%meta=("HTTP::Tiny"=>$HTTP::Tiny::VERSION);$supports{https}=HTTP::Tiny->can_ssl;\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attrs)=@_;bless {tiny=>HTTP::Tiny->new(%attrs),},$class}sub request {my$self=shift;$self->{tiny}->request(@_)}sub mirror {my$self=shift;$self->{tiny}->mirror(@_)}1;
HTTP_TINYISH_HTTPTINY

$fatpacked{"HTTP/Tinyish/LWP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_LWP';
  package HTTP::Tinyish::LWP;use strict;use parent qw(HTTP::Tinyish::Base);use LWP 5.802;use LWP::UserAgent;my%supports=(http=>1);sub configure {my%meta=(LWP=>$LWP::VERSION,);if (eval {require LWP::Protocol::https;require Mozilla::CA;1}){$supports{https}=1;$meta{"LWP::Protocol::https"}=$LWP::Protocol::https::VERSION}\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;my$ua=LWP::UserAgent->new;bless {ua=>$class->translate_lwp($ua,%attr),},$class}sub _headers_to_hashref {my($self,$hdrs)=@_;my%headers;for my$field ($hdrs->header_field_names){$headers{lc$field}=$hdrs->header($field)}\%headers}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my$req=HTTP::Request->new($method=>$url);if ($opts->{headers}){$req->header(%{$opts->{headers}})}if ($opts->{content}){$req->content($opts->{content})}my$res=$self->{ua}->request($req);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content(charset=>'none'),success=>$res->is_success,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub mirror {my($self,$url,$file)=@_;my$res=$self->{ua}->mirror($url,$file);if ($self->is_internal_response($res)){return$self->internal_error($url,$res->content)}return {url=>$url,content=>$res->decoded_content,success=>$res->is_success || $res->code==304,status=>$res->code,reason=>$res->message,headers=>$self->_headers_to_hashref($res->headers),protocol=>$res->protocol,}}sub translate_lwp {my($class,$agent,%attr)=@_;$agent->parse_head(0);$agent->env_proxy;$agent->timeout(delete$attr{timeout}|| 60);$agent->max_redirect(delete$attr{max_redirect}|| 5);$agent->agent(delete$attr{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION");unless ($attr{verify_SSL}){if ($agent->can("ssl_opts")){$agent->ssl_opts(verify_hostname=>0)}}if ($attr{default_headers}){$agent->default_headers(HTTP::Headers->new(%{$attr{default_headers}}))}$agent}sub is_internal_response {my($self,$res)=@_;$res->code==500 && ($res->header('Client-Warning')|| '')eq 'Internal response'}1;
HTTP_TINYISH_LWP

$fatpacked{"HTTP/Tinyish/Wget.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'HTTP_TINYISH_WGET';
  package HTTP::Tinyish::Wget;use strict;use warnings;use parent qw(HTTP::Tinyish::Base);use IPC::Run3 qw(run3);use File::Which qw(which);my%supports;my$wget;my$method_supported;sub _run_wget {run3([$wget,@_],\undef,\my$out,\my$err);wantarray ? ($out,$err): $out}sub configure {my$class=shift;my%meta;$wget=which('wget');eval {local$ENV{LC_ALL}='en_US';$meta{$wget}=_run_wget('--version');unless ($meta{$wget}=~ /GNU Wget 1\.(\d+)/ and $1 >= 12){die "Wget version is too old. $meta{$wget}"}my$config=$class->new(agent=>__PACKAGE__);my@options=grep {$_ ne '--quiet'}$config->build_options("GET");my(undef,$err)=_run_wget(@options,'https://');if ($err && $err =~ /HTTPS support not compiled/){$supports{http}=1}elsif ($err && $err =~ /Invalid host/){$supports{http}=$supports{https}=1}(undef,$err)=_run_wget('--method','GET','http://');if ($err && $err =~ /Invalid host/){$method_supported=$meta{method_supported}=1}};\%meta}sub supports {$supports{$_[1]}}sub new {my($class,%attr)=@_;bless \%attr,$class}sub request {my($self,$method,$url,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options($method,$url,$opts),$url,'-O','-',],\undef,\$stdout,\$stderr};if ($@ or $? && ($? >> 8)<= 5){return$self->internal_error($url,$@ || $stderr)}my$header='';$stderr =~ s{^  (\S.*)$}{ $header .= $1."\n" }gem;my$res={url=>$url,content=>$stdout };$self->parse_http_header($header,$res);$res}sub mirror {my($self,$url,$file,$opts)=@_;$opts ||= {};my($stdout,$stderr);eval {run3 [$wget,$self->build_options("GET",$url,$opts),$url,'-O',$file],\undef,\$stdout,\$stderr};if ($@ or $?){return$self->internal_error($url,$@ || $stderr)}$stderr =~ s/^  //gm;my$res={url=>$url,content=>$stdout };$self->parse_http_header($stderr,$res);$res}sub build_options {my($self,$method,$url,$opts)=@_;my@options=('--retry-connrefused','--server-response','--timeout',($self->{timeout}|| 60),'--tries',1,'--max-redirect',($self->{max_redirect}|| 5),'--user-agent',($self->{agent}|| "HTTP-Tinyish/$HTTP::Tinyish::VERSION"),);if ($method_supported){push@options,"--method",$method}else {if ($method eq 'GET' or $method eq 'POST'){}elsif ($method eq 'HEAD'){push@options,'--spider'}else {die "This version of wget doesn't support specifying HTTP method '$method'"}}if ($self->{agent}){push@options,'--user-agent',$self->{agent}}my%headers;if ($self->{default_headers}){%headers=%{$self->{default_headers}}}if ($opts->{headers}){%headers=(%headers,%{$opts->{headers}})}$self->_translate_headers(\%headers,\@options);if ($supports{https}&&!$self->{verify_SSL}){push@options,'--no-check-certificate'}if ($opts->{content}){my$content;if (ref$opts->{content}eq 'CODE'){while (my$chunk=$opts->{content}->()){$content .= $chunk}}else {$content=$opts->{content}}if ($method_supported){push@options,'--body-data',$content}else {push@options,'--post-data',$content}}@options}sub _translate_headers {my($self,$headers,$options)=@_;for my$field (keys %$headers){my$value=$headers->{$field};if (ref$value eq 'ARRAY'){push @$options,'--header',"$field:" .join(",",@$value)}else {push @$options,'--header',"$field:$value"}}}1;
HTTP_TINYISH_WGET

$fatpacked{"IPC/Run3.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3';
  package IPC::Run3;BEGIN {require 5.006_000}use strict;our$VERSION='0.048';use Exporter;our@ISA=qw(Exporter);our@EXPORT=qw(run3);our%EXPORT_TAGS=(all=>\@EXPORT);use constant debugging=>$ENV{IPCRUN3DEBUG}|| $ENV{IPCRUNDEBUG}|| 0;use constant profiling=>$ENV{IPCRUN3PROFILE}|| $ENV{IPCRUNPROFILE}|| 0;use constant is_win32=>0 <= index $^O,"Win32";BEGIN {if (is_win32){eval "use Win32 qw( GetOSName ); use Win32::ShellQuote qw(quote_native); 1" or die $@}}use Carp qw(croak);use File::Temp qw(tempfile);use POSIX qw(dup dup2);my%fh_cache;my$fh_cache_pid=$$;my$profiler;sub _profiler {$profiler}BEGIN {if (profiling){eval "use Time::HiRes qw( gettimeofday ); 1" or die $@;if ($ENV{IPCRUN3PROFILE}=~ /\A\d+\z/){require IPC::Run3::ProfPP;IPC::Run3::ProfPP->import;$profiler=IPC::Run3::ProfPP->new(Level=>$ENV{IPCRUN3PROFILE})}else {my ($dest,undef,$class)=reverse split /(=)/,$ENV{IPCRUN3PROFILE},2;$class="IPC::Run3::ProfLogger" unless defined$class && length$class;if (not eval "require $class"){my$e=$@;$class="IPC::Run3::$class";eval "require IPC::Run3::$class" or die$e}$profiler=$class->new(Destination=>$dest)}$profiler->app_call([$0,@ARGV ],scalar gettimeofday())}}END {$profiler->app_exit(scalar gettimeofday())if profiling}sub _binmode {my ($fh,$mode,$what)=@_;my$layer=!$mode ? (is_win32 ? ":crlf" : ":raw"): ($mode =~ /^:/ ? $mode : ":raw");warn "binmode $what, $layer\n" if debugging >= 2;binmode$fh,":raw" unless$layer eq ":raw";binmode$fh,$layer or croak "binmode $layer failed: $!"}sub _spool_data_to_child {my ($type,$source,$binmode_it)=@_;return undef unless defined$source;my$fh;if (!$type){open$fh,"<",$source or croak "$!: $source";_binmode($fh,$binmode_it,"STDIN");warn "run3(): feeding file '$source' to child STDIN\n" if debugging >= 2}elsif ($type eq "FH"){$fh=$source;warn "run3(): feeding filehandle '$source' to child STDIN\n" if debugging >= 2}else {$fh=$fh_cache{in}||= tempfile;truncate$fh,0;seek$fh,0,0;_binmode($fh,$binmode_it,"STDIN");my$seekit;if ($type eq "SCALAR"){return$fh unless defined $$source;warn "run3(): feeding SCALAR to child STDIN",debugging >= 3 ? (": '",$$source,"' (",length $$source," chars)"): (),"\n" if debugging >= 2;$seekit=length $$source;print$fh $$source or die "$! writing to temp file"}elsif ($type eq "ARRAY"){warn "run3(): feeding ARRAY to child STDIN",debugging >= 3 ? (": '",@$source,"'"): (),"\n" if debugging >= 2;print$fh @$source or die "$! writing to temp file";$seekit=grep length,@$source}elsif ($type eq "CODE"){warn "run3(): feeding output of CODE ref '$source' to child STDIN\n" if debugging >= 2;my$parms=[];while (1){my$data=$source->(@$parms);last unless defined$data;print$fh $data or die "$! writing to temp file";$seekit=length$data}}seek$fh,0,0 or croak "$! seeking on temp file for child's stdin" if$seekit}croak "run3() can't redirect $type to child stdin" unless defined$fh;return$fh}sub _fh_for_child_output {my ($what,$type,$dest,$options)=@_;my$fh;if ($type eq "SCALAR" && $dest==\undef){warn "run3(): redirecting child $what to oblivion\n" if debugging >= 2;$fh=$fh_cache{nul}||= do {open$fh,">",File::Spec->devnull;$fh}}elsif ($type eq "FH"){$fh=$dest;warn "run3(): redirecting $what to filehandle '$dest'\n" if debugging >= 3}elsif (!$type){warn "run3(): feeding child $what to file '$dest'\n" if debugging >= 2;open$fh,$options->{"append_$what"}? ">>" : ">",$dest or croak "$!: $dest"}else {warn "run3(): capturing child $what\n" if debugging >= 2;$fh=$fh_cache{$what}||= tempfile;seek$fh,0,0;truncate$fh,0}my$binmode_it=$options->{"binmode_$what"};_binmode($fh,$binmode_it,uc$what);return$fh}sub _read_child_output_fh {my ($what,$type,$dest,$fh,$options)=@_;return if$type eq "SCALAR" && $dest==\undef;seek$fh,0,0 or croak "$! seeking on temp file for child $what";if ($type eq "SCALAR"){warn "run3(): reading child $what to SCALAR\n" if debugging >= 3;my$count=read$fh,$$dest,10_000,$options->{"append_$what"}? length $$dest : 0;while (1){croak "$! reading child $what from temp file" unless defined$count;last unless$count;warn "run3(): read $count bytes from child $what",debugging >= 3 ? (": '",substr($$dest,-$count),"'"): (),"\n" if debugging >= 2;$count=read$fh,$$dest,10_000,length $$dest}}elsif ($type eq "ARRAY"){if ($options->{"append_$what"}){push @$dest,<$fh>}else {@$dest=<$fh>}if (debugging >= 2){my$count=0;$count += length for @$dest;warn "run3(): read ",scalar @$dest," records, $count bytes from child $what",debugging >= 3 ? (": '",@$dest,"'"): (),"\n"}}elsif ($type eq "CODE"){warn "run3(): capturing child $what to CODE ref\n" if debugging >= 3;local $_;while (<$fh>){warn "run3(): read ",length," bytes from child $what",debugging >= 3 ? (": '",$_,"'"): (),"\n" if debugging >= 2;$dest->($_)}}else {croak "run3() can't redirect child $what to a $type"}}sub _type {my ($redir)=@_;return "FH" if eval {local$SIG{'__DIE__'};$redir->isa("IO::Handle")};my$type=ref$redir;return$type eq "GLOB" ? "FH" : $type}sub _max_fd {my$fd=dup(0);POSIX::close$fd;return$fd}my$run_call_time;my$sys_call_time;my$sys_exit_time;sub run3 {$run_call_time=gettimeofday()if profiling;my$options=@_ && ref $_[-1]eq "HASH" ? pop : {};my ($cmd,$stdin,$stdout,$stderr)=@_;print STDERR "run3(): running ",join(" ",map "'$_'",ref$cmd ? @$cmd : $cmd),"\n" if debugging;if (ref$cmd){croak "run3(): empty command" unless @$cmd;croak "run3(): undefined command" unless defined$cmd->[0];croak "run3(): command name ('')" unless length$cmd->[0]}else {croak "run3(): missing command" unless @_;croak "run3(): undefined command" unless defined$cmd;croak "run3(): command ('')" unless length$cmd}for (qw/binmode_stdin binmode_stdout binmode_stderr/){if (my$mode=$options->{$_}){croak qq[option $_ must be a number or a proper layer string: "$mode"] unless$mode =~ /^(:|\d+$)/}}my$in_type=_type$stdin;my$out_type=_type$stdout;my$err_type=_type$stderr;if ($fh_cache_pid!=$$){close $_ foreach values%fh_cache;%fh_cache=();$fh_cache_pid=$$}my$in_fh=_spool_data_to_child$in_type,$stdin,$options->{binmode_stdin}if defined$stdin;my$out_fh=_fh_for_child_output "stdout",$out_type,$stdout,$options if defined$stdout;my$tie_err_to_out=defined$stderr && defined$stdout && $stderr eq $stdout;my$err_fh=$tie_err_to_out ? $out_fh : _fh_for_child_output "stderr",$err_type,$stderr,$options if defined$stderr;local*STDOUT_SAVE;local*STDERR_SAVE;my$saved_fd0=dup(0)if defined$in_fh;open STDOUT_SAVE,">&STDOUT" or croak "run3(): $! saving STDOUT" if defined$out_fh;open STDERR_SAVE,">&STDERR" or croak "run3(): $! saving STDERR" if defined$err_fh;my$errno;my$ok=eval {dup2(fileno$in_fh,0)or croak "run3(): $! redirecting STDIN" if defined$in_fh;open STDOUT,">&" .fileno$out_fh or croak "run3(): $! redirecting STDOUT" if defined$out_fh;open STDERR,">&" .fileno$err_fh or croak "run3(): $! redirecting STDERR" if defined$err_fh;$sys_call_time=gettimeofday()if profiling;my$r=ref$cmd ? system {$cmd->[0]}is_win32 ? quote_native(@$cmd): @$cmd : system$cmd;$errno=$!;$sys_exit_time=gettimeofday()if profiling;if (debugging){my$err_fh=defined$err_fh ? \*STDERR_SAVE : \*STDERR;if (defined$r && $r!=-1){print$err_fh "run3(): \$? is $?\n"}else {print$err_fh "run3(): \$? is $?, \$! is $errno\n"}}if (defined$r && ($r==-1 || (is_win32 && $r==0xFF00))&&!$options->{return_if_system_error}){croak($errno)}1};my$x=$@;my@errs;if (defined$saved_fd0){dup2($saved_fd0,0);POSIX::close($saved_fd0)}open STDOUT,">&STDOUT_SAVE" or push@errs,"run3(): $! restoring STDOUT" if defined$out_fh;open STDERR,">&STDERR_SAVE" or push@errs,"run3(): $! restoring STDERR" if defined$err_fh;croak join ", ",@errs if@errs;die$x unless$ok;_read_child_output_fh "stdout",$out_type,$stdout,$out_fh,$options if defined$out_fh && $out_type && $out_type ne "FH";_read_child_output_fh "stderr",$err_type,$stderr,$err_fh,$options if defined$err_fh && $err_type && $err_type ne "FH" &&!$tie_err_to_out;$profiler->run_exit($cmd,$run_call_time,$sys_call_time,$sys_exit_time,scalar gettimeofday())if profiling;$!=$errno;return 1}1;
IPC_RUN3

$fatpacked{"IPC/Run3/ProfArrayBuffer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFARRAYBUFFER';
  package IPC::Run3::ProfArrayBuffer;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Events}=[];return$self}for my$subname (qw(app_call app_exit run_exit)){no strict 'refs';*{$subname}=sub {push @{shift->{Events}},[$subname=>@_ ]}}sub get_events {my$self=shift;@{$self->{Events}}}1;
IPC_RUN3_PROFARRAYBUFFER

$fatpacked{"IPC/Run3/ProfLogReader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGREADER';
  package IPC::Run3::ProfLogReader;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Source}="run3.out" unless defined$self->{Source}&& length$self->{Source};my$source=$self->{Source};if (ref$source eq "GLOB" || UNIVERSAL::isa($source,"IO::Handle")){$self->{FH}=$source}elsif ($source eq "-"){$self->{FH}=\*STDIN}else {open PROFILE,"<$self->{Source}" or die "$!: $self->{Source}\n";$self->{FH}=*PROFILE{IO}}return$self}sub set_handler {$_[0]->{Handler}=$_[1]}sub get_handler {$_[0]->{Handler}}sub read {my$self=shift;my$fh=$self->{FH};my@ln=split / /,<$fh>;return 0 unless@ln;return 1 unless$self->{Handler};chomp$ln[-1];return 1 if@ln==1 &&!length$ln[0]|| 0==index$ln[0],"#";if ($ln[0]eq "\\app_call"){shift@ln;my@times=split /,/,pop@ln;$self->{Handler}->app_call([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}elsif ($ln[0]eq "\\app_exit"){shift@ln;$self->{Handler}->app_exit(pop@ln,@ln)}else {my@times=split /,/,pop@ln;$self->{Handler}->run_exit([map {s/\\\\/\\/g;s/\\_/ /g;$_}@ln ],@times)}return 1}sub read_all {my$self=shift;1 while$self->read;return 1}1;
IPC_RUN3_PROFLOGREADER

$fatpacked{"IPC/Run3/ProfLogger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFLOGGER';
  package IPC::Run3::ProfLogger;$VERSION=0.048;use strict;sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{Destination}="run3.out" unless defined$self->{Destination}&& length$self->{Destination};open PROFILE,">$self->{Destination}" or die "$!: $self->{Destination}\n";binmode PROFILE;$self->{FH}=*PROFILE{IO};$self->{times}=[];return$self}sub run_exit {my$self=shift;my$fh=$self->{FH};print($fh join(" ",(map {my$s=$_;$s =~ s/\\/\\\\/g;$s =~ s/ /_/g;$s}@{shift()}),join(",",@{$self->{times}},@_,),),"\n")}sub app_exit {my$self=shift;my$fh=$self->{FH};print$fh "\\app_exit ",shift,"\n"}sub app_call {my$self=shift;my$fh=$self->{FH};my$t=shift;print($fh join(" ","\\app_call",(map {my$s=$_;$s =~ s/\\\\/\\/g;$s =~ s/ /\\_/g;$s}@_),$t,),"\n")}1;
IPC_RUN3_PROFLOGGER

$fatpacked{"IPC/Run3/ProfPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFPP';
  package IPC::Run3::ProfPP;$VERSION=0.048;require IPC::Run3::ProfReporter;@ISA=qw(IPC::Run3::ProfReporter);use strict;use POSIX qw(floor);sub _emit {shift;warn @_}sub _t {sprintf "%10.6f secs",@_}sub _r {my ($num,$denom)=@_;return ()unless$denom;sprintf "%10.6f",$num / $denom}sub _pct {my ($num,$denom)=@_;return ()unless$denom;sprintf " (%3d%%)",floor(100 * $num / $denom + 0.5)}sub handle_app_call {my$self=shift;$self->_emit("IPC::Run3 parent: ",join(" ",@{$self->get_app_cmd}),"\n",);$self->{NeedNL}=1}sub handle_app_exit {my$self=shift;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=1;$self->_emit("IPC::Run3 total elapsed:             ",_t($self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 calls to run3():    ",sprintf("%10d",$self->get_run_count),"\n");$self->_emit("IPC::Run3 total spent in run3():     ",_t($self->get_run_cumulative_time),_pct($self->get_run_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_run_cumulative_time,$self->get_run_count)," per call","\n");my$exclusive=$self->get_app_cumulative_time - $self->get_run_cumulative_time;$self->_emit("IPC::Run3 total spent not in run3(): ",_t($exclusive),_pct($exclusive,$self->get_app_cumulative_time),"\n");$self->_emit("IPC::Run3 total spent in children:   ",_t($self->get_sys_cumulative_time),_pct($self->get_sys_cumulative_time,$self->get_app_cumulative_time),", ",_r($self->get_sys_cumulative_time,$self->get_run_count)," per call","\n");my$overhead=$self->get_run_cumulative_time - $self->get_sys_cumulative_time;$self->_emit("IPC::Run3 total overhead:            ",_t($overhead),_pct($overhead,$self->get_sys_cumulative_time),", ",_r($overhead,$self->get_run_count)," per call","\n")}sub handle_run_exit {my$self=shift;my$overhead=$self->get_run_time - $self->get_sys_time;$self->_emit("\n")if$self->{NeedNL}&& $self->{NeedNL}!=2;$self->{NeedNL}=3;$self->_emit("IPC::Run3 child: ",join(" ",@{$self->get_run_cmd}),"\n");$self->_emit("IPC::Run3 run3()  : ",_t($self->get_run_time),"\n","IPC::Run3 child   : ",_t($self->get_sys_time),"\n","IPC::Run3 overhead: ",_t($overhead),_pct($overhead,$self->get_sys_time),"\n")}1;
IPC_RUN3_PROFPP

$fatpacked{"IPC/Run3/ProfReporter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN3_PROFREPORTER';
  package IPC::Run3::ProfReporter;$VERSION=0.048;use strict;my$loaded_by;sub import {$loaded_by=shift}END {my@caller;for (my$i=0;;++$i ){my@c=caller$i;last unless@c;@caller=@c}if ($caller[0]eq "main" && $caller[1]eq "-e"){require IPC::Run3::ProfLogReader;require Getopt::Long;my ($app,$run);Getopt::Long::GetOptions("app"=>\$app,"run"=>\$run,);$app=1,$run=1 unless$app || $run;for (@ARGV ? @ARGV : ""){my$r=IPC::Run3::ProfLogReader->new(Source=>$_,Handler=>$loaded_by->new(Source=>$_,app_report=>$app,run_report=>$run,),);$r->read_all}}}sub new {my$class=ref $_[0]? ref shift : shift;my$self=bless {@_ },$class;$self->{app_report}=1,$self->{run_report}=1 unless$self->{app_report}|| $self->{run_report};return$self}sub handle_app_call {}sub handle_app_exit {}sub handle_run_exit {}sub app_call {my$self=shift;($self->{app_cmd},$self->{app_call_time})=@_;$self->handle_app_call if$self->{app_report}}sub app_exit {my$self=shift;$self->{app_exit_time}=shift;$self->handle_app_exit if$self->{app_report}}sub run_exit {my$self=shift;@{$self}{qw(run_cmd run_call_time sys_call_time sys_exit_time run_exit_time)}=@_;++$self->{run_count};$self->{run_cumulative_time}+= $self->get_run_time;$self->{sys_cumulative_time}+= $self->get_sys_time;$self->handle_run_exit if$self->{run_report}}sub get_run_count {shift->{run_count}}sub get_app_call_time {shift->{app_call_time}}sub get_app_exit_time {shift->{app_exit_time}}sub get_app_cmd {shift->{app_cmd}}sub get_app_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_app_cumulative_time {my$self=shift;$self->get_app_exit_time - $self->get_app_call_time}sub get_run_call_time {shift->{run_call_time}}sub get_run_exit_time {shift->{run_exit_time}}sub get_run_time {my$self=shift;$self->get_run_exit_time - $self->get_run_call_time}sub get_run_cumulative_time {shift->{run_cumulative_time}}sub get_sys_call_time {shift->{sys_call_time}}sub get_sys_exit_time {shift->{sys_exit_time}}sub get_sys_time {my$self=shift;$self->get_sys_exit_time - $self->get_sys_call_time}sub get_sys_cumulative_time {shift->{sys_cumulative_time}}sub get_run_cmd {shift->{run_cmd}}1;
IPC_RUN3_PROFREPORTER

$fatpacked{"Importer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IMPORTER';
  package Importer;use strict;no strict 'refs';use warnings;no warnings 'once';our$VERSION='0.026';my%SIG_TO_SLOT=('&'=>'CODE','$'=>'SCALAR','%'=>'HASH','@'=>'ARRAY','*'=>'GLOB',);our%IMPORTED;my%NUMERIC=map +($_=>1),0 .. 9;sub IMPORTER_MENU() {return (export_ok=>[qw/optimal_import/],export_anon=>{import=>sub {my$from=shift;my@caller=caller(0);_version_check($from,\@caller,shift @_)if @_ && $NUMERIC{substr($_[0],0,1)};my$file=_mod_to_file($from);_load_file(\@caller,$file)unless$INC{$file};return if optimal_import($from,$caller[0],\@caller,@_);my$self=__PACKAGE__->new(from=>$from,caller=>\@caller,);$self->do_import($caller[0],@_)},},)}sub import {my$class=shift;my@caller=caller(0);_version_check($class,\@caller,shift @_)if @_ && $NUMERIC{substr($_[0],0,1)};return unless @_;my ($from,@args)=@_;my$file=_mod_to_file($from);_load_file(\@caller,$file)unless$INC{$file};return if optimal_import($from,$caller[0],\@caller,@args);my$self=$class->new(from=>$from,caller=>\@caller,);$self->do_import($caller[0],@args)}sub unimport {my$class=shift;my@caller=caller(0);my$self=$class->new(from=>$caller[0],caller=>\@caller,);$self->do_unimport(@_)}sub import_into {my$class=shift;my ($from,$into,@args)=@_;my@caller;if (ref($into)){@caller=@$into;$into=$caller[0]}elsif ($into =~ m/^\d+$/){@caller=caller($into + 1);$into=$caller[0]}else {@caller=caller(0)}my$file=_mod_to_file($from);_load_file(\@caller,$file)unless$INC{$file};return if optimal_import($from,$into,\@caller,@args);my$self=$class->new(from=>$from,caller=>\@caller,);$self->do_import($into,@args)}sub unimport_from {my$class=shift;my ($from,@args)=@_;my@caller;if ($from =~ m/^\d+$/){@caller=caller($from + 1);$from=$caller[0]}else {@caller=caller(0)}my$self=$class->new(from=>$from,caller=>\@caller,);$self->do_unimport(@args)}sub new {my$class=shift;my%params=@_;my$caller=$params{caller}|| [caller()];die "You must specify a package to import from at $caller->[1] line $caller->[2].\n" unless$params{from};return bless {from=>$params{from},caller=>$params{caller},},$class}sub get {my$proto=shift;my@caller=caller(1);my$self=ref($proto)? $proto : $proto->new(from=>shift(@_),caller=>\@caller,);my%result;$self->do_import($caller[0],@_,sub {$result{$_[0]}=$_[1]});return \%result}sub get_list {my$proto=shift;my@caller=caller(1);my$self=ref($proto)? $proto : $proto->new(from=>shift(@_),caller=>\@caller,);my@result;$self->do_import($caller[0],@_,sub {push@result=>$_[1]});return@result}sub get_one {my$proto=shift;my@caller=caller(1);my$self=ref($proto)? $proto : $proto->new(from=>shift(@_),caller=>\@caller,);my$result;$self->do_import($caller[0],@_,sub {$result=$_[1]});return$result}sub do_import {my$self=shift;my ($into,$versions,$exclude,$import,$set)=$self->parse_args(@_);_version_check($self->from,$self->get_caller,@$versions)if @$versions;return unless @$import;$self->_handle_fail($into,$import)if$self->menu($into)->{fail};$self->_set_symbols($into,$exclude,$import,$set)}sub do_unimport {my$self=shift;my$from=$self->from;my$imported=$IMPORTED{$from}or $self->croak("'$from' does not have any imports to remove");my%allowed=map {$_=>1}@$imported;my@args=@_ ? @_ : @$imported;my$stash=\%{"$from\::"};for my$name (@args){$name =~ s/^&//;$self->croak("Sub '$name' was not imported using " .ref($self))unless$allowed{$name};my$glob=delete$stash->{$name};local*GLOBCLONE=*$glob;for my$type (qw/SCALAR HASH ARRAY FORMAT IO/){next unless defined(*{$glob}{$type});*{"$from\::$name"}=*{$glob}{$type}}}}sub from {$_[0]->{from}}sub from_file {my$self=shift;$self->{from_file}||= _mod_to_file($self->{from});return$self->{from_file}}sub load_from {my$self=shift;my$from_file=$self->from_file;my$this_file=__FILE__;return if$INC{$from_file};my$caller=$self->get_caller;_load_file($caller,$from_file)}sub get_caller {my$self=shift;return$self->{caller}if$self->{caller};my$level=1;while(my@caller=caller($level++)){return \@caller if@caller &&!$caller[0]->isa(__PACKAGE__);last unless@caller}return [caller(0)]}sub croak {my$self=shift;my ($msg)=@_;my$caller=$self->get_caller;my$file=$caller->[1]|| 'unknown file';my$line=$caller->[2]|| 'unknown line';die "$msg at $file line $line.\n"}sub carp {my$self=shift;my ($msg)=@_;my$caller=$self->get_caller;my$file=$caller->[1]|| 'unknown file';my$line=$caller->[2]|| 'unknown line';warn "$msg at $file line $line.\n"}sub menu {my$self=shift;my ($into)=@_;$self->croak("menu() requires the name of the destination package")unless$into;my$for=$self->{menu_for};delete$self->{menu}if$for && $for ne $into;return$self->{menu}|| $self->reload_menu($into)}sub reload_menu {my$self=shift;my ($into)=@_;$self->croak("reload_menu() requires the name of the destination package")unless$into;my$from=$self->from;if (my$menu_sub=*{"$from\::IMPORTER_MENU"}{CODE}){my%got=$from->$menu_sub($into,$self->get_caller);$got{export}||= [];$got{export_ok}||= [];$got{export_tags}||= {};$got{export_fail}||= [];$got{export_anon}||= {};$got{export_magic}||= {};$self->croak("'$from' provides both 'generate' and 'export_gen' in its IMPORTER_MENU (They are exclusive, module must pick 1)")if$got{export_gen}&& $got{generate};$got{export_gen}||= {};$self->{menu}=$self->_build_menu($into=>\%got,1)}else {my%got;$got{export}=\@{"$from\::EXPORT"};$got{export_ok}=\@{"$from\::EXPORT_OK"};$got{export_tags}=\%{"$from\::EXPORT_TAGS"};$got{export_fail}=\@{"$from\::EXPORT_FAIL"};$got{export_gen}=\%{"$from\::EXPORT_GEN"};$got{export_anon}=\%{"$from\::EXPORT_ANON"};$got{export_magic}=\%{"$from\::EXPORT_MAGIC"};$self->{menu}=$self->_build_menu($into=>\%got,0)}$self->{menu_for}=$into;return$self->{menu}}sub _build_menu {my$self=shift;my ($into,$got,$new_style)=@_;my$from=$self->from;my$export=$got->{export}|| [];my$export_ok=$got->{export_ok}|| [];my$export_tags=$got->{export_tags}|| {};my$export_fail=$got->{export_fail}|| [];my$export_anon=$got->{export_anon}|| {};my$export_gen=$got->{export_gen}|| {};my$export_magic=$got->{export_magic}|| {};my$generate=$got->{generate};$generate ||= sub {my$symbol=shift;my ($sig,$name)=($symbol =~ m/^(\W?)(.*)$/);$sig ||= '&';my$do=$export_gen->{"${sig}${name}"};$do ||= $export_gen->{$name}if!$sig || $sig eq '&';return undef unless$do;$from->$do($into,$symbol)}if$export_gen && keys %$export_gen;my$lookup={};my$exports={};for my$sym (@$export,@$export_ok,keys %$export_gen,keys %$export_anon){my ($sig,$name)=($sym =~ m/^(\W?)(.*)$/);$sig ||= '&';$lookup->{"${sig}${name}"}=1;$lookup->{$name}=1 if$sig eq '&';next if$export_gen->{"${sig}${name}"};next if$sig eq '&' && $export_gen->{$name};next if$got->{generate}&& $generate->("${sig}${name}");my$fqn="$from\::$name";$exports->{"${sig}${name}"}=$export_anon->{$sym}|| ($sig eq '&' ? \&{$fqn}: $sig eq '$' ? \${$fqn}: $sig eq '@' ? \@{$fqn}: $sig eq '%' ? \%{$fqn}: $sig eq '*' ? \*{$fqn}: next)}my$f_import=$new_style || $from->can('import');$self->croak("'$from' does not provide any exports")unless$new_style || keys %$exports || $from->isa('Exporter')|| ($INC{'Exporter.pm'}&& $f_import && $f_import==\&Exporter::import);my$tags={%$export_tags,'DEFAULT'=>[@$export ],};$tags->{ALL}||= [sort grep {m/^[\&\$\@\%\*]/}keys %$lookup ];my$fail=@$export_fail ? {map {my ($sig,$name)=(m/^(\W?)(.*)$/);$sig ||= '&';("${sig}${name}"=>1,$sig eq '&' ? ($name=>1): ())}@$export_fail }: undef;my$menu={lookup=>$lookup,exports=>$exports,tags=>$tags,fail=>$fail,generate=>$generate,magic=>$export_magic,};return$menu}sub parse_args {my$self=shift;my ($into,@args)=@_;my$menu=$self->menu($into);my@out=$self->_parse_args($into,$menu,\@args);pop@out;return@out}sub _parse_args {my$self=shift;my ($into,$menu,$args,$is_tag)=@_;my$from=$self->from;my$main_menu=$self->menu($into);$menu ||= $main_menu;my@sets;my@versions;my@leftover;for my$arg (@$args){no warnings 'void';push@sets=>$arg and next if ref($arg)eq 'CODE';push@versions=>$arg xor next if$NUMERIC{substr($arg,0,1)};push@leftover=>$arg}$self->carp("Multiple setters specified, only 1 will be used")if@sets > 1;my$set=pop@sets;$args=\@leftover;@$args=(':DEFAULT')unless$is_tag || @$args || @versions;my%exclude;my@import;while(my$full_arg=shift @$args){my$arg=$full_arg;my$lead=substr($arg,0,1);my ($spec,$exc);if ($lead eq '!'){$exc=$lead;if ($arg eq '!'){$arg=shift @$args}else {substr($arg,0,1,'')}unshift @$args=>':DEFAULT' unless@import || keys%exclude || @versions;$lead=substr($arg,0,1)}else {$spec=ref($args->[0])eq 'HASH' ? shift @$args : {}}if($lead eq ':'){substr($arg,0,1,'');my$tag=$menu->{tags}->{$arg}or $self->croak("$from does not export the :$arg tag");my (undef,$cvers,$cexc,$cimp,$cset,$newmenu)=$self->_parse_args($into,$menu,$tag,$arg);$self->croak("Exporter specified version numbers (" .join(', ',@$cvers).") in the :$arg tag!")if @$cvers;$self->croak("Exporter specified a custom symbol setter in the :$arg tag!")if$cset;%exclude=(%exclude,%$cexc);if ($exc){$exclude{$_}=1 for grep {!ref($_)&& substr($_,0,1)ne '+'}map {$_->[0]}@$cimp}elsif ($spec && keys %$spec){$self->croak("Cannot use '-as' to rename multiple symbols included by: $full_arg")if$spec->{'-as'}&& @$cimp > 1;for my$set (@$cimp){my ($sym,$cspec)=@$set;my$nspec={%$cspec,%$spec};$nspec->{'-prefix'}="$spec->{'-prefix'}$cspec->{'-prefix'}" if$spec->{'-prefix'}&& $cspec->{'-prefix'};$nspec->{'-postfix'}="$cspec->{'-postfix'}$spec->{'-postfix'}" if$spec->{'-postfix'}&& $cspec->{'-postfix'};push@import=>[$sym,$nspec]}}else {push@import=>@$cimp}$menu=$newmenu;next}my@list;if(ref($arg)eq 'Regexp'){@list=sort grep /$arg/,keys %{$menu->{lookup}}}elsif($lead eq '/' && $arg =~ m{^/(.*)/$}){my$pattern=$1;@list=sort grep /$1/,keys %{$menu->{lookup}}}else {@list=($arg)}@list=map {m/^\W/ ? $_ : "\&$_"}@list;if ($exc){$exclude{$_}=1 for@list}else {$self->croak("Cannot use '-as' to rename multiple symbols included by: $full_arg")if$spec->{'-as'}&& @list > 1;push@import=>[$_,$spec]for@list}}return ($into,\@versions,\%exclude,\@import,$set,$menu)}sub _handle_fail {my$self=shift;my ($into,$import)=@_;my$from=$self->from;my$menu=$self->menu($into);my@fail=map {my$x=$_->[0];$x =~ s/^&//;$x}grep$menu->{fail}->{$_->[0]},@$import or return;my@real_fail=$from->can('export_fail')? $from->export_fail(@fail): @fail;if (@real_fail){$self->carp(qq["$_" is not implemented by the $from module on this architecture])for@real_fail;$self->croak("Can't continue after import errors")}$self->reload_menu($menu);return}sub _set_symbols {my$self=shift;my ($into,$exclude,$import,$custom_set)=@_;my$from=$self->from;my$menu=$self->menu($into);my$caller=$self->get_caller();my$set_symbol=$custom_set || eval <<"    EOT" || die $@;for my$set (@$import){my ($symbol,$spec)=@$set;my ($sig,$name)=($symbol =~ m/^(\W)(.*)$/)or die "Invalid symbol: $symbol";my$ref=$menu->{exports}->{$symbol};$ref ||= $menu->{generate}->($symbol)if$menu->{generate};$self->croak("$from does not export $symbol")unless$ref || $menu->{lookup}->{"${sig}${name}"};next unless$ref;my$type=ref($ref);$type='SCALAR' if$type eq 'REF';$self->croak("Symbol '$sig$name' requested, but reference (" .ref($ref).") does not match sigil ($sig)")if$ref && $type ne $SIG_TO_SLOT{$sig};next if$exclude->{"${sig}${name}"}&&!$spec->{'-as'};my$new_name=join ''=>($spec->{'-prefix'}|| '',$spec->{'-as'}|| $name,$spec->{'-postfix'}|| '');$set_symbol->($new_name,$ref,sig=>$sig,symbol=>$symbol,into=>$into,from=>$from,spec=>$spec);next if$custom_set;push @{$IMPORTED{$into}}=>$new_name if$sig eq '&';my$magic=$menu->{magic}->{$symbol};$magic ||= $menu->{magic}->{$name}if$sig eq '&';$from->$magic(into=>$into,orig_name=>$name,new_name=>$new_name,ref=>$ref)if$magic}}sub _version_check {my ($mod,$caller,@versions)=@_;eval <<"    EOT" or die $@}sub _mod_to_file {my$file=shift;$file =~ s{::}{/}g;$file .= '.pm';return$file}sub _load_file {my ($caller,$file)=@_;eval <<"    EOT" || die $@}my%HEAVY_VARS=(IMPORTER_MENU=>'CODE',EXPORT_FAIL=>'ARRAY',EXPORT_GEN=>'HASH',EXPORT_ANON=>'HASH',EXPORT_MAGIC=>'HASH',);sub optimal_import {my ($from,$into,$caller,@args)=@_;defined(*{"$from\::$_"}{$HEAVY_VARS{$_}})and return 0 for keys%HEAVY_VARS;@args=@{"$from\::EXPORT"}unless@args;my%allowed=map +(substr($_,0,1)eq '&' ? substr($_,1): $_=>1),@{"$from\::EXPORT"},@{"$from\::EXPORT_OK"};my%final=map +((!ref($_)&& ($allowed{$_}|| (substr($_,0,1,"")eq '&' && $allowed{$_})))? ($_=>*{"$from\::$_"}{CODE}|| return 0): return 0),@args;eval <<"    EOT" || die $@}1;
  # Inherit the callers warning settings. If they have warnings and we
  # redefine their subs they will hear about it. If they do not have warnings
  # on they will not.
  BEGIN { \${^WARNING_BITS} = \$caller->[9] if defined \$caller->[9] }
  #line $caller->[2] "$caller->[1]"
  sub { *{"$into\\::\$_[0]"} = \$_[1] }
      EOT
  #line $caller->[2] "$caller->[1]"
  \$mod->VERSION(\$_) for \@versions;
  1;
      EOT
  #line $caller->[2] "$caller->[1]"
  require \$file;
      EOT
  # If the caller has redefine warnings enabled then we want to warn them if
  # their import redefines things.
  BEGIN { \${^WARNING_BITS} = \$caller->[9] if defined \$caller->[9] };
  #line $caller->[2] "$caller->[1]"
  (*{"$into\\::\$_"} = \$final{\$_}, push \@{\$Importer::IMPORTED{\$into}} => \$_) for keys %final;
  1;
      EOT
IMPORTER

$fatpacked{"Menlo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO';
  package Menlo;our$VERSION="1.9019";1;
MENLO

$fatpacked{"Menlo/Builder/Static.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_BUILDER_STATIC';
  package Menlo::Builder::Static;use strict;use warnings;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/dirname/;use File::Find ();use File::Path qw/mkpath/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;sub new {my($class,%args)=@_;bless {meta=>$args{meta},},$class}sub meta {my$self=shift;$self->{meta}}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared },catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}1},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and return;1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/});1},);sub build {my$self=shift;my$action=@_ && $_[0]=~ /\A\w+\z/ ? shift @_ : 'build';die "No such action '$action'\n" if not $actions{$action};my%opt;GetOptionsFromArray([@$_],\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($self->{env},$self->{configure_args},\@_);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),$self->meta);$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub configure {my$self=shift;$self->{env}=defined$ENV{PERL_MB_OPT}? [split_like_shell($ENV{PERL_MB_OPT})]: [];$self->{configure_args}=[@_];$self->meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MENLO_BUILDER_STATIC

$fatpacked{"Menlo/CLI/Compat.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_CLI_COMPAT';
  package Menlo::CLI::Compat;use strict;use Config;use Cwd ();use Menlo;use Menlo::Dependency;use Menlo::Util qw(WIN32);use File::Basename ();use File::Find ();use File::Path ();use File::Spec ();use File::Copy ();use File::Temp ();use File::Which qw(which);use Getopt::Long ();use Symbol ();use version ();use constant BAD_TAR=>($^O eq 'solaris' || $^O eq 'hpux');use constant CAN_SYMLINK=>eval {symlink("","");1};our$VERSION='1.9022';if ($INC{"App/FatPacker/Trace.pm"}){require version::vpp}sub qs($) {Menlo::Util::shell_quote($_[0])}sub determine_home {my$class=shift;my$homedir=$ENV{HOME}|| eval {require File::HomeDir;File::HomeDir->my_home}|| join('',@ENV{qw(HOMEDRIVE HOMEPATH)});if (WIN32){require Win32;$homedir=Win32::GetShortPathName($homedir)}return "$homedir/.cpanm"}sub new {my$class=shift;my$self=bless {name=>"Menlo",home=>$class->determine_home,cmd=>'install',seen=>{},notest=>undef,test_only=>undef,installdeps=>undef,force=>undef,sudo=>undef,make=>undef,verbose=>undef,quiet=>undef,interactive=>undef,log=>undef,mirrors=>[],mirror_only=>undef,mirror_index=>undef,cpanmetadb=>"http://cpanmetadb.plackperl.org/v1.0/",perl=>$^X,argv=>[],local_lib=>undef,self_contained=>undef,exclude_vendor=>undef,prompt_timeout=>0,prompt=>undef,configure_timeout=>60,build_timeout=>3600,test_timeout=>1800,try_lwp=>1,try_wget=>1,try_curl=>1,uninstall_shadows=>($] < 5.012),skip_installed=>1,skip_satisfied=>0,static_install=>1,auto_cleanup=>7,pod2man=>1,installed_dists=>0,install_types=>['requires'],with_develop=>0,with_configure=>0,showdeps=>0,scandeps=>0,scandeps_tree=>[],format=>'tree',save_dists=>undef,skip_configure=>0,verify=>0,report_perl_version=>!$class->maybe_ci,build_args=>{},features=>{},pure_perl=>0,cpanfile_path=>'cpanfile',@_,},$class;$self}sub env {my($self,$key)=@_;$ENV{"PERL_CPANM_" .$key}}sub maybe_ci {my$class=shift;grep$ENV{$_},qw(TRAVIS CI AUTOMATED_TESTING AUTHOR_TESTING)}sub install_type_handlers {my$self=shift;my@handlers;for my$type (qw(recommends suggests)){push@handlers,"with-$type"=>sub {my%uniq;$self->{install_types}=[grep!$uniq{$_}++,@{$self->{install_types}},$type ]};push@handlers,"without-$type"=>sub {$self->{install_types}=[grep $_ ne $type,@{$self->{install_types}}]}}@handlers}sub build_args_handlers {my$self=shift;my@handlers;for my$phase (qw(configure build test install)){push@handlers,"$phase-args=s"=>\($self->{build_args}{$phase})}@handlers}sub parse_options {my$self=shift;local@ARGV=@{$self->{argv}};push@ARGV,grep length,split /\s+/,$self->env('OPT');push@ARGV,@_;Getopt::Long::Configure("bundling");Getopt::Long::GetOptions('f|force'=>sub {$self->{skip_installed}=0;$self->{force}=1},'n|notest!'=>\$self->{notest},'test-only'=>sub {$self->{notest}=0;$self->{skip_installed}=0;$self->{test_only}=1},'S|sudo!'=>\$self->{sudo},'v|verbose'=>\$self->{verbose},'verify!'=>\$self->{verify},'q|quiet!'=>\$self->{quiet},'h|help'=>sub {$self->{action}='show_help'},'V|version'=>sub {$self->{action}='show_version'},'perl=s'=>sub {$self->diag("--perl is deprecated since it's known to be fragile in figuring out dependencies. Run `$_[1] -S cpanm` instead.\n",1);$self->{perl}=$_[1]},'l|local-lib=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1])},'L|local-lib-contained=s'=>sub {$self->{local_lib}=$self->maybe_abs($_[1]);$self->{self_contained}=1;$self->{pod2man}=undef},'self-contained!'=>\$self->{self_contained},'exclude-vendor!'=>\$self->{exclude_vendor},'mirror=s@'=>$self->{mirrors},'mirror-only!'=>\$self->{mirror_only},'mirror-index=s'=>sub {$self->{mirror_index}=$self->maybe_abs($_[1])},'M|from=s'=>sub {$self->{mirrors}=[$_[1]];$self->{mirror_only}=1},'cpanmetadb=s'=>\$self->{cpanmetadb},'cascade-search!'=>\$self->{cascade_search},'prompt!'=>\$self->{prompt},'installdeps'=>\$self->{installdeps},'skip-installed!'=>\$self->{skip_installed},'skip-satisfied!'=>\$self->{skip_satisfied},'reinstall'=>sub {$self->{skip_installed}=0},'interactive!'=>\$self->{interactive},'i|install'=>sub {$self->{cmd}='install'},'info'=>sub {$self->{cmd}='info'},'look'=>sub {$self->{cmd}='look';$self->{skip_installed}=0},'U|uninstall'=>sub {$self->{cmd}='uninstall'},'self-upgrade'=>sub {$self->{action}='self_upgrade'},'uninst-shadows!'=>\$self->{uninstall_shadows},'lwp!'=>\$self->{try_lwp},'wget!'=>\$self->{try_wget},'curl!'=>\$self->{try_curl},'auto-cleanup=s'=>\$self->{auto_cleanup},'man-pages!'=>\$self->{pod2man},'scandeps'=>\$self->{scandeps},'showdeps'=>sub {$self->{showdeps}=1;$self->{skip_installed}=0},'format=s'=>\$self->{format},'save-dists=s'=>sub {$self->{save_dists}=$self->maybe_abs($_[1])},'skip-configure!'=>\$self->{skip_configure},'static-install!'=>\$self->{static_install},'dev!'=>\$self->{dev_release},'metacpan!'=>\$self->{metacpan},'report-perl-version!'=>\$self->{report_perl_version},'configure-timeout=i'=>\$self->{configure_timeout},'build-timeout=i'=>\$self->{build_timeout},'test-timeout=i'=>\$self->{test_timeout},'with-develop'=>\$self->{with_develop},'without-develop'=>sub {$self->{with_develop}=0},'with-configure'=>\$self->{with_configure},'without-configure'=>sub {$self->{with_configure}=0},'with-feature=s'=>sub {$self->{features}{$_[1]}=1},'without-feature=s'=>sub {$self->{features}{$_[1]}=0},'with-all-features'=>sub {$self->{features}{__all}=1},'pp|pureperl!'=>\$self->{pure_perl},"cpanfile=s"=>\$self->{cpanfile_path},$self->install_type_handlers,$self->build_args_handlers,);if (!@ARGV && $0 ne '-' &&!-t STDIN){push@ARGV,$self->load_argv_from_fh(\*STDIN);$self->{load_from_stdin}=1}$self->{argv}=\@ARGV}sub check_upgrade {my$self=shift;my$install_base=$ENV{PERL_LOCAL_LIB_ROOT}? $self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}): $Config{installsitebin};if ($0 eq '-'){return}elsif ($0 !~ /^$install_base/){if ($0 =~ m!perlbrew/bin!){die <<DIE}else {die <<DIE}}}sub check_libs {my$self=shift;return if$self->{_checked}++;$self->bootstrap_local_lib}sub setup_verify {my$self=shift;my$has_modules=eval {require Module::Signature;require Digest::SHA;1};$self->{cpansign}=which('cpansign');unless ($has_modules && $self->{cpansign}){warn "WARNING: Module::Signature and Digest::SHA is required for distribution verifications.\n";$self->{verify}=0}}sub parse_module_args {my($self,$module)=@_;$module =~ s/^([A-Za-z0-9_:]+)@([v\d\._]+)$/$1~== $2/;if ($module =~ /\~[v\d\._,\!<>= ]+$/){return split '~',$module,2}else {return$module,undef}}sub run {my$self=shift;my$code;eval {$code=($self->_doit==0)};if (my$e=$@){warn$e;$code=1}$self->{status}=$code}sub status {$_[0]->{status}}sub _doit {my$self=shift;$self->setup_home;$self->init_tools;$self->setup_verify if$self->{verify};if (my$action=$self->{action}){$self->$action()and return 1}return$self->show_help(1)unless @{$self->{argv}}or $self->{load_from_stdin};$self->configure_mirrors;my$cwd=Cwd::cwd;my@fail;for my$module (@{$self->{argv}}){if ($module =~ s/\.pm$//i){my ($volume,$dirs,$file)=File::Spec->splitpath($module);$module=join '::',grep {$_}File::Spec->splitdir($dirs),$file}($module,my$version)=$self->parse_module_args($module);$self->chdir($cwd);if ($self->{cmd}eq 'uninstall'){$self->uninstall_module($module)or push@fail,$module}else {$self->install_module($module,0,$version)or push@fail,$module}}if ($self->{base}&& $self->{auto_cleanup}){$self->cleanup_workdirs}if ($self->{installed_dists}){my$dists=$self->{installed_dists}> 1 ? "distributions" : "distribution";$self->diag("$self->{installed_dists} $dists installed\n",1)}if ($self->{scandeps}){$self->dump_scandeps()}$self->chdir($cwd);return!@fail}sub setup_home {my$self=shift;$self->{home}=$self->env('HOME')if$self->env('HOME');unless (_writable($self->{home})){die "Can't write to cpanm home '$self->{home}': You should fix it with chown/chmod first.\n"}$self->{base}="$self->{home}/work/" .time .".$$";File::Path::mkpath([$self->{base}],0,0777);$self->{log}=File::Spec->catfile($self->{base},"build.log");my$final_log="$self->{home}/build.log";{open my$out,">$self->{log}" or die "$self->{log}: $!"}if (CAN_SYMLINK){my$build_link="$self->{home}/latest-build";unlink$build_link;symlink$self->{base},$build_link;unlink$final_log;symlink$self->{log},$final_log}else {my$log=$self->{log};my$home=$self->{home};$self->{at_exit}=sub {my$self=shift;my$temp_log="$home/build.log." .time .".$$";File::Copy::copy($log,$temp_log)&& unlink($final_log);rename($temp_log,$final_log)}}$self->chat("cpanm ($self->{name}) $Menlo::VERSION on perl $] built for $Config{archname}\n" ."Work directory is $self->{base}\n")}sub search_mirror_index_local {my ($self,$local,$module,$version)=@_;require CPAN::Common::Index::LocalPackage;my$index=CPAN::Common::Index::LocalPackage->new({source=>$local });$self->search_common($index,{package=>$module },$version)}sub search_mirror_index {my ($self,$mirror,$module,$version)=@_;require Menlo::Index::Mirror;my$index=Menlo::Index::Mirror->new({mirror=>$mirror,cache=>$self->source_for($mirror),fetcher=>sub {$self->mirror(@_)},});$self->search_common($index,{package=>$module },$version)}sub search_common {my($self,$index,$search_args,$want_version)=@_;$index->refresh_index;my$found=$index->search_packages($search_args);$found=$self->cpan_module_common($found)if$found;return$found unless$self->{cascade_search};if ($found){if ($self->satisfy_version($found->{module},$found->{module_version},$want_version)){return$found}else {$self->chat("Found $found->{module} $found->{module_version} which doesn't satisfy $want_version.\n")}}return}sub with_version_range {my($self,$version)=@_;defined($version)&& $version =~ /(?:<|!=|==)/}sub search_metacpan {my($self,$module,$version,$dev_release)=@_;require Menlo::Index::MetaCPAN;$self->chat("Searching $module ($version) on metacpan ...\n");my$index=Menlo::Index::MetaCPAN->new({include_dev=>$self->{dev_release}});my$pkg=$self->search_common($index,{package=>$module,version_range=>$version },$version);return$pkg if$pkg;$self->diag_fail("Finding $module ($version) on metacpan failed.");return}sub search_database {my($self,$module,$version)=@_;my$found;if ($self->{dev_release}or $self->{metacpan}){$found=$self->search_metacpan($module,$version,$self->{dev_release})and return$found;$found=$self->search_cpanmetadb($module,$version,$self->{dev_release})and return$found}else {$found=$self->search_cpanmetadb($module,$version)and return$found;$found=$self->search_metacpan($module,$version)and return$found}}sub search_cpanmetadb {my($self,$module,$version,$dev_release)=@_;require Menlo::Index::MetaDB;$self->chat("Searching $module ($version) on cpanmetadb ...\n");my$args={package=>$module };if ($self->with_version_range($version)){$args->{version_range}=$version}my$index=Menlo::Index::MetaDB->new({uri=>$self->{cpanmetadb}});my$pkg=$self->search_common($index,$args,$version);return$pkg if$pkg;$self->diag_fail("Finding $module on cpanmetadb failed.");return}sub search_module {my($self,$module,$version)=@_;if ($self->{mirror_index}){$self->mask_output(chat=>"Searching $module on mirror index $self->{mirror_index} ...\n");my$pkg=$self->search_mirror_index_local($self->{mirror_index},$module,$version);return$pkg if$pkg;unless ($self->{cascade_search}){$self->mask_output(diag_fail=>"Finding $module ($version) on mirror index $self->{mirror_index} failed.");return}}unless ($self->{mirror_only}){my$found=$self->search_database($module,$version);return$found if$found}MIRROR: for my$mirror (@{$self->{mirrors}}){$self->mask_output(chat=>"Searching $module on mirror $mirror ...\n");my$pkg=$self->search_mirror_index($mirror,$module,$version);return$pkg if$pkg;$self->mask_output(diag_fail=>"Finding $module ($version) on mirror $mirror failed.")}return}sub source_for {my($self,$mirror)=@_;$mirror =~ s/[^\w\.\-]+/%/g;my$dir="$self->{home}/sources/$mirror";File::Path::mkpath([$dir ],0,0777);return$dir}sub load_argv_from_fh {my($self,$fh)=@_;my@argv;while(defined(my$line=<$fh>)){chomp$line;$line =~ s/#.+$//;$line =~ s/^\s+//;$line =~ s/\s+$//;push@argv,split ' ',$line if$line}return@argv}sub show_version {my$self=shift;print "cpanm ($self->{name}) version $VERSION ($0)\n";print "perl version $] ($^X)\n\n";print "  \%Config:\n";for my$key (qw(archname installsitelib installsitebin installman1dir installman3dir sitearchexp sitelibexp vendorarch vendorlibexp archlibexp privlibexp)){print "    $key=$Config{$key}\n" if$Config{$key}}print "  \%ENV:\n";for my$key (grep /^PERL/,sort keys%ENV){print "    $key=$ENV{$key}\n"}print "  \@INC:\n";for my$inc (@INC){print "    $inc\n" unless ref($inc)eq 'CODE'}return 1}sub show_help {my$self=shift;if ($_[0]){print <<USAGE;return}print <<HELP;return 1}sub _writable {my$dir=shift;my@dir=File::Spec->splitdir($dir);while (@dir){$dir=File::Spec->catdir(@dir);if (-e $dir){return -w _}pop@dir}return}sub maybe_abs {my($self,$lib)=@_;if ($lib eq '_' or $lib =~ /^~/ or File::Spec->file_name_is_absolute($lib)){return$lib}else {return File::Spec->canonpath(File::Spec->catdir(Cwd::cwd(),$lib))}}sub local_lib_target {my($self,$root)=@_;(grep {$_ ne ''}split /\Q$Config{path_sep}/,$root)[0]}sub bootstrap_local_lib {my$self=shift;if ($self->{local_lib}){return$self->setup_local_lib($self->{local_lib})}if ($ENV{PERL_LOCAL_LIB_ROOT}&& $ENV{PERL_MM_OPT}){return$self->setup_local_lib($self->local_lib_target($ENV{PERL_LOCAL_LIB_ROOT}),1)}return if$self->{sudo}or (_writable($Config{installsitelib})and _writable($Config{installsitebin}));if ($ENV{PERL_MM_OPT}and ($ENV{MODULEBUILDRC}or $ENV{PERL_MB_OPT})){return}$self->setup_local_lib;$self->diag(<<DIAG,1);sleep 2}sub upgrade_toolchain {my($self,$config_deps)=@_;my%deps=map {$_->module=>$_}@$config_deps;my$reqs=CPAN::Meta::Requirements->from_string_hash({'Module::Build'=>'0.38','ExtUtils::MakeMaker'=>'6.58','ExtUtils::Install'=>'1.46',});if ($deps{"ExtUtils::MakeMaker"}){$deps{"ExtUtils::MakeMaker"}->merge_with($reqs)}elsif ($deps{"Module::Build"}){$deps{"Module::Build"}->merge_with($reqs);$deps{"ExtUtils::Install"}||= Menlo::Dependency->new("ExtUtils::Install",0,'configure');$deps{"ExtUtils::Install"}->merge_with($reqs)}@$config_deps=values%deps}sub _core_only_inc {my($self,$base)=@_;require local::lib;(local::lib->resolve_path(local::lib->install_base_arch_path($base)),local::lib->resolve_path(local::lib->install_base_perl_path($base)),(!$self->{exclude_vendor}? grep {$_}@Config{qw(vendorarch vendorlibexp)}: ()),@Config{qw(archlibexp privlibexp)},)}sub _setup_local_lib_env {my($self,$base)=@_;$self->diag(<<WARN,1)if$base =~ /\s/;local$SIG{__WARN__}=sub {};local::lib->setup_env_hash_for($base,0)}sub setup_local_lib {my($self,$base,$no_env)=@_;$base=undef if$base eq '_';require local::lib;{local $0='cpanm';$base ||= "~/perl5";$base=local::lib->resolve_path($base);if ($self->{self_contained}){my@inc=$self->_core_only_inc($base);$self->{search_inc}=[@inc ]}else {$self->{search_inc}=[local::lib->install_base_arch_path($base),local::lib->install_base_perl_path($base),@INC,]}$self->_setup_local_lib_env($base)unless$no_env;$self->{local_lib}=$base}}sub prompt_bool {my($self,$mess,$def)=@_;my$val=$self->prompt($mess,$def);return lc$val eq 'y'}sub prompt {my($self,$mess,$def)=@_;my$isa_tty=-t STDIN && (-t STDOUT ||!(-f STDOUT || -c STDOUT));my$dispdef=defined$def ? "[$def] " : " ";$def=defined$def ? $def : "";if (!$self->{prompt}|| (!$isa_tty && eof STDIN)){return$def}local $|=1;local $\;my$ans;eval {local$SIG{ALRM}=sub {undef$ans;die "alarm\n"};print STDOUT "$mess $dispdef";alarm$self->{prompt_timeout}if$self->{prompt_timeout};$ans=<STDIN>;alarm 0};if (defined$ans){chomp$ans}else {print STDOUT "\n"}return (!defined$ans || $ans eq '')? $def : $ans}sub diag_ok {my($self,$msg)=@_;chomp$msg;$msg ||= "OK";if ($self->{in_progress}){$self->_diag("$msg\n");$self->{in_progress}=0}$self->log("-> $msg\n")}sub diag_fail {my($self,$msg,$always)=@_;chomp$msg;if ($self->{in_progress}){$self->_diag("FAIL\n");$self->{in_progress}=0}if ($msg){$self->_diag("! $msg\n",$always,1);$self->log("-> FAIL $msg\n")}}sub diag_progress {my($self,$msg)=@_;chomp$msg;$self->{in_progress}=1;$self->_diag("$msg ... ");$self->log("$msg\n")}sub _diag {my($self,$msg,$always,$error)=@_;my$fh=$error ? *STDERR : *STDOUT;print {$fh}$msg if$always or $self->{verbose}or!$self->{quiet}}sub diag {my($self,$msg,$always)=@_;$self->_diag($msg,$always);$self->log($msg)}sub chat {my$self=shift;print STDERR @_ if$self->{verbose};$self->log(@_)}sub mask_output {my$self=shift;my$method=shift;$self->$method($self->mask_uri_passwords(@_))}sub log {my$self=shift;open my$out,">>$self->{log}";print$out @_}sub run_command {my($self,$cmd)=@_;if (ref$cmd eq 'CODE'){if ($self->{verbose}){return$cmd->()}else {require Capture::Tiny;open my$logfh,">>",$self->{log};my$ret;Capture::Tiny::capture(sub {$ret=$cmd->()},stdout=>$logfh,stderr=>$logfh);return$ret}}if (WIN32){$cmd=Menlo::Util::shell_quote(@$cmd)if ref$cmd eq 'ARRAY';unless ($self->{verbose}){$cmd .= " >> " .Menlo::Util::shell_quote($self->{log})." 2>&1"}!system$cmd}else {my$pid=fork;if ($pid){waitpid$pid,0;return!$?}else {$self->run_exec($cmd)}}}sub run_exec {my($self,$cmd)=@_;if (ref$cmd eq 'ARRAY'){unless ($self->{verbose}){open my$logfh,">>",$self->{log};open STDERR,'>&',$logfh;open STDOUT,'>&',$logfh;close$logfh}exec @$cmd}else {unless ($self->{verbose}){$cmd .= " >> " .Menlo::Util::shell_quote($self->{log})." 2>&1"}exec$cmd}}sub run_timeout {my($self,$cmd,$timeout)=@_;return$self->run_command($cmd)if ref($cmd)eq 'CODE' || WIN32 || $self->{verbose}||!$timeout;my$pid=fork;if ($pid){eval {local$SIG{ALRM}=sub {die "alarm\n"};alarm$timeout;waitpid$pid,0;alarm 0};if ($@ && $@ eq "alarm\n"){$self->diag_fail("Timed out (> ${timeout}s). Use --verbose to retry.");local$SIG{TERM}='IGNORE';kill TERM=>0;waitpid$pid,0;return}return!$?}elsif ($pid==0){$self->run_exec($cmd)}else {$self->chat("! fork failed: falling back to system()\n");$self->run_command($cmd)}}sub append_args {my($self,$cmd,$phase)=@_;return$cmd if ref$cmd ne 'ARRAY';if (my$args=$self->{build_args}{$phase}){$cmd=join ' ',Menlo::Util::shell_quote(@$cmd),$args}$cmd}sub _use_unsafe_inc {my($self,$dist)=@_;if (exists$ENV{PERL_USE_UNSAFE_INC}){return$ENV{PERL_USE_UNSAFE_INC}}if (exists$dist->{meta}{x_use_unsafe_inc}){$self->chat("Distribution opts in x_use_unsafe_inc: $dist->{meta}{x_use_unsafe_inc}\n");return$dist->{meta}{x_use_unsafe_inc}}return 1}sub configure {my($self,$cmd,$dist,$depth)=@_;local$ENV{PERL5_CPAN_IS_RUNNING}=local$ENV{PERL5_CPANPLUS_IS_RUNNING}=$$;local$ENV{PERL5_CPANM_IS_RUNNING}=$$;my$use_default=!$self->{interactive};local$ENV{PERL_MM_USE_DEFAULT}=$use_default;local$ENV{PERL_MM_OPT}=$ENV{PERL_MM_OPT};local$ENV{PERL_MB_OPT}=$ENV{PERL_MB_OPT};unless ($self->{pod2man}){$ENV{PERL_MM_OPT}.= " INSTALLMAN1DIR=none INSTALLMAN3DIR=none";$ENV{PERL_MB_OPT}.= " --config installman1dir= --config installsiteman1dir= --config installman3dir= --config installsiteman3dir="}if ($self->{pure_perl}){$ENV{PERL_MM_OPT}.= " PUREPERL_ONLY=1";$ENV{PERL_MB_OPT}.= " --pureperl-only"}local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'configure')if$depth==0;local$self->{verbose}=$self->{verbose}|| $self->{interactive};$self->run_timeout($cmd,$self->{configure_timeout})}sub build {my($self,$cmd,$distname,$dist,$depth)=@_;local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'build')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{build_timeout});while (1){my$ans=lc$self->prompt("Building $distname failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->build($cmd,$distname,$dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}sub test {my($self,$cmd,$distname,$dist,$depth)=@_;return 1 if$self->{notest};local$ENV{PERL_MM_USE_DEFAULT}=!$self->{interactive};local$ENV{NONINTERACTIVE_TESTING}=!$self->{interactive};local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);$cmd=$self->append_args($cmd,'test')if$depth==0;return 1 if$self->run_timeout($cmd,$self->{test_timeout});if ($self->{force}){$self->diag_fail("Testing $distname failed but installing it anyway.");return 1}else {$self->diag_fail;while (1){my$ans=lc$self->prompt("Testing $distname failed.\nYou can s)kip, r)etry, f)orce install, e)xamine build log, or l)ook ?","s");return if$ans eq 's';return$self->test($cmd,$distname,$dist,$depth)if$ans eq 'r';return 1 if$ans eq 'f';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}}sub install {my($self,$cmd,$uninst_opts,$dist,$depth)=@_;if ($depth==0 && $self->{test_only}){return 1}return$self->run_command($cmd)if ref$cmd eq 'CODE';local$ENV{PERL_USE_UNSAFE_INC}=$self->_use_unsafe_inc($dist);if ($self->{sudo}){unshift @$cmd,"sudo"}if ($self->{uninstall_shadows}&&!$ENV{PERL_MM_OPT}){push @$cmd,@$uninst_opts}$cmd=$self->append_args($cmd,'install')if$depth==0;$self->run_command($cmd)}sub look {my$self=shift;my$shell=$ENV{SHELL};$shell ||= $ENV{COMSPEC}if WIN32;if ($shell){my$cwd=Cwd::cwd;$self->diag("Entering $cwd with $shell\n");system$shell}else {$self->diag_fail("You don't seem to have a SHELL :/")}}sub show_build_log {my$self=shift;my@pagers=($ENV{PAGER},(WIN32 ? (): ('less')),'more');my$pager;while (@pagers){$pager=shift@pagers;next unless$pager;$pager=which($pager);next unless$pager;last}if ($pager){if (WIN32){system "@{[ qs $pager ]} < @{[ qs $self->{log}]}"}else {system$pager,$self->{log}}}else {$self->diag_fail("You don't seem to have a PAGER :/")}}sub chdir {my$self=shift;Cwd::chdir(File::Spec->canonpath($_[0]))or die "$_[0]: $!"}sub configure_mirrors {my$self=shift;unless (@{$self->{mirrors}}){$self->{mirrors}=['http://www.cpan.org' ]}for (@{$self->{mirrors}}){s!^/!file:///!;s!/$!!}}sub self_upgrade {my$self=shift;$self->check_upgrade;$self->{argv}=['Menlo' ];return}sub install_module {my($self,$module,$depth,$version,$dep)=@_;$self->check_libs;if ($self->{seen}{$module}++){$self->chat("Already tried $module. Skipping.\n");return 1}if ($self->{skip_satisfied}){my($ok,$local)=$self->check_module($module,$version || 0);if ($ok){$self->diag("You have $module ($local)\n",1);return 1}}my$dist=$self->resolve_name($module,$version,$dep);unless ($dist){my$what=$module .($version ? " ($version)" : "");$self->diag_fail("Couldn't find module or a distribution $what",1);return}if ($dist->{distvname}&& $self->{seen}{$dist->{distvname}}++){$self->chat("Already tried $dist->{distvname}. Skipping.\n");return 1}if ($self->{cmd}eq 'info'){print$self->format_dist($dist),"\n";return 1}$dist->{depth}=$depth;if ($dist->{module}){unless ($self->satisfy_version($dist->{module},$dist->{module_version},$version)){$self->diag("Found $dist->{module} $dist->{module_version} which doesn't satisfy $version.\n",1);return}my$cmp=$version ? "==" : "";my$requirement=$dist->{module_version}? "$cmp$dist->{module_version}" : 0;my($ok,$local)=$self->check_module($dist->{module},$requirement);if ($self->{skip_installed}&& $ok){$self->diag("$dist->{module} is up to date. ($local)\n",1);return 1}}if ($dist->{dist}eq 'perl'){$self->diag("skipping $dist->{pathname}\n");return 1}$self->diag("--> Working on $module\n");$dist->{dir}||= $self->fetch_module($dist);unless ($dist->{dir}){$self->diag_fail("Failed to fetch distribution $dist->{distvname}",1);return}$self->chat("Entering $dist->{dir}\n");$self->chdir($self->{base});$self->chdir($dist->{dir});if ($self->{cmd}eq 'look'){$self->look;return 1}return$self->build_stuff($module,$dist,$depth)}sub uninstall_search_path {my$self=shift;$self->{local_lib}? (local::lib->install_base_arch_path($self->{local_lib}),local::lib->install_base_perl_path($self->{local_lib})): @Config{qw(installsitearch installsitelib)}}sub uninstall_module {my ($self,$module)=@_;$self->check_libs;my@inc=$self->uninstall_search_path;my($metadata,$packlist)=$self->packlists_containing($module,\@inc);unless ($packlist){$self->diag_fail(<<DIAG,1);return}my@uninst_files=$self->uninstall_target($metadata,$packlist);$self->ask_permission($module,\@uninst_files)or return;$self->uninstall_files(@uninst_files,$packlist);$self->diag("Successfully uninstalled $module\n",1);return 1}sub packlists_containing {my($self,$module,$inc)=@_;require Module::Metadata;my$metadata=Module::Metadata->new_from_module($module,inc=>$inc)or return;my$packlist;my$wanted=sub {return unless $_ eq '.packlist' && -f $_;for my$file ($self->unpack_packlist($File::Find::name)){$packlist ||= $File::Find::name if$file eq $metadata->filename}};{require File::pushd;my$pushd=File::pushd::pushd();my@search=grep -d $_,map File::Spec->catdir($_,'auto'),@$inc;File::Find::find($wanted,@search)}return$metadata,$packlist}sub uninstall_target {my($self,$metadata,$packlist)=@_;if ($self->has_shadow_install($metadata)or $self->{local_lib}){grep$self->should_unlink($_),$self->unpack_packlist($packlist)}else {$self->unpack_packlist($packlist)}}sub has_shadow_install {my($self,$metadata)=@_;my@shadow=grep defined,map Module::Metadata->new_from_module($metadata->name,inc=>[$_]),@INC;@shadow >= 2}sub should_unlink {my($self,$file)=@_;if ($self->{local_lib}){$file =~ /^\Q$self->{local_lib}\E/}else {!(grep$file =~ /^\Q$_\E/,@Config{qw(installbin installscript installman1dir installman3dir)})}}sub ask_permission {my ($self,$module,$files)=@_;$self->diag("$module contains the following files:\n\n");for my$file (@$files){$self->diag("  $file\n")}$self->diag("\n");return 'force uninstall' if$self->{force};local$self->{prompt}=1;return$self->prompt_bool("Are you sure you want to uninstall $module?",'y')}sub unpack_packlist {my ($self,$packlist)=@_;open my$fh,'<',$packlist or die "$packlist: $!";map {chomp;$_}<$fh>}sub uninstall_files {my ($self,@files)=@_;$self->diag("\n");for my$file (@files){$self->diag("Unlink: $file\n");unlink$file or $self->diag_fail("$!: $file")}$self->diag("\n");return 1}sub format_dist {my($self,$dist)=@_;return "$dist->{cpanid}/$dist->{filename}"}sub trim {local $_=shift;tr/\n/ /d;s/^\s*|\s*$//g;$_}sub fetch_module {my($self,$dist)=@_;$self->chdir($self->{base});for my$uri (@{$dist->{uris}}){$self->mask_output(diag_progress=>"Fetching $uri");my$filename=$dist->{filename}|| $uri;my$name=File::Basename::basename($filename);my$cancelled;my$fetch=sub {my$file;eval {local$SIG{INT}=sub {$cancelled=1;die "SIGINT\n"};$self->mirror($uri,$name);$file=$name if -e $name};$self->diag("ERROR: " .trim("$@")."\n",1)if $@ && $@ ne "SIGINT\n";return$file};my($try,$file);while ($try++ < 3){$file=$fetch->();last if$cancelled or $file;$self->mask_output(diag_fail=>"Download $uri failed. Retrying ... ")}if ($cancelled){$self->diag_fail("Download cancelled.");return}unless ($file){$self->mask_output(diag_fail=>"Failed to download $uri");next}$self->diag_ok;$dist->{local_path}=File::Spec->rel2abs($name);my$dir=$self->unpack($file,$uri,$dist);next unless$dir;if (my$save=$self->{save_dists}){my$path=$dist->{pathname}? "$save/authors/id/$dist->{pathname}" : "$save/vendor/$file";$self->chat("Copying $name to $path\n");File::Path::mkpath([File::Basename::dirname($path)],0,0777);File::Copy::copy($file,$path)or warn $!}return$dist,$dir}}sub unpack {my($self,$file,$uri,$dist)=@_;if ($self->{verify}){$self->verify_archive($file,$uri,$dist)or return}$self->chat("Unpacking $file\n");my$dir=$file =~ /\.zip/i ? $self->unzip($file): $self->untar($file);unless ($dir){$self->diag_fail("Failed to unpack $file: no directory")}return$dir}sub verify_checksums_signature {my($self,$chk_file)=@_;require Module::Signature;$self->chat("Verifying the signature of CHECKSUMS\n");my$rv=eval {local$SIG{__WARN__}=sub {};my$v=Module::Signature::_verify($chk_file);$v==Module::Signature::SIGNATURE_OK()};if ($rv){$self->chat("Verified OK!\n")}else {$self->diag_fail("Verifying CHECKSUMS signature failed: $rv\n");return}return 1}sub verify_archive {my($self,$file,$uri,$dist)=@_;unless ($dist->{cpanid}){$self->chat("Archive '$file' does not seem to be from PAUSE. Skip verification.\n");return 1}(my$mirror=$uri)=~ s!/authors/id.*$!!;(my$chksum_uri=$uri)=~ s!/[^/]*$!/CHECKSUMS!;my$chk_file=$self->source_for($mirror)."/$dist->{cpanid}.CHECKSUMS";$self->mask_output(diag_progress=>"Fetching $chksum_uri");$self->mirror($chksum_uri,$chk_file);unless (-e $chk_file){$self->diag_fail("Fetching $chksum_uri failed.\n");return}$self->diag_ok;$self->verify_checksums_signature($chk_file)or return;$self->verify_checksum($file,$chk_file)}sub verify_checksum {my($self,$file,$chk_file)=@_;$self->chat("Verifying the SHA1 for $file\n");open my$fh,"<$chk_file" or die "$chk_file: $!";my$data=join '',<$fh>;$data =~ s/\015?\012/\n/g;require Safe;my$chksum=Safe->new->reval($data);if (!ref$chksum or ref$chksum ne 'HASH'){$self->diag_fail("! Checksum file downloaded from $chk_file is broken.\n");return}if (my$sha=$chksum->{$file}{sha256}){my$hex=$self->sha_for(256,$file);if ($hex eq $sha){$self->chat("Checksum for $file: Verified!\n")}else {$self->diag_fail("Checksum mismatch for $file\n");return}}else {$self->chat("Checksum for $file not found in CHECKSUMS.\n");return}}sub sha_for {my($self,$alg,$file)=@_;require Digest::SHA;open my$fh,"<",$file or die "$file: $!";my$dg=Digest::SHA->new($alg);my($data);while (read($fh,$data,4096)){$dg->add($data)}return$dg->hexdigest}sub verify_signature {my($self,$dist)=@_;$self->diag_progress("Verifying the SIGNATURE file");my$out=`@{[ qs $self->{cpansign} ]} -v --skip 2>&1`;$self->log($out);if ($out =~ /Signature verified OK/){$self->diag_ok("Verified OK");return 1}else {$self->diag_fail("SIGNATURE verification for $dist->{filename} failed\n");return}}sub resolve_name {my($self,$module,$version,$dep)=@_;if ($dep && $dep->url){if ($dep->url =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$dep->url)}else {return {uris=>[$dep->url ]}}}if ($dep && $dep->dist){return$self->cpan_dist($dep->dist,undef,$dep->mirror)}if ($module =~ /(?:^git:|\.git(?:@.+)?$)/){return$self->git_uri($module)}if ($module =~ /^(ftp|https?|file):/){if ($module =~ m!authors/id/(.*)!){return$self->cpan_dist($1,$module)}else {return {uris=>[$module ]}}}if ($module =~ m!^[\./]! && -d $module){return {source=>'local',dir=>Cwd::abs_path($module),}}if (-f $module){return {source=>'local',uris=>["file://" .Cwd::abs_path($module)],}}if ($module =~ s!^cpan:///distfile/!!){return$self->cpan_dist($module)}if ($module =~ m!^(?:[A-Z]/[A-Z]{2}/)?([A-Z]{2}[\-A-Z0-9]*/.*)$!){return$self->cpan_dist($1)}return$self->search_module($module,$version)}sub cpan_module_common {my($self,$match)=@_;(my$distfile=$match->{uri})=~ s!^cpan:///distfile/!!;my$mirrors=$self->{mirrors};if ($match->{download_uri}){(my$mirror=$match->{download_uri})=~ s!/authors/id/.*$!!;$mirrors=[$mirror]}local$self->{mirrors}=$mirrors;return$self->cpan_module($match->{package},$distfile,$match->{version})}sub cpan_module {my($self,$module,$dist_file,$version)=@_;my$dist=$self->cpan_dist($dist_file);$dist->{module}=$module;$dist->{module_version}=$version if$version && $version ne 'undef';return$dist}sub cpan_dist {my($self,$dist,$url,$mirror)=@_;$mirror =~ s!/$!! if$mirror;$dist =~ s!^([A-Z]{2})!substr($1,0,1)."/".substr($1,0,2)."/".$1!e;require CPAN::DistnameInfo;my$d=CPAN::DistnameInfo->new($dist);if ($url){$url=[$url ]unless ref$url eq 'ARRAY'}else {my$id=$d->cpanid;my$fn=substr($id,0,1)."/" .substr($id,0,2)."/" .$id ."/" .$d->filename;my@mirrors=$mirror ? ($mirror): @{$self->{mirrors}};my@urls=map "$_/authors/id/$fn",@mirrors;$url=\@urls,}return {$d->properties,source=>'cpan',uris=>$url,}}sub git_uri {my ($self,$uri)=@_;($uri,my$commitish)=split /(?<=\.git)@/i,$uri,2;my$dir=File::Temp::tempdir(CLEANUP=>1);$self->mask_output(diag_progress=>"Cloning $uri");$self->run_command(['git','clone',$uri,$dir ]);unless (-e "$dir/.git"){$self->diag_fail("Failed cloning git repository $uri",1);return}if ($commitish){require File::pushd;my$dir=File::pushd::pushd($dir);unless ($self->run_command(['git','checkout',$commitish ])){$self->diag_fail("Failed to checkout '$commitish' in git repository $uri\n");return}}$self->diag_ok;return {source=>'local',dir=>$dir,}}sub core_version_for {my($self,$module)=@_;require Module::CoreList;unless (exists$Module::CoreList::version{$]+0}){die sprintf("Module::CoreList %s (loaded from %s) doesn't seem to have entries for perl $]. " ."You're strongly recommended to upgrade Module::CoreList from CPAN.\n",$Module::CoreList::VERSION,$INC{"Module/CoreList.pm"})}unless (exists$Module::CoreList::version{$]+0}{$module}){return -1}return$Module::CoreList::version{$]+0}{$module}}sub search_inc {my$self=shift;$self->{search_inc}||= do {if (defined$::Bin){[grep!/^\Q$::Bin\E\/..\/(?:fat)?lib$/,@INC]}else {[@INC]}}}sub check_module {my($self,$mod,$want_ver)=@_;require Module::Metadata;my$meta=Module::Metadata->new_from_module($mod,inc=>$self->search_inc)or return 0,undef;my$version=$meta->version;if ($self->{self_contained}&& $self->loaded_from_perl_lib($meta)){$version=$self->core_version_for($mod);return 0,undef if$version && $version==-1}$self->{local_versions}{$mod}=$version;if ($self->is_deprecated($meta)){return 0,$version}elsif ($self->satisfy_version($mod,$version,$want_ver)){return 1,($version || 'undef')}else {return 0,$version}}sub satisfy_version {my($self,$mod,$version,$want_ver)=@_;$want_ver='0' unless defined($want_ver)&& length($want_ver);require CPAN::Meta::Requirements;my$requirements=CPAN::Meta::Requirements->new;$requirements->add_string_requirement($mod,$want_ver);$requirements->accepts_module($mod,$version)}sub unsatisfy_how {my($self,$ver,$want_ver)=@_;if ($want_ver =~ /^[v0-9\.\_]+$/){return "$ver < $want_ver"}else {return "$ver doesn't satisfy $want_ver"}}sub is_deprecated {my($self,$meta)=@_;my$deprecated=eval {require Module::CoreList;Module::CoreList::is_deprecated($meta->{module})};return$deprecated && $self->loaded_from_perl_lib($meta)}sub loaded_from_perl_lib {my($self,$meta)=@_;require Config;my@dirs=qw(archlibexp privlibexp);if ($self->{self_contained}&&!$self->{exclude_vendor}&& $Config{vendorarch}){unshift@dirs,qw(vendorarch vendorlibexp)}for my$dir (@dirs){my$confdir=$Config{$dir};if ($confdir eq substr($meta->filename,0,length($confdir))){return 1}}return}sub should_install {my($self,$mod,$ver)=@_;$self->chat("Checking if you have $mod $ver ... ");my($ok,$local)=$self->check_module($mod,$ver);if ($ok){$self->chat("Yes ($local)\n")}elsif ($local){$self->chat("No (" .$self->unsatisfy_how($local,$ver).")\n")}else {$self->chat("No\n")}return$mod unless$ok;return}sub check_perl_version {my($self,$version)=@_;require CPAN::Meta::Requirements;my$req=CPAN::Meta::Requirements->from_string_hash({perl=>$version });$req->accepts_module(perl=>$])}sub install_deps {my($self,$dir,$depth,@deps)=@_;my(@install,%seen,@fail);for my$dep (@deps){next if$seen{$dep->module};if ($dep->module eq 'perl'){if ($dep->is_requirement &&!$self->check_perl_version($dep->version)){$self->diag("Needs perl @{[$dep->version]}, you have $]\n");push@fail,'perl'}}elsif ($self->should_install($dep->module,$dep->version)){push@install,$dep;$seen{$dep->module}=1}}if (@install){$self->diag("==> Found dependencies: " .join(", ",map $_->module,@install)."\n")}for my$dep (@install){$self->install_module($dep->module,$depth + 1,$dep->version,$dep)}$self->chdir($self->{base});$self->chdir($dir)if$dir;if ($self->{scandeps}){return 1}my@not_ok=$self->unsatisfied_deps(@deps);if (@not_ok){return 0,\@not_ok}else {return 1}}sub unsatisfied_deps {my($self,@deps)=@_;require CPAN::Meta::Check;require CPAN::Meta::Requirements;my$reqs=CPAN::Meta::Requirements->new;for my$dep (grep $_->is_requirement,@deps){$reqs->add_string_requirement($dep->module=>$dep->requires_version || '0')}my$ret=CPAN::Meta::Check::check_requirements($reqs,'requires',$self->{search_inc});grep defined,values %$ret}sub install_deps_bailout {my($self,$target,$dir,$depth,@deps)=@_;my($ok,$fail)=$self->install_deps($dir,$depth,@deps);if (!$ok){$self->diag_fail("Installing the dependencies failed: " .join(", ",@$fail),1);unless ($self->prompt_bool("Do you want to continue building $target anyway?","n")){$self->diag_fail("Bailing out the installation for $target.",1);return}}return 1}sub build_stuff {my($self,$stuff,$dist,$depth)=@_;if ($self->{verify}&& -e 'SIGNATURE'){$self->verify_signature($dist)or return}require CPAN::Meta;my($meta_file)=grep -f,qw(META.json META.yml);if ($meta_file){$self->chat("Checking configure dependencies from $meta_file\n");$dist->{cpanmeta}=eval {CPAN::Meta->load_file($meta_file)}}elsif ($dist->{dist}&& $dist->{version}){$self->chat("META.yml/json not found. Creating skeleton for it.\n");$dist->{cpanmeta}=CPAN::Meta->new({name=>$dist->{dist},version=>$dist->{version}})}$dist->{meta}=$dist->{cpanmeta}? $dist->{cpanmeta}->as_struct : {};if ($self->opts_in_static_install($dist->{cpanmeta})){$dist->{static_install}=1}my@config_deps;if ($dist->{cpanmeta}){push@config_deps,Menlo::Dependency->from_prereqs($dist->{cpanmeta}->effective_prereqs,['configure'],$self->{install_types},)}if (-e 'Build.PL' &&!@config_deps){push@config_deps,Menlo::Dependency->from_versions({'Module::Build'=>'0.38' },'configure',)}$self->merge_with_cpanfile($dist,\@config_deps);$self->upgrade_toolchain(\@config_deps);my$target=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $dist->{dir};unless ($self->skip_configure($dist,$depth)){$self->install_deps_bailout($target,$dist->{dir},$depth,@config_deps)or return}$self->diag_progress("Configuring $target");my$configure_state=$self->configure_this($dist,$depth);$self->diag_ok($configure_state->{configured_ok}? "OK" : "N/A");if ($dist->{cpanmeta}&& $dist->{source}eq 'cpan'){$dist->{provides}=$dist->{cpanmeta}{provides}|| $self->extract_packages($dist->{cpanmeta},".")}my$deps_only=$self->deps_only($depth);$dist->{want_phases}=$self->{notest}&&!$self->deps_only($depth)? [qw(build runtime)]: [qw(build test runtime)];push @{$dist->{want_phases}},'develop' if$self->{with_develop}&& $depth==0;push @{$dist->{want_phases}},'configure' if$self->{with_configure}&& $depth==0;my@deps=$self->find_prereqs($dist);my$module_name=$self->find_module_name($configure_state)|| $dist->{meta}{name};$module_name =~ s/-/::/g;if ($self->{showdeps}){for my$dep (@config_deps,@deps){print$dep->module,($dep->version ? ("~".$dep->version): ""),"\n"}return 1}my$distname=$dist->{meta}{name}? "$dist->{meta}{name}-$dist->{meta}{version}" : $stuff;my$walkup;if ($self->{scandeps}){$walkup=$self->scandeps_append_child($dist)}$self->install_deps_bailout($distname,$dist->{dir},$depth,@deps)or return;if ($self->{scandeps}){unless ($configure_state->{configured_ok}){my$diag=<<DIAG;if (@config_deps){my@tree=@{$self->{scandeps_tree}};$diag .= "!\n" .join("",map "! * $_->[0]{module}\n",@tree[0..$#tree-1])if@tree}$self->diag("!\n$diag!\n",1)}$walkup->();return 1}if ($self->{installdeps}&& $depth==0){if ($configure_state->{configured_ok}){$self->diag("<== Installed dependencies for $stuff. Finishing.\n");return 1}else {$self->diag("! Configuring $distname failed. See $self->{log} for details.\n",1);return}}my$installed;if ($configure_state->{static_install}){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build(sub {$configure_state->{static_install}->build},$distname,$dist,$depth)&& $self->test(sub {$configure_state->{static_install}->build("test")},$distname,$dist,$depth)&& $self->install(sub {$configure_state->{static_install}->build("install")},[],$dist,$depth)&& $installed++}elsif ($configure_state->{use_module_build}&& -e 'Build' && -f _){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{perl},"./Build" ],$distname,$dist,$depth)&& $self->test([$self->{perl},"./Build","test" ],$distname,$dist,$depth)&& $self->install([$self->{perl},"./Build","install" ],["--uninst",1 ],$dist,$depth)&& $installed++}elsif ($self->{make}&& -e 'Makefile'){$self->diag_progress("Building " .($self->{notest}? "" : "and testing ").$distname);$self->build([$self->{make}],$distname,$dist,$depth)&& $self->test([$self->{make},"test" ],$distname,$dist,$depth)&& $self->install([$self->{make},"install" ],["UNINST=1" ],$dist,$depth)&& $installed++}else {my$why;my$configure_failed=$configure_state->{configured}&&!$configure_state->{configured_ok};if ($configure_failed){$why="Configure failed for $distname."}elsif ($self->{make}){$why="The distribution doesn't have a proper Makefile.PL/Build.PL"}else {$why="Can't configure the distribution. You probably need to have 'make'."}$self->diag_fail("$why See $self->{log} for details.",1);return}if ($installed && $self->{test_only}){$self->diag_ok;$self->diag("Successfully tested $distname\n",1)}elsif ($installed){my$local=$self->{local_versions}{$dist->{module}|| ''};my$version=$dist->{module_version}|| $dist->{meta}{version}|| $dist->{version};my$reinstall=$local && ($local eq $version);my$action=$local &&!$reinstall ? $self->is_downgrade($version,$local)? "downgraded" : "upgraded" : undef;my$how=$reinstall ? "reinstalled $distname" : $local ? "installed $distname ($action from $local)" : "installed $distname" ;my$msg="Successfully $how";$self->diag_ok;$self->diag("$msg\n",1);$self->{installed_dists}++;$self->save_meta($stuff,$dist,$module_name,\@config_deps,\@deps);return 1}else {my$what=$self->{test_only}? "Testing" : "Installing";$self->diag_fail("$what $stuff failed. See $self->{log} for details. Retry with --force to force install it.",1);return}}sub is_downgrade {my($self,$va,$vb)=@_;eval {version::->new($va)< $vb}}sub opts_in_static_install {my($self,$meta)=@_;return if!$self->{static_install};return if$self->{sudo}or $self->{uninstall_shadows};return$meta->{x_static_install}&& $meta->{x_static_install}==1}sub skip_configure {my($self,$dist,$depth)=@_;return 1 if$self->{skip_configure};return 1 if$dist->{static_install};return 1 if$self->no_dynamic_config($dist->{meta})&& $self->deps_only($depth);return}sub no_dynamic_config {my($self,$meta)=@_;exists$meta->{dynamic_config}&& $meta->{dynamic_config}==0}sub deps_only {my($self,$depth)=@_;($self->{installdeps}&& $depth==0)or $self->{showdeps}or $self->{scandeps}}sub perl_requirements {my($self,@requires)=@_;my@perl;for my$requires (grep defined,@requires){if (exists$requires->{perl}){push@perl,Menlo::Dependency->new(perl=>$requires->{perl})}}return@perl}sub configure_this {my($self,$dist,$depth)=@_;my$deps_only=$self->deps_only($depth);if (-e $self->{cpanfile_path}&& $deps_only){require Module::CPANfile;$dist->{cpanfile}=eval {Module::CPANfile->load($self->{cpanfile_path})};$self->diag_fail($@,1)if $@;$self->{cpanfile_global}||= $dist->{cpanfile};return {configured=>1,configured_ok=>!!$dist->{cpanfile},use_module_build=>0,}}if ($self->{skip_configure}){my$eumm=-e 'Makefile';my$mb=-e 'Build' && -f _;return {configured=>1,configured_ok=>$eumm || $mb,use_module_build=>$mb,}}if ($deps_only && $self->no_dynamic_config($dist->{meta})){return {configured=>1,configured_ok=>exists$dist->{meta}{prereqs},use_module_build=>0,}}my$state={};my$try_static=sub {if ($dist->{static_install}){$self->chat("Distribution opts in x_static_install: $dist->{meta}{x_static_install}\n");$self->static_install_configure($state,$dist,$depth)}};my$try_eumm=sub {if (-e 'Makefile.PL'){$self->chat("Running Makefile.PL\n");if ($self->configure([$self->{perl},"Makefile.PL" ],$dist,$depth)){$state->{configured_ok}=-e 'Makefile'}$state->{configured}++}};my$try_mb=sub {if (-e 'Build.PL'){$self->chat("Running Build.PL\n");if ($self->configure([$self->{perl},"Build.PL" ],$dist,$depth)){$state->{configured_ok}=-e 'Build' && -f _}$state->{use_module_build}++;$state->{configured}++}};for my$try ($try_static,$try_mb,$try_eumm){$try->();last if$state->{configured_ok}}unless ($state->{configured_ok}){while (1){my$ans=lc$self->prompt("Configuring $dist->{dist} failed.\nYou can s)kip, r)etry, e)xamine build log, or l)ook ?","s");last if$ans eq 's';return$self->configure_this($dist,$depth)if$ans eq 'r';$self->show_build_log if$ans eq 'e';$self->look if$ans eq 'l'}}return$state}sub static_install_configure {my($self,$state,$dist,$depth)=@_;my$args=$depth==0 ? $self->{build_args}{configure}: [];require Menlo::Builder::Static;my$builder=Menlo::Builder::Static->new(meta=>$dist->{cpanmeta});$self->configure(sub {$builder->configure($args || [])},$dist,$depth);$state->{configured_ok}=1;$state->{static_install}=$builder;$state->{configured}++}sub find_module_name {my($self,$state)=@_;return unless$state->{configured_ok};if ($state->{use_module_build}&& -e "_build/build_params"){my$params=do {open my$in,"_build/build_params";eval(join "",<$in>)};return eval {$params->[2]{module_name}}|| undef}elsif (-e "Makefile"){open my$mf,"Makefile";while (<$mf>){if (/^\#\s+NAME\s+=>\s+(.*)/){return eval($1)}}}return}sub list_files {my$self=shift;if (-e 'MANIFEST'){require ExtUtils::Manifest;my$manifest=eval {ExtUtils::Manifest::manifind()}|| {};return sort {lc$a cmp lc$b}keys %$manifest}else {require File::Find;my@files;my$finder=sub {my$name=$File::Find::name;$name =~ s!\.[/\\]!!;push@files,$name};File::Find::find($finder,".");return sort {lc$a cmp lc$b}@files}}sub extract_packages {my($self,$meta,$dir)=@_;my$try=sub {my$file=shift;return 0 if$file =~ m!^(?:x?t|inc|local|perl5|fatlib|_build)/!;return 1 unless$meta->{no_index};return 0 if grep {$file =~ m!^$_/!}@{$meta->{no_index}{directory}|| []};return 0 if grep {$file eq $_}@{$meta->{no_index}{file}|| []};return 1};require Parse::PMFile;my@files=grep {/\.pm(?:\.PL)?$/ && $try->($_)}$self->list_files;my$provides={};for my$file (@files){my$parser=Parse::PMFile->new($meta,{UNSAFE=>1,ALLOW_DEV_VERSION=>1 });my$packages=$parser->parse($file);while (my($package,$meta)=each %$packages){$provides->{$package}||= {file=>$meta->{infile},($meta->{version}eq 'undef')? (): (version=>$meta->{version}),}}}return$provides}sub save_meta {my($self,$module,$dist,$module_name,$config_deps,$build_deps)=@_;return unless$dist->{distvname}&& $dist->{source}eq 'cpan';my$base=($ENV{PERL_MM_OPT}|| '')=~ /INSTALL_BASE=/ ? ($self->install_base($ENV{PERL_MM_OPT})."/lib/perl5"): $Config{sitelibexp};my$provides=$dist->{provides};File::Path::mkpath("blib/meta",0,0777);my$local={name=>$module_name,target=>$module,version=>exists$provides->{$module_name}? ($provides->{$module_name}{version}|| $dist->{version}): $dist->{version},dist=>$dist->{distvname},pathname=>$dist->{pathname},provides=>$provides,};require JSON::PP;open my$fh,">","blib/meta/install.json" or die $!;print$fh JSON::PP::encode_json($local);File::Copy::copy("MYMETA.json","blib/meta/MYMETA.json");my@cmd=(($self->{sudo}? 'sudo' : ()),$^X,'-MExtUtils::Install=install','-e',qq[install({ 'blib/meta' => '$base/$Config{archname}/.meta/$dist->{distvname}' })],);$self->run_command(\@cmd)}sub install_base {my($self,$mm_opt)=@_;$mm_opt =~ /INSTALL_BASE=(\S+)/ and return $1;die "Your PERL_MM_OPT doesn't contain INSTALL_BASE"}sub configure_features {my($self,$dist,@features)=@_;map $_->identifier,grep {$self->effective_feature($dist,$_)}@features}sub effective_feature {my($self,$dist,$feature)=@_;if ($dist->{depth}==0){my$value=$self->{features}{$feature->identifier};return$value if defined$value;return 1 if$self->{features}{__all}}if ($self->{interactive}){require CPAN::Meta::Requirements;$self->diag("[@{[ $feature->description ]}]\n",1);my$req=CPAN::Meta::Requirements->new;for my$phase (@{$dist->{want_phases}}){for my$type (@{$self->{install_types}}){$req->add_requirements($feature->prereqs->requirements_for($phase,$type))}}my$reqs=$req->as_string_hash;my@missing;for my$module (keys %$reqs){if ($self->should_install($module,$req->{$module})){push@missing,$module}}if (@missing){my$howmany=@missing;$self->diag("==> Found missing dependencies: " .join(", ",@missing)."\n",1);local$self->{prompt}=1;return$self->prompt_bool("Install the $howmany optional module(s)?","y")}}return}sub find_prereqs {my($self,$dist)=@_;my@deps=$self->extract_meta_prereqs($dist);if ($dist->{module}=~ /^Bundle::/i){push@deps,$self->bundle_deps($dist)}$self->merge_with_cpanfile($dist,\@deps);return@deps}sub merge_with_cpanfile {my($self,$dist,$deps)=@_;if ($self->{cpanfile_requirements}&&!$dist->{cpanfile}){for my$dep (@$deps){$dep->merge_with($self->{cpanfile_requirements})}}if ($self->{cpanfile_global}){for my$dep (@$deps){my$opts=$self->{cpanfile_global}->options_for_module($dep->module)or next;$dep->dist($opts->{dist})if$opts->{dist};$dep->mirror($opts->{mirror})if$opts->{mirror};$dep->url($opts->{url})if$opts->{url}}}}sub extract_meta_prereqs {my($self,$dist)=@_;if ($dist->{cpanfile}){my@features=$self->configure_features($dist,$dist->{cpanfile}->features);my$prereqs=$dist->{cpanfile}->prereqs_with(@features);$self->{cpanfile_requirements}=$prereqs->merged_requirements($dist->{want_phases},['requires']);return Menlo::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}require CPAN::Meta;my@meta=qw(MYMETA.json MYMETA.yml);if ($self->no_dynamic_config($dist->{meta})){push@meta,qw(META.json META.yml)}my@deps;my($meta_file)=grep -f,@meta;if ($meta_file){$self->chat("Checking dependencies from $meta_file ...\n");my$mymeta=eval {CPAN::Meta->load_file($meta_file,{lazy_validation=>1 })};if ($mymeta){$dist->{meta}{name}=$mymeta->name;$dist->{meta}{version}=$mymeta->version;return$self->extract_prereqs($mymeta,$dist)}}$self->diag_fail("No MYMETA file is found after configure. Your toolchain is too old?");return}sub bundle_deps {my($self,$dist)=@_;my$match;if ($dist->{module}){$match=sub {my$meta=Module::Metadata->new_from_file($_[0]);$meta && ($meta->name eq $dist->{module})}}else {$match=sub {1}}my@files;File::Find::find({wanted=>sub {push@files,File::Spec->rel2abs($_)if /\.pm$/i && $match->($_)},no_chdir=>1,},'.');my@deps;for my$file (@files){open my$pod,"<",$file or next;my$in_contents;while (<$pod>){if (/^=head\d\s+CONTENTS/){$in_contents=1}elsif (/^=/){$in_contents=0}elsif ($in_contents){/^(\S+)\s*(\S+)?/ and push@deps,Menlo::Dependency->new($1,$self->maybe_version($2))}}}return@deps}sub maybe_version {my($self,$string)=@_;return$string && $string =~ /^\.?\d/ ? $string : undef}sub extract_prereqs {my($self,$meta,$dist)=@_;my@features=$self->configure_features($dist,$meta->features);my$prereqs=$meta->effective_prereqs(\@features)->clone;$self->adjust_prereqs($dist,$prereqs);return Menlo::Dependency->from_prereqs($prereqs,$dist->{want_phases},$self->{install_types})}sub adjust_prereqs {my($self,$dist,$prereqs)=@_;if (-e "inc/Module/Install.pm"){for my$phase (qw(build test runtime)){my$reqs=$prereqs->requirements_for($phase,'requires');if ($reqs->requirements_for_module('ExtUtils::MakeMaker')){$reqs->clear_requirement('ExtUtils::MakeMaker');$reqs->add_minimum('ExtUtils::MakeMaker'=>0)}}}if ($dist->{static_install}){my$reqs=$prereqs->requirements_for('test'=>'requires');$reqs->add_minimum('TAP::Harness::Env'=>0)}}sub cleanup_workdirs {my$self=shift;my$expire=time - 24 * 60 * 60 * $self->{auto_cleanup};my@targets;opendir my$dh,"$self->{home}/work";while (my$e=readdir$dh){next if$e !~ /^(\d+)\.\d+$/;my$time=$1;if ($time < $expire){push@targets,"$self->{home}/work/$e"}}if (@targets){if (@targets >= 64){$self->diag("Expiring " .scalar(@targets)." work directories. This might take a while...\n")}else {$self->chat("Expiring " .scalar(@targets)." work directories.\n")}File::Path::rmtree(\@targets,0,0)}}sub scandeps_append_child {my($self,$dist)=@_;my$new_node=[$dist,[]];my$curr_node=$self->{scandeps_current}|| [undef,$self->{scandeps_tree}];push @{$curr_node->[1]},$new_node;$self->{scandeps_current}=$new_node;return sub {$self->{scandeps_current}=$curr_node}}sub dump_scandeps {my$self=shift;if ($self->{format}eq 'tree'){$self->walk_down(sub {my($dist,$depth)=@_;if ($depth==0){print "$dist->{distvname}\n"}else {print " " x ($depth - 1);print "\\_ $dist->{distvname}\n"}},1)}elsif ($self->{format}=~ /^dists?$/){$self->walk_down(sub {my($dist,$depth)=@_;print$self->format_dist($dist),"\n"},0)}elsif ($self->{format}eq 'json'){require JSON::PP;print JSON::PP::encode_json($self->{scandeps_tree})}elsif ($self->{format}eq 'yaml'){require CPAN::Meta::YAML;print CPAN::Meta::YAML::Dump($self->{scandeps_tree})}else {$self->diag("Unknown format: $self->{format}\n")}}sub walk_down {my($self,$cb,$pre)=@_;$self->_do_walk_down($self->{scandeps_tree},$cb,0,$pre)}sub _do_walk_down {my($self,$children,$cb,$depth,$pre)=@_;for my$node (@$children){$cb->($node->[0],$depth)if$pre;$self->_do_walk_down($node->[1],$cb,$depth + 1,$pre);$cb->($node->[0],$depth)unless$pre}}sub DESTROY {my$self=shift;$self->{at_exit}->($self)if$self->{at_exit}}sub mirror {my($self,$uri,$local)=@_;if ($uri =~ /^file:/){$self->file_mirror($uri,$local)}else {$self->{http}->mirror($uri,$local)}}sub untar {$_[0]->{_backends}{untar}->(@_)};sub unzip {$_[0]->{_backends}{unzip}->(@_)};sub uri_to_file {my($self,$uri)=@_;if ($uri =~ s!file:/+!!){$uri="/$uri" unless$uri =~ m![a-zA-Z]:!}return$uri}sub file_get {my($self,$uri)=@_;my$file=$self->uri_to_file($uri);open my$fh,"<$file" or return;join '',<$fh>}sub file_mirror {my($self,$uri,$path)=@_;my$file=$self->uri_to_file($uri);my$source_mtime=(stat$file)[9];return 1 if -e $path && (stat$path)[9]>= $source_mtime;File::Copy::copy($file,$path);utime$source_mtime,$source_mtime,$path}sub configure_http {my$self=shift;require HTTP::Tinyish;my@try=qw(HTTPTiny);unshift@try,'Wget' if$self->{try_wget};unshift@try,'Curl' if$self->{try_curl};unshift@try,'LWP' if$self->{try_lwp};my@protocol=('http');push@protocol,'https' if grep /^https:/,@{$self->{mirrors}};my$backend;for my$try (map "HTTP::Tinyish::$_",@try){if (my$meta=HTTP::Tinyish->configure_backend($try)){if ((grep$try->supports($_),@protocol)==@protocol){for my$tool (sort keys %$meta){(my$desc=$meta->{$tool})=~ s/^(.*?)\n.*/$1/s;$self->chat("You have $tool: $desc\n")}$backend=$try;last}}}$backend->new(agent=>"Menlo/$Menlo::VERSION",verify_SSL=>1)}sub init_tools {my$self=shift;return if$self->{initialized}++;if ($self->{make}=which($Config{make})){$self->chat("You have make $self->{make}\n")}$self->{http}=$self->configure_http;my$tar=which('tar');my$tar_ver;my$maybe_bad_tar=sub {WIN32 || BAD_TAR || (($tar_ver=`@{[ qs $tar ]} --version 2>/dev/null`)=~ /GNU.*1\.13/i)};if ($tar &&!$maybe_bad_tar->()){chomp$tar_ver;$self->chat("You have $tar: $tar_ver\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$xf=($self->{verbose}? 'v' : '')."xf";my$ar=$tarfile =~ /bz2$/ ? 'j' : 'z';my($root,@others)=`@{[ qs $tar ]} ${ar}tf @{[ qs $tarfile ]}` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$self->run_command([$tar,$ar.$xf,$tarfile ]);return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif ($tar and my$gzip=which('gzip')and my$bzip2=which('bzip2')){$self->chat("You have $tar, $gzip and $bzip2\n");$self->{_backends}{untar}=sub {my($self,$tarfile)=@_;my$x="x" .($self->{verbose}? 'v' : '')."f -";my$ar=$tarfile =~ /bz2$/ ? $bzip2 : $gzip;my($root,@others)=`@{[ qs $ar ]} -dc @{[ qs $tarfile ]} | @{[ qs $tar ]} tf -` or return undef;FILE: {chomp$root;$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}system "@{[ qs $ar ]} -dc @{[ qs $tarfile ]} | @{[ qs $tar ]} $x";return$root if -d $root;$self->diag_fail("Bad archive: $tarfile");return undef}}elsif (eval {require Archive::Tar}){$self->chat("Falling back to Archive::Tar $Archive::Tar::VERSION\n");$self->{_backends}{untar}=sub {my$self=shift;my$t=Archive::Tar->new($_[0]);my($root,@others)=$t->list_files;FILE: {$root =~ s!^\./!!;$root =~ s{^(.+?)/.*$}{$1};if (!length($root)){$root=shift(@others);redo FILE if$root}}$t->extract;return -d $root ? $root : undef}}else {$self->{_backends}{untar}=sub {die "Failed to extract $_[1] - You need to have tar or Archive::Tar installed.\n"}}if (my$unzip=which('unzip')){$self->chat("You have $unzip\n");$self->{_backends}{unzip}=sub {my($self,$zipfile)=@_;my@opt=$self->{verbose}? (): ('-q');my(undef,$root,@others)=`@{[ qs $unzip ]} -t @{[ qs $zipfile ]}` or return undef;FILE: {chomp$root;if ($root !~ s{^\s+testing:\s+([^/]+)/.*?\s+OK$}{$1}){$root=shift(@others);redo FILE if$root}}$self->run_command([$unzip,@opt,$zipfile ]);return$root if -d $root;$self->diag_fail("Bad archive: '$root' $zipfile");return undef}}else {$self->{_backends}{unzip}=sub {eval {require Archive::Zip}or die "Failed to extract $_[1] - You need to have unzip or Archive::Zip installed.\n";my($self,$file)=@_;my$zip=Archive::Zip->new();my$status;$status=$zip->read($file);$self->diag_fail("Read of file '$file' failed")if$status!=Archive::Zip::AZ_OK();my@members=$zip->members();for my$member (@members){my$af=$member->fileName();next if ($af =~ m!^(/|\.\./)!);$status=$member->extractToFileNamed($af);$self->diag_fail("Extracting of file 'af' from zipfile '$file' failed")if$status!=Archive::Zip::AZ_OK()}my ($root)=$zip->membersMatching(qr<^[^/]+/$>);$root &&= $root->fileName;return -d $root ? $root : undef}}}sub mask_uri_passwords {my($self,@strings)=@_;s{ (https?://) ([^:/]+) : [^@/]+ @ }{$1$2:********@}gx for@strings;return@strings}1;
  It appears your cpanm executable was installed via `perlbrew install-cpanm`.
  cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
  Run the following command to get it upgraded.
  
    perlbrew install-cpanm
  
  DIE
  You are running cpanm from the path where your current perl won't install executables to.
  Because of that, cpanm --self-upgrade won't upgrade the version of cpanm you're running.
  
    cpanm path   : $0
    Install path : $Config{installsitebin}
  
  It means you either installed cpanm globally with system perl, or use distro packages such
  as rpm or apt-get, and you have to use them again to upgrade cpanm.
  DIE
  Usage: cpanm [options] Module [...]
  
  Try `cpanm --help` or `man cpanm` for more options.
  USAGE
  Usage: cpanm [options] Module [...]
  
  Options:
    -v,--verbose              Turns on chatty output
    -q,--quiet                Turns off the most output
    --interactive             Turns on interactive configure (required for Task:: modules)
    -f,--force                force install
    -n,--notest               Do not run unit tests
    --test-only               Run tests only, do not install
    -S,--sudo                 sudo to run install commands
    --installdeps             Only install dependencies
    --showdeps                Only display direct dependencies
    --reinstall               Reinstall the distribution even if you already have the latest version installed
    --mirror                  Specify the base URL for the mirror (e.g. http://cpan.cpantesters.org/)
    --mirror-only             Use the mirror's index file instead of the CPAN Meta DB
    -M,--from                 Use only this mirror base URL and its index file
    --prompt                  Prompt when configure/build/test fails
    -l,--local-lib            Specify the install base to install modules
    -L,--local-lib-contained  Specify the install base to install all non-core modules
    --self-contained          Install all non-core modules, even if they're already installed.
    --auto-cleanup            Number of days that cpanm's work directories expire in. Defaults to 7
  
  Commands:
    --self-upgrade            upgrades itself
    --info                    Displays distribution info on CPAN
    --look                    Opens the distribution with your SHELL
    -U,--uninstall            Uninstalls the modules (EXPERIMENTAL)
    -V,--version              Displays software version
  
  Examples:
  
    cpanm Test::More                                          # install Test::More
    cpanm MIYAGAWA/Plack-0.99_05.tar.gz                       # full distribution path
    cpanm http://example.org/LDS/CGI.pm-3.20.tar.gz           # install from URL
    cpanm ~/dists/MyCompany-Enterprise-1.00.tar.gz            # install from a local file
    cpanm --interactive Task::Kensho                          # Configure interactively
    cpanm .                                                   # install from local directory
    cpanm --installdeps .                                     # install all the deps for the current directory
    cpanm -L extlib Plack                                     # install Plack and all non-core deps into extlib
    cpanm --mirror http://cpan.cpantesters.org/ DBI           # use the fast-syncing mirror
    cpanm -M https://cpan.metacpan.org App::perlbrew          # use only this secure mirror and its index
  
  You can also specify the default options in PERL_CPANM_OPT environment variable in the shell rc:
  
    export PERL_CPANM_OPT="--prompt --reinstall -l ~/perl --mirror http://cpan.cpantesters.org"
  
  Type `man cpanm` or `perldoc cpanm` for the more detailed explanation of the options.
  
  HELP
  !
  ! Can't write to $Config{installsitelib} and $Config{installsitebin}: Installing modules to $ENV{HOME}/perl5
  ! To turn off this warning, you have to do one of the following:
  !   - run me as a root or with --sudo option (to install to $Config{installsitelib} and $Config{installsitebin})
  !   - Configure local::lib in your existing shell to set PERL_MM_OPT etc.
  !   - Install local::lib by running the following commands
  !
  !         cpanm --local-lib=~/perl5 local::lib && eval \$(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
  !
  DIAG
  WARNING: Your lib directory name ($base) contains a space in it. It's known to cause issues with perl builder tools such as local::lib and MakeMaker. You're recommended to rename your directory.
  WARN
  $module is not found in the following directories and can't be uninstalled.
  
  @{[ join("  \n", map "  $_", @inc) ]}
  
  DIAG
  ! Configuring $distname failed. See $self->{log} for details.
  ! You might have to install the following modules first to get --scandeps working correctly.
  DIAG
MENLO_CLI_COMPAT

$fatpacked{"Menlo/Dependency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_DEPENDENCY';
  package Menlo::Dependency;use strict;use CPAN::Meta::Requirements;use Class::Tiny qw(module version type original_version dist mirror url);sub BUILDARGS {my($class,$module,$version,$type)=@_;return {module=>$module,version=>$version,type=>$type || 'requires',}}sub from_prereqs {my($class,$prereqs,$phases,$types)=@_;my@deps;for my$type (@$types){push@deps,$class->from_versions($prereqs->merged_requirements($phases,[$type])->as_string_hash,$type,)}return@deps}sub from_versions {my($class,$versions,$type)=@_;my@deps;while (my($module,$version)=each %$versions){push@deps,$class->new($module,$version,$type)}@deps}sub merge_with {my($self,$requirements)=@_;$self->original_version($self->version);eval {$requirements->add_string_requirement($self->module,$self->version)};if ($@ =~ /illegal requirements/){warn sprintf("Can't merge requirements for %s: '%s' and '%s'",$self->module,$self->version,$requirements->requirements_for_module($self->module))}$self->version($requirements->requirements_for_module($self->module))}sub requires_version {my$self=shift;if (defined$self->original_version){return$self->original_version}$self->version}sub is_requirement {$_[0]->type eq 'requires'}1;
MENLO_DEPENDENCY

$fatpacked{"Menlo/Index/MetaCPAN.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_METACPAN';
  use 5.008001;use strict;use warnings;package Menlo::Index::MetaCPAN;use parent 'CPAN::Common::Index';use Class::Tiny qw/uri include_dev/;use Carp;use HTTP::Tinyish;use JSON::PP ();use Time::Local ();sub BUILD {my$self=shift;my$uri=$self->uri;$uri="https://fastapi.metacpan.org/v1/download_url/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';my$range;if ($args->{version}){$range="== $args->{version}"}elsif ($args->{version_range}){$range=$args->{version_range}}my%query=(($self->include_dev ? (dev=>1): ()),($range ? (version=>$range): ()),);my$query=join "&",map {"$_=" .$self->_uri_escape($query{$_})}sort keys%query;my$uri=$self->uri .$args->{package}.($query ? "?$query" : "");my$res=HTTP::Tinyish->new->get($uri);return unless$res->{success};my$dist_meta=eval {JSON::PP::decode_json($res->{content})};if ($dist_meta && $dist_meta->{download_url}){(my$distfile=$dist_meta->{download_url})=~ s!.+/authors/id/\w/\w\w/!!;return {package=>$args->{package},version=>$dist_meta->{version},uri=>"cpan:///distfile/$distfile",download_uri=>$self->_download_uri("http://cpan.metacpan.org",$distfile),}}return}sub _parse_date {my($self,$date)=@_;my@date=$date =~ /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d):(\d\d)$/;Time::Local::timegm($date[5],$date[4],$date[3],$date[2],$date[1]- 1,$date[0]- 1900)}sub _uri_escape {my($self,$string)=@_;$string =~ s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;$string}sub _download_uri {my($self,$base,$distfile)=@_;join "/",$base,"authors/id",substr($distfile,0,1),substr($distfile,0,2),$distfile}sub index_age {return time}sub search_authors {return}1;
MENLO_INDEX_METACPAN

$fatpacked{"Menlo/Index/MetaDB.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_METADB';
  use 5.008001;use strict;use warnings;package Menlo::Index::MetaDB;our$VERSION="1.9019";use parent 'CPAN::Common::Index';use Class::Tiny qw/uri/;use Carp;use CPAN::Meta::YAML;use CPAN::Meta::Requirements;use HTTP::Tiny;sub BUILD {my$self=shift;my$uri=$self->uri;$uri="http://cpanmetadb.plackperl.org/v1.0/" unless defined$uri;$uri =~ s{/?$}{/};$self->uri($uri);return}sub search_packages {my ($self,$args)=@_;Carp::croak("Argument to search_packages must be hash reference")unless ref$args eq 'HASH';return unless exists$args->{package}&& ref$args->{package}eq '';my$mod=$args->{package};if ($args->{version}|| $args->{version_range}){my$res=HTTP::Tiny->new->get($self->uri ."history/$mod");return unless$res->{success};my$range=defined$args->{version}? "== $args->{version}" : $args->{version_range};my$reqs=CPAN::Meta::Requirements->from_string_hash({$mod=>$range });my@found;for my$line (split /\r?\n/,$res->{content}){if ($line =~ /^$mod\s+(\S+)\s+(\S+)$/){push@found,{version=>$1,version_o=>version::->parse($1),distfile=>$2,}}}return unless@found;$found[-1]->{latest}=1;my$match;for my$try (sort {$b->{version_o}<=> $a->{version_o}}@found){if ($reqs->accepts_module($mod=>$try->{version_o})){$match=$try,last}}if ($match){my$file=$match->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$match->{version},uri=>"cpan:///distfile/$file",($match->{latest}? (): (download_uri=>"http://backpan.perl.org/authors/id/$match->{distfile}")),}}}else {my$res=HTTP::Tiny->new->get($self->uri ."package/$mod");return unless$res->{success};if (my$yaml=CPAN::Meta::YAML->read_string($res->{content})){my$meta=$yaml->[0];if ($meta && $meta->{distfile}){my$file=$meta->{distfile};$file =~ s{^./../}{};return {package=>$mod,version=>$meta->{version},uri=>"cpan:///distfile/$file",}}}}return}sub index_age {return time};sub search_authors {return};1;
MENLO_INDEX_METADB

$fatpacked{"Menlo/Index/Mirror.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_INDEX_MIRROR';
  package Menlo::Index::Mirror;use strict;use parent qw(CPAN::Common::Index::Mirror);use Class::Tiny qw(fetcher);use File::Basename ();use File::Spec ();use URI ();our$HAS_IO_UNCOMPRESS_GUNZIP=eval {require IO::Uncompress::Gunzip};my%INDICES=(packages=>'modules/02packages.details.txt.gz',);sub refresh_index {my$self=shift;for my$file (values%INDICES){my$remote=URI->new_abs($file,$self->mirror);$remote =~ s/\.gz$// unless$HAS_IO_UNCOMPRESS_GUNZIP;my$local=File::Spec->catfile($self->cache,File::Basename::basename($file));$self->fetcher->($remote,$local)or Carp::croak("Cannot fetch $remote to $local");if ($HAS_IO_UNCOMPRESS_GUNZIP){(my$uncompressed=$local)=~ s/\.gz$//;IO::Uncompress::Gunzip::gunzip($local,$uncompressed)or Carp::croak "gunzip failed: $IO::Uncompress::Gunzip::GunzipError\n"}}}1;
MENLO_INDEX_MIRROR

$fatpacked{"Menlo/Legacy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_LEGACY';
  package Menlo::Legacy;use strict;our$VERSION='1.9022';1;
MENLO_LEGACY

$fatpacked{"Menlo/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MENLO_UTIL';
  package Menlo::Util;use strict;use Exporter;our@ISA=qw(Exporter);our@EXPORT_OK=qw(WIN32);use constant WIN32=>$^O eq 'MSWin32';if (WIN32){require Win32::ShellQuote;*shell_quote=\&Win32::ShellQuote::quote_native}else {require String::ShellQuote;*shell_quote=\&String::ShellQuote::shell_quote_best_effort}1;
MENLO_UTIL

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.039';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared },catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Module/CPANfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE';
  package Module::CPANfile;use strict;use warnings;use Cwd;use Carp ();use Module::CPANfile::Environment;use Module::CPANfile::Requirement;our$VERSION='1.1004';BEGIN {if (${^TAINT}){*untaint=sub {my$str=shift;($str)=$str =~ /^(.+)$/s;$str}}else {*untaint=sub {$_[0]}}}sub new {my($class,$file)=@_;bless {},$class}sub load {my($proto,$file)=@_;my$self=ref$proto ? $proto : $proto->new;$self->parse($file || _default_cpanfile());$self}sub save {my($self,$path)=@_;open my$out,">",$path or die "$path: $!";print {$out}$self->to_string}sub parse {my($self,$file)=@_;my$code=do {open my$fh,"<",$file or die "$file: $!";join '',<$fh>};$code=untaint$code;my$env=Module::CPANfile::Environment->new($file);$env->parse($code)or die $@;$self->{_mirrors}=$env->mirrors;$self->{_prereqs}=$env->prereqs}sub from_prereqs {my($proto,$prereqs)=@_;my$self=$proto->new;$self->{_prereqs}=Module::CPANfile::Prereqs->from_cpan_meta($prereqs);$self}sub mirrors {my$self=shift;$self->{_mirrors}|| []}sub features {my$self=shift;map$self->feature($_),$self->{_prereqs}->identifiers}sub feature {my($self,$identifier)=@_;$self->{_prereqs}->feature($identifier)}sub prereq {shift->prereqs}sub prereqs {my$self=shift;$self->{_prereqs}->as_cpan_meta}sub merged_requirements {my$self=shift;$self->{_prereqs}->merged_requirements}sub effective_prereqs {my($self,$features)=@_;$self->prereqs_with(@{$features || []})}sub prereqs_with {my($self,@feature_identifiers)=@_;my@others=map {$self->feature($_)->prereqs}@feature_identifiers;$self->prereqs->with_merged_prereqs(\@others)}sub prereq_specs {my$self=shift;$self->prereqs->as_string_hash}sub prereq_for_module {my($self,$module)=@_;$self->{_prereqs}->find($module)}sub options_for_module {my($self,$module)=@_;my$prereq=$self->prereq_for_module($module)or return;$prereq->requirement->options}sub merge_meta {my($self,$file,$version)=@_;require CPAN::Meta;$version ||= $file =~ /\.yml$/ ? '1.4' : '2';my$prereq=$self->prereqs;my$meta=CPAN::Meta->load_file($file);my$prereqs_hash=$prereq->with_merged_prereqs($meta->effective_prereqs)->as_string_hash;my$struct={%{$meta->as_struct},prereqs=>$prereqs_hash };CPAN::Meta->new($struct)->save($file,{version=>$version })}sub _d($) {require Data::Dumper;chomp(my$value=Data::Dumper->new([$_[0]])->Terse(1)->Dump);$value}sub _default_cpanfile {my$file=Cwd::abs_path('cpanfile');untaint$file}sub to_string {my($self,$include_empty)=@_;my$mirrors=$self->mirrors;my$prereqs=$self->prereq_specs;my$code='';$code .= $self->_dump_mirrors($mirrors);$code .= $self->_dump_prereqs($prereqs,$include_empty);for my$feature ($self->features){$code .= "feature @{[ _d $feature->{identifier} ]}, @{[ _d $feature->{description} ]} => sub {\n";$code .= $self->_dump_prereqs($feature->{prereqs}->as_string_hash,$include_empty,4);$code .= "};\n\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_mirrors {my($self,$mirrors)=@_;my$code="";for my$url (@$mirrors){$code .= "mirror @{[ _d $url ]};\n"}$code =~ s/\n+$/\n/s;$code}sub _dump_prereqs {my($self,$prereqs,$include_empty,$base_indent)=@_;my$code='';for my$phase (qw(runtime configure build test develop)){my$indent=$phase eq 'runtime' ? '' : '    ';$indent .= (' ' x ($base_indent || 0));my($phase_code,$requirements);$phase_code .= "on $phase => sub {\n" unless$phase eq 'runtime';for my$type (qw(requires recommends suggests conflicts)){for my$mod (sort keys %{$prereqs->{$phase}{$type}}){my$ver=$prereqs->{$phase}{$type}{$mod};$phase_code .= $ver eq '0' ? "${indent}$type @{[ _d $mod ]}" : "${indent}$type @{[ _d $mod ]}, @{[ _d $ver ]}";my$options=$self->options_for_module($mod)|| {};if (%$options){my@opts;for my$key (keys %$options){my$k=$key =~ /^[a-zA-Z0-9_]+$/ ? $key : _d$key;push@opts,"$k => @{[ _d $options->{$k} ]}"}$phase_code .= ",\n" .join(",\n",map "  $indent$_",@opts)}$phase_code .= ";\n";$requirements++}}$phase_code .= "\n" unless$requirements;$phase_code .= "};\n" unless$phase eq 'runtime';$code .= $phase_code ."\n" if$requirements or $include_empty}$code =~ s/\n+$/\n/s;$code}1;
MODULE_CPANFILE

$fatpacked{"Module/CPANfile/Environment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_ENVIRONMENT';
  package Module::CPANfile::Environment;use strict;use warnings;use Module::CPANfile::Prereqs;use Carp ();my@bindings=qw(on requires recommends suggests conflicts feature osname mirror configure_requires build_requires test_requires author_requires);my$file_id=1;sub new {my($class,$file)=@_;bless {file=>$file,phase=>'runtime',feature=>undef,features=>{},prereqs=>Module::CPANfile::Prereqs->new,mirrors=>[],},$class}sub bind {my$self=shift;my$pkg=caller;for my$binding (@bindings){no strict 'refs';*{"$pkg\::$binding"}=sub {$self->$binding(@_)}}}sub parse {my($self,$code)=@_;my$err;{local $@;$file_id++;$self->_evaluate(<<EVAL);$err=$@}if ($err){die "Parsing $self->{file} failed: $err"};return 1}sub _evaluate {my$_environment=$_[0];eval $_[1]}sub prereqs {$_[0]->{prereqs}}sub mirrors {$_[0]->{mirrors}}sub on {my($self,$phase,$code)=@_;local$self->{phase}=$phase;$code->()}sub feature {my($self,$identifier,$description,$code)=@_;if (@_==3 && ref($description)eq 'CODE'){$code=$description;$description=$identifier}unless (ref$description eq '' && ref$code eq 'CODE'){Carp::croak("Usage: feature 'identifier', 'Description' => sub { ... }")}local$self->{feature}=$identifier;$self->prereqs->add_feature($identifier,$description);$code->()}sub osname {die "TODO"}sub mirror {my($self,$url)=@_;push @{$self->{mirrors}},$url}sub requirement_for {my($self,$module,@args)=@_;my$requirement=0;$requirement=shift@args if@args % 2;return Module::CPANfile::Requirement->new(name=>$module,version=>$requirement,@args,)}sub requires {my$self=shift;$self->add_prereq(requires=>@_)}sub recommends {my$self=shift;$self->add_prereq(recommends=>@_)}sub suggests {my$self=shift;$self->add_prereq(suggests=>@_)}sub conflicts {my$self=shift;$self->add_prereq(conflicts=>@_)}sub add_prereq {my($self,$type,$module,@args)=@_;$self->prereqs->add(feature=>$self->{feature},phase=>$self->{phase},type=>$type,module=>$module,requirement=>$self->requirement_for($module,@args),)}sub configure_requires {my($self,@args)=@_;$self->on(configure=>sub {$self->requires(@args)})}sub build_requires {my($self,@args)=@_;$self->on(build=>sub {$self->requires(@args)})}sub test_requires {my($self,@args)=@_;$self->on(test=>sub {$self->requires(@args)})}sub author_requires {my($self,@args)=@_;$self->on(develop=>sub {$self->requires(@args)})}1;
  package Module::CPANfile::Sandbox$file_id;
  no warnings;
  BEGIN { \$_environment->bind }
  
  # line 1 "$self->{file}"
  $code;
  EVAL
MODULE_CPANFILE_ENVIRONMENT

$fatpacked{"Module/CPANfile/Prereq.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQ';
  package Module::CPANfile::Prereq;use strict;sub new {my($class,%options)=@_;bless \%options,$class}sub feature {$_[0]->{feature}}sub phase {$_[0]->{phase}}sub type {$_[0]->{type}}sub module {$_[0]->{module}}sub requirement {$_[0]->{requirement}}1;
MODULE_CPANFILE_PREREQ

$fatpacked{"Module/CPANfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_PREREQS';
  package Module::CPANfile::Prereqs;use strict;use Carp ();use CPAN::Meta::Feature;use Module::CPANfile::Prereq;sub from_cpan_meta {my($class,$prereqs)=@_;my$self=$class->new;for my$phase (keys %$prereqs){for my$type (keys %{$prereqs->{$phase}}){while (my($module,$requirement)=each %{$prereqs->{$phase}{$type}}){$self->add(phase=>$phase,type=>$type,module=>$module,requirement=>Module::CPANfile::Requirement->new(name=>$module,version=>$requirement),)}}}$self}sub new {my$class=shift;bless {prereqs=>{},features=>{},},$class}sub add_feature {my($self,$identifier,$description)=@_;$self->{features}{$identifier}={description=>$description }}sub add {my($self,%args)=@_;my$feature=$args{feature}|| '';push @{$self->{prereqs}{$feature}},Module::CPANfile::Prereq->new(%args)}sub as_cpan_meta {my$self=shift;$self->{cpanmeta}||= $self->build_cpan_meta}sub build_cpan_meta {my($self,$feature)=@_;CPAN::Meta::Prereqs->new($self->specs($feature))}sub specs {my($self,$feature)=@_;$feature='' unless defined$feature;my$prereqs=$self->{prereqs}{$feature}|| [];my$specs={};for my$prereq (@$prereqs){$specs->{$prereq->phase}{$prereq->type}{$prereq->module}=$prereq->requirement->version}return$specs}sub merged_requirements {my$self=shift;my$reqs=CPAN::Meta::Requirements->new;for my$prereq (@{$self->{prereqs}}){$reqs->add_string_requirement($prereq->module,$prereq->requirement->version)}$reqs}sub find {my($self,$module)=@_;for my$feature ('',keys %{$self->{features}}){for my$prereq (@{$self->{prereqs}{$feature}}){return$prereq if$prereq->module eq $module}}return}sub identifiers {my$self=shift;keys %{$self->{features}}}sub feature {my($self,$identifier)=@_;my$data=$self->{features}{$identifier}or Carp::croak("Unknown feature '$identifier'");my$prereqs=$self->build_cpan_meta($identifier);CPAN::Meta::Feature->new($identifier,{description=>$data->{description},prereqs=>$prereqs->as_string_hash,})}1;
MODULE_CPANFILE_PREREQS

$fatpacked{"Module/CPANfile/Requirement.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPANFILE_REQUIREMENT';
  package Module::CPANfile::Requirement;use strict;sub new {my ($class,%args)=@_;$args{version}||= 0;bless +{name=>delete$args{name},version=>delete$args{version},options=>\%args,},$class}sub name {$_[0]->{name}}sub version {$_[0]->{version}}sub options {$_[0]->{options}}sub has_options {keys %{$_[0]->{options}}> 0}1;
MODULE_CPANFILE_REQUIREMENT

$fatpacked{"Module/Pluggable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE';
  package Module::Pluggable;use strict;use vars qw($VERSION $FORCE_SEARCH_ALL_PATHS);use Module::Pluggable::Object;use if $] > 5.017,'deprecate';$VERSION='5.2';$FORCE_SEARCH_ALL_PATHS=0;sub import {my$class=shift;my%opts=@_;my ($pkg,$file)=caller;my$sub=$opts{'sub_name'}|| 'plugins';my ($package)=$opts{'package'}|| $pkg;$opts{filename}=$file;$opts{package}=$package;$opts{force_search_all_paths}=$FORCE_SEARCH_ALL_PATHS unless exists$opts{force_search_all_paths};my$finder=Module::Pluggable::Object->new(%opts);my$subroutine=sub {my$self=shift;return$finder->plugins(@_)};my$searchsub=sub {my$self=shift;my ($action,@paths)=@_;$finder->{'search_path'}=["${package}::Plugin"]if ($action eq 'add' and not $finder->{'search_path'});push @{$finder->{'search_path'}},@paths if ($action eq 'add');$finder->{'search_path'}=\@paths if ($action eq 'new');return$finder->{'search_path'}};my$onlysub=sub {my ($self,$only)=@_;if (defined$only){$finder->{'only'}=$only};return$finder->{'only'}};my$exceptsub=sub {my ($self,$except)=@_;if (defined$except){$finder->{'except'}=$except};return$finder->{'except'}};no strict 'refs';no warnings qw(redefine prototype);*{"$package\::$sub"}=$subroutine;*{"$package\::search_path"}=$searchsub;*{"$package\::only"}=$onlysub;*{"$package\::except"}=$exceptsub}1;
MODULE_PLUGGABLE

$fatpacked{"Module/Pluggable/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;use strict;use File::Find ();use File::Basename;use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);use Carp qw(croak carp confess);use Devel::InnerPackage;use vars qw($VERSION $MR);use if $] > 5.017,'deprecate';$VERSION='5.2';BEGIN {eval {require Module::Runtime};unless ($@){Module::Runtime->import('require_module')}else {*require_module=sub {my$module=shift;my$path=$module .".pm";$path =~ s{::}{/}g;require$path}}}sub new {my$class=shift;my%opts=@_;return bless \%opts,$class}sub plugins {my$self=shift;my@args=@_;$self->{'require'}=1 if$self->{'inner'};my$filename=$self->{'filename'};my$pkg=$self->{'package'};$self->_setup_exceptions;for (qw(search_path search_dirs)){$self->{$_}=[$self->{$_}]if exists$self->{$_}&&!ref($self->{$_})}$self->{'search_path'}||= ["${pkg}::Plugin"];$self->{'on_require_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't require $plugin : $err";return 0};$self->{'on_instantiate_error'}||= sub {my ($plugin,$err)=@_;carp "Couldn't instantiate $plugin: $err";return 0};$self->{'follow_symlinks'}=1 unless exists$self->{'follow_symlinks'};my@SEARCHDIR=exists$INC{"blib.pm"}&& defined$filename && $filename =~ m!(^|/)blib/! &&!$self->{'force_search_all_paths'}? grep {/blib/}@INC : @INC;unshift@SEARCHDIR,@{$self->{'search_dirs'}}if defined$self->{'search_dirs'};my@tmp=@INC;unshift@tmp,@{$self->{'search_dirs'}|| []};local@INC=@tmp if defined$self->{'search_dirs'};my@plugins=$self->search_directories(@SEARCHDIR);push(@plugins,$self->handle_inc_hooks($_,@SEARCHDIR))for @{$self->{'search_path'}};push(@plugins,$self->handle_innerpackages($_))for @{$self->{'search_path'}};return ()unless@plugins;my%plugins;for(@plugins){next unless$self->_is_legit($_);$plugins{$_}=1}if (defined$self->{'instantiate'}){my$method=$self->{'instantiate'};my@objs=();for my$package (sort keys%plugins){next unless$package->can($method);my$obj=eval {$package->$method(@_)};$self->{'on_instantiate_error'}->($package,$@)if $@;push@objs,$obj if$obj}return@objs}else {my@objs=sort keys%plugins;return@objs}}sub _setup_exceptions {my$self=shift;my%only;my%except;my$only;my$except;if (defined$self->{'only'}){if (ref($self->{'only'})eq 'ARRAY'){%only=map {$_=>1}@{$self->{'only'}}}elsif (ref($self->{'only'})eq 'Regexp'){$only=$self->{'only'}}elsif (ref($self->{'only'})eq ''){$only{$self->{'only'}}=1}}if (defined$self->{'except'}){if (ref($self->{'except'})eq 'ARRAY'){%except=map {$_=>1}@{$self->{'except'}}}elsif (ref($self->{'except'})eq 'Regexp'){$except=$self->{'except'}}elsif (ref($self->{'except'})eq ''){$except{$self->{'except'}}=1}}$self->{_exceptions}->{only_hash}=\%only;$self->{_exceptions}->{only}=$only;$self->{_exceptions}->{except_hash}=\%except;$self->{_exceptions}->{except}=$except}sub _is_legit {my$self=shift;my$plugin=shift;my%only=%{$self->{_exceptions}->{only_hash}||{}};my%except=%{$self->{_exceptions}->{except_hash}||{}};my$only=$self->{_exceptions}->{only};my$except=$self->{_exceptions}->{except};my$depth=()=split '::',$plugin,-1;return 0 if (keys%only &&!$only{$plugin});return 0 unless (!defined$only || $plugin =~ m!$only!);return 0 if (keys%except && $except{$plugin});return 0 if (defined$except && $plugin =~ m!$except!);return 0 if defined$self->{max_depth}&& $depth>$self->{max_depth};return 0 if defined$self->{min_depth}&& $depth<$self->{min_depth};return 1}sub search_directories {my$self=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){push@plugins,$self->search_paths($dir)}return@plugins}sub search_paths {my$self=shift;my$dir=shift;my@plugins;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;for my$searchpath (@{$self->{'search_path'}}){my$sp=catdir($dir,(split /::/,$searchpath));next unless (-e $sp && -d _);my@files=$self->find_files($sp);for my$file (@files){next unless ($file)=($file =~ /(.*$file_regex)$/);my ($name,$directory,$suffix)=fileparse($file,$file_regex);next if (!$self->{include_editor_junk}&& $self->_is_editor_junk($name));$directory=abs2rel($directory,$sp);my@pkg_dirs=();if ($name eq lc($name)|| $name eq uc($name)){my$pkg_file=catfile($sp,$directory,"$name$suffix");open PKGFILE,"<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";my$in_pod=0;while (my$line=<PKGFILE>){$in_pod=1 if$line =~ m/^=\w/;$in_pod=0 if$line =~ /^=cut/;next if ($in_pod || $line =~ /^=cut/);next if$line =~ /^\s*#/;if ($line =~ m/^\s*package\s+(.*::)?($name)\s*;/i){@pkg_dirs=split /::/,$1 if defined $1;;$name=$2;last}}close PKGFILE}$directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);my@dirs=();if ($directory){($directory)=($directory =~ /(.*)/);@dirs=grep(length($_),splitdir($directory))unless$directory eq curdir();for my$d (reverse@dirs){my$pkg_dir=pop@pkg_dirs;last unless defined$pkg_dir;$d =~ s/\Q$pkg_dir\E/$pkg_dir/i}}else {$directory=""}my$plugin=join '::',$searchpath,@dirs,$name;next unless$plugin =~ m!(?:[a-z\d]+)[a-z\d]*!i;$self->handle_finding_plugin($plugin,\@plugins)}push@plugins,$self->handle_innerpackages($searchpath)}return@plugins}sub _is_editor_junk {my$self=shift;my$name=shift;return 1 if$name =~ /~$/;return 1 if$name =~ /^\.#/;return 1 if$name =~ /\.sw[po]$/;return 0}sub handle_finding_plugin {my$self=shift;my$plugin=shift;my$plugins=shift;my$no_req=shift || 0;return unless$self->_is_legit($plugin);unless (defined$self->{'instantiate'}|| $self->{'require'}){push @$plugins,$plugin;return}$self->{before_require}->($plugin)|| return if defined$self->{before_require};unless ($no_req){my$tmp=$@;my$res=eval {require_module($plugin)};my$err=$@;$@=$tmp;if ($err){if (defined$self->{on_require_error}){$self->{on_require_error}->($plugin,$err)|| return}else {return}}}$self->{after_require}->($plugin)|| return if defined$self->{after_require};push @$plugins,$plugin}sub find_files {my$self=shift;my$search_path=shift;my$file_regex=$self->{'file_regex'}|| qr/\.pm$/;my@files=();{local $_;File::Find::find({no_chdir=>1,follow=>$self->{'follow_symlinks'},wanted=>sub {return unless$File::Find::name =~ /$file_regex/;(my$path=$File::Find::name)=~ s#^\\./##;push@files,$path}},$search_path)}return@files}sub handle_inc_hooks {my$self=shift;my$path=shift;my@SEARCHDIR=@_;my@plugins;for my$dir (@SEARCHDIR){next unless ref$dir && eval {$dir->can('files')};for my$plugin ($dir->files){$plugin =~ s/\.pm$//;$plugin =~ s{/}{::}g;next unless$plugin =~ m!^${path}::!;$self->handle_finding_plugin($plugin,\@plugins)}}return@plugins}sub handle_innerpackages {my$self=shift;return ()if (exists$self->{inner}&&!$self->{inner});my$path=shift;my@plugins;for my$plugin (Devel::InnerPackage::list_packages($path)){$self->handle_finding_plugin($plugin,\@plugins,1)}return@plugins}1;
MODULE_PLUGGABLE_OBJECT

$fatpacked{"Module/cpmfile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPMFILE';
  package Module::cpmfile;use 5.008001;use strict;use warnings;our$VERSION='0.005';use Module::cpmfile::Prereqs;use Module::cpmfile::Util qw(merge_version _yaml_hash);use YAML::PP ();sub load {my ($class,$file)=@_;my ($hash)=YAML::PP->new->load_file($file);$class->new($hash)}sub new {my ($class,$hash)=@_;my$prereqs=Module::cpmfile::Prereqs->new($hash->{prereqs});my%feature;for my$id (sort keys %{$hash->{features}|| +{}}){my$description=$hash->{features}{$id}{description};my$prereqs=Module::cpmfile::Prereqs->new($hash->{features}{$id}{prereqs});$feature{$id}={description=>$description,prereqs=>$prereqs }}bless {prereqs=>$prereqs,features=>\%feature,_mirrors=>[]},$class}sub from_cpanfile {my ($class,$cpanfile)=@_;my%feature;for my$feature ($cpanfile->features){my$id=$feature->{identifier};my$description=$feature->{description};my$prereqs=Module::cpmfile::Prereqs->from_cpanmeta($feature->{prereqs});$feature{$id}={description=>$description,prereqs=>$prereqs }}my$prereqs=Module::cpmfile::Prereqs->from_cpanmeta($cpanfile->prereqs);for my$p ($prereqs,map {$_->{prereqs}}values%feature){$p->walk(undef,undef,sub {my (undef,undef,$package,$original_options)=@_;my$additional_options=$cpanfile->options_for_module($package)|| +{};if (%$additional_options){%$original_options=(%$original_options,%$additional_options)}})}my$mirrors=$cpanfile->mirrors;bless {prereqs=>$prereqs,features=>\%feature,_mirrors=>$mirrors },$class}sub from_cpanmeta {my ($class,$cpanmeta)=@_;my%feature;for my$id (keys %{$cpanmeta->optional_features}){my$f=$cpanmeta->optional_features->{$id};my$description=$f->{description};my$prereqs=Module::cpmfile::Prereqs->from_cpanmeta($f->{prereqs});$feature{$id}={description=>$description,prereqs=>$prereqs }}my$prereqs=Module::cpmfile::Prereqs->from_cpanmeta($cpanmeta->prereqs);bless {prereqs=>$prereqs,features=>\%feature,_mirrors=>[]},$class}sub prereqs {my$self=shift;$self->{prereqs}}sub features {my$self=shift;if (%{$self->{features}}){return$self->{features}}return}sub _feature_prereqs {my ($self,$ids)=@_;my@prereqs;for my$id (@{$ids || []}){my$feature=$self->{features}{$id};next if!$feature ||!$feature->{prereqs};push@prereqs,$feature->{prereqs}}@prereqs}sub effective_requirements {my ($self,$feature_ids,$phases,$types)=@_;my%req;for my$prereqs ($self->{prereqs},$self->_feature_prereqs($feature_ids)){$prereqs->walk($phases,$types,sub {my (undef,undef,$package,$options)=@_;if (exists$req{$package}){my$v1=$req{$package}{version}|| 0;my$v2=$options->{version}|| 0;my$version=merge_version$v1,$v2;$req{$package}=+{%{$req{$package}},%$options,$version ? (version=>$version): (),}}else {$req{$package}=$options}})}\%req}sub to_string {my$self=shift;my@out;push@out,$self->prereqs->to_string;if (my$features=$self->features){push@out,"features:";for my$id (sort keys %$features){my$feature=$features->{$id};push@out,"  $id:";if (my$desc=$feature->{description}){push@out,_yaml_hash({description=>$desc },"    ")}if (my$prereqs=$feature->{prereqs}){push@out,$prereqs->to_string("    ")}}}(join "\n",@out)."\n"}1;
MODULE_CPMFILE

$fatpacked{"Module/cpmfile/Prereqs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPMFILE_PREREQS';
  package Module::cpmfile::Prereqs;use strict;use warnings;use CPAN::Meta::Prereqs;use Module::cpmfile::Util '_yaml_hash';use Scalar::Util 'blessed';my@PHASE=qw(runtime configure build test develop);my@TYPE=qw(requires recommends suggests);sub new {my$class=shift;my$hash=shift || +{};my$self=+{};for my$phase (@PHASE){for my$type (@TYPE){next if!$hash->{$phase}||!$hash->{$phase}{$type};for my$package (sort keys %{$hash->{$phase}{$type}}){$self->{$phase}{$type}{$package}=$hash->{$phase}{$type}{$package}|| +{}}}}bless$self,$class}sub from_cpanmeta {my ($class,$cpanmeta)=@_;my$hash=$cpanmeta;if (blessed$cpanmeta and $cpanmeta->isa('CPAN::Meta::Prereqs')){$hash=$cpanmeta->as_string_hash}my$out={};for my$phase (sort keys %$hash){for my$type (sort keys %{$hash->{$phase}}){for my$package (sort keys %{$hash->{$phase}{$type}}){my$version=$hash->{$phase}{$type}{$package};my$options=+{$version ? (version=>$version): ()};$out->{$phase}{$type}{$package}=$options}}}$class->new($out)}sub cpanmeta {my$self=shift;my$hash=+{};for my$phase (sort keys %$self){for my$type (sort keys %{$self->{$phase}}){for my$package (sort keys %{$self->{$phase}{$type}}){my$options=$self->{$phase}{$type}{$package};$hash->{$phase}{$type}{$package}=$options->{version}|| 0}}}CPAN::Meta::Prereqs->new($hash)}sub walk {my ($self,$phases,$types,$cb)=@_;$phases ||= \@PHASE;$types ||= \@TYPE;for my$phase (@$phases){for my$type (@$types){next if!$self->{$phase}||!$self->{$phase}{$type};for my$package (sort keys %{$self->{$phase}{$type}}){my$options=$self->{$phase}{$type}{$package};my$ret=$cb->($phase,$type,$package,$options);return if ref($ret)eq 'SCALAR' &&!$$ret}}}}sub to_string {my$self=shift;my$indent=shift || "";my@out;push@out,"prereqs:";for my$phase (@PHASE){my$spec1=$self->{$phase}or next;push@out,"  $phase:";for my$type (@TYPE){my$spec2=$spec1->{$type}or next;push@out,"    $type:";for my$package (sort keys %{$spec2}){if (my%option=%{$spec2->{$package}|| +{}}){my@key=keys%option;if (@key==1 && $key[0]eq "version"){push@out,"      $package: { version: '$option{version}' }"}else {push@out,"      $package:";push@out,_yaml_hash(\%option,"        ")}}else {push@out,"      $package:"}}}}join "\n",map {"$indent$_"}@out}1;
MODULE_CPMFILE_PREREQS

$fatpacked{"Module/cpmfile/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_CPMFILE_UTIL';
  package Module::cpmfile::Util;use strict;use warnings;use CPAN::Meta::Requirements;use Exporter 'import';our@EXPORT_OK=qw(merge_version _yaml_hash);my$TEST_PACKAGE='__TEST_PACKAGE__';sub merge_version {my ($v1,$v2)=@_;my$r=CPAN::Meta::Requirements->new;$r->add_string_requirement($TEST_PACKAGE,$v1)if defined$v1;$r->add_string_requirement($TEST_PACKAGE,$v2)if defined$v2;$r->requirements_for_module($TEST_PACKAGE)}{my$YAML;sub _yaml_hash {my ($hash,$indent)=@_;$YAML ||= do {require YAML::PP;YAML::PP->new(header=>0)};my@string=split /\n/,$YAML->dump_string($hash);map {"$indent$_"}@string}}1;
MODULE_CPMFILE_UTIL

$fatpacked{"Parallel/Pipes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARALLEL_PIPES';
  package Parallel::Pipes;use 5.008001;use strict;use warnings;use IO::Handle;use IO::Select;use constant WIN32=>$^O eq 'MSWin32';our$VERSION='0.005';{package Parallel::Pipe::Impl;use Storable ();sub new {my ($class,%option)=@_;my$read_fh=delete$option{read_fh}or die;my$write_fh=delete$option{write_fh}or die;$write_fh->autoflush(1);bless {%option,read_fh=>$read_fh,write_fh=>$write_fh,buf=>'' },$class}sub read :method {my$self=shift;my$_size=$self->_read(4)or return;my$size=unpack 'I',$_size;my$freezed=$self->_read($size);Storable::thaw($freezed)}sub write :method {my ($self,$data)=@_;my$freezed=Storable::freeze({data=>$data});my$size=pack 'I',length($freezed);$self->_write("$size$freezed")}sub _read {my ($self,$size)=@_;my$fh=$self->{read_fh};my$offset=length$self->{buf};while ($offset < $size){my$len=sysread$fh,$self->{buf},65536,$offset;if (!defined$len){die $!}elsif ($len==0){last}else {$offset += $len}}return substr$self->{buf},0,$size,''}sub _write {my ($self,$data)=@_;my$fh=$self->{write_fh};my$size=length$data;my$offset=0;while ($size){my$len=syswrite$fh,$data,$size,$offset;if (!defined$len){die $!}elsif ($len==0){last}else {$size -= $len;$offset += $len}}$size}}{package Parallel::Pipe::Here;our@ISA=qw(Parallel::Pipe::Impl);use Carp ();sub new {my ($class,%option)=@_;$class->SUPER::new(%option,_written=>0)}sub is_written {my$self=shift;$self->{_written}==1}sub read :method {my$self=shift;if (!$self->is_written){Carp::croak("This pipe has not been written; you cannot read it")}$self->{_written}--;return unless my$read=$self->SUPER::read;$read->{data}}sub write :method {my ($self,$task)=@_;if ($self->is_written){Carp::croak("This pipe has already been written; you must read it first")}$self->{_written}++;$self->SUPER::write($task)}}{package Parallel::Pipe::There;our@ISA=qw(Parallel::Pipe::Impl)}{package Parallel::Pipe::Impl::NoFork;use Carp ();sub new {my ($class,%option)=@_;bless {%option},$class}sub is_written {my$self=shift;exists$self->{_result}}sub read :method {my$self=shift;if (!$self->is_written){Carp::croak("This pipe has not been written; you cannot read it")}delete$self->{_result}}sub write :method {my ($self,$task)=@_;if ($self->is_written){Carp::croak("This pipe has already been written; you must read it first")}my$result=$self->{code}->($task);$self->{_result}=$result}}sub new {my ($class,$number,$code)=@_;if (WIN32 and $number!=1){die "The number of pipes must be 1 under WIN32 environment.\n"}my$self=bless {code=>$code,number=>$number,no_fork=>$number==1,pipes=>{},},$class;if ($self->no_fork){$self->{pipes}{-1}=Parallel::Pipe::Impl::NoFork->new(code=>$self->{code})}else {$self->_fork for 1 .. $number}$self}sub no_fork {shift->{no_fork}}sub _fork {my$self=shift;my$code=$self->{code};pipe my$read_fh1,my$write_fh1;pipe my$read_fh2,my$write_fh2;my$pid=fork;die "fork failed" unless defined$pid;if ($pid==0){srand;close $_ for$read_fh1,$write_fh2,map {($_->{read_fh},$_->{write_fh})}$self->pipes;my$there=Parallel::Pipe::There->new(read_fh=>$read_fh2,write_fh=>$write_fh1);while (my$read=$there->read){$there->write($code->($read->{data}))}exit}close $_ for$write_fh1,$read_fh2;$self->{pipes}{$pid}=Parallel::Pipe::Here->new(pid=>$pid,read_fh=>$read_fh1,write_fh=>$write_fh2,)}sub pipes {my$self=shift;map {$self->{pipes}{$_}}sort {$a <=> $b}keys %{$self->{pipes}}}sub is_ready {my$self=shift;return$self->pipes if$self->no_fork;my@pipes=@_ ? @_ : $self->pipes;if (my@ready=grep {$_->{_written}==0}@pipes){return@ready}my$select=IO::Select->new(map {$_->{read_fh}}@pipes);my@ready=$select->can_read;my@return;for my$pipe (@pipes){if (grep {$pipe->{read_fh}==$_}@ready){push@return,$pipe}}return@return}sub is_written {my$self=shift;grep {$_->is_written}$self->pipes}sub close :method {my$self=shift;return if$self->no_fork;close $_ for map {($_->{write_fh},$_->{read_fh})}$self->pipes;while (%{$self->{pipes}}){my$pid=wait;if (delete$self->{pipes}{$pid}){}else {warn "wait() unexpectedly returns $pid\n"}}}1;
PARALLEL_PIPES

$fatpacked{"Parse/PMFile.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PARSE_PMFILE';
  package Parse::PMFile;sub __clean_eval {eval $_[0]}use strict;use warnings;use Safe;use JSON::PP ();use Dumpvalue;use version ();use File::Spec ();our$VERSION='0.43';our$VERBOSE=0;our$ALLOW_DEV_VERSION=0;our$FORK=0;our$UNSAFE=$] < 5.010000 ? 1 : 0;sub new {my ($class,$meta,$opts)=@_;bless {%{$opts || {}},META_CONTENT=>$meta},$class}sub parse {my ($self,$pmfile)=@_;$pmfile =~ s|\\|/|g;my($filemtime)=(stat$pmfile)[9];$self->{MTIME}=$filemtime;$self->{PMFILE}=$pmfile;unless ($self->_version_from_meta_ok){my$version;unless (eval {$version=$self->_parse_version;1}){$self->_verbose(1,"error with version in $pmfile: $@");return}$self->{VERSION}=$version;if ($self->{VERSION}=~ /^\{.*\}$/){}elsif ($self->{VERSION}=~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){return}}my($ppp)=$self->_packages_per_pmfile;my@keys_ppp=$self->_filter_ppps(sort keys %$ppp);$self->_verbose(1,"Will check keys_ppp[@keys_ppp]\n");my ($package,%errors);my%checked_in;DBPACK: foreach$package (@keys_ppp){if ($package !~ /^\w[\w\:\']*\w?\z/ || $package !~ /\w\z/ || $package =~ /:/ && $package !~ /::/ || $package =~ /\w:\w/ || $package =~ /:::/){$self->_verbose(1,"Package[$package] did not pass the ultimate sanity check");delete$ppp->{$package};next}if ($self->{USERID}&& $self->{PERMISSIONS}&&!$self->_perm_check($package)){delete$ppp->{$package};next}{my (undef,$module)=split m{/lib/},$self->{PMFILE},2;if ($module){$module =~ s{\.pm\z}{};$module =~ s{/}{::}g;if (lc$module eq lc$package && $module ne $package){$errors{$package}={indexing_warning=>"Capitalization of package ($package) does not match filename!",infile=>$self->{PMFILE},}}}}my$pp=$ppp->{$package};if ($pp->{version}&& $pp->{version}=~ /^\{.*\}$/){my$err=JSON::PP::decode_json($pp->{version});if ($err->{x_normalize}){$errors{$package}={normalize=>$err->{version},infile=>$pp->{infile},};$pp->{version}="undef"}elsif ($err->{openerr}){$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          read the file. It issued the following error: C< $err->{r} >},);$errors{$package}={open=>$err->{r},infile=>$pp->{infile},}}else {$pp->{version}="undef";$self->_verbose(1,qq{Parse::PMFile was not able to
          parse the following line in that file: C< $err->{line} >
  
          Note: the indexer is running in a Safe compartement and cannot
          provide the full functionality of perl in the VERSION line. It
          is trying hard, but sometime it fails. As a workaround, please
          consider writing a META.yml that contains a 'provides'
          attribute or contact the CPAN admins to investigate (yet
          another) workaround against "Safe" limitations.)},);$errors{$package}={parse_version=>$err->{line},infile=>$err->{file},}}}for ($package,$pp->{version},){if (!defined || /^\s*$/ || /\s/){delete$ppp->{$package};next}}unless ($self->_version_ok($pp)){$errors{$package}={long_version=>qq{Version string exceeds maximum allowed length of 16b: "$pp->{version}"},infile=>$pp->{infile},};next}$checked_in{$package}=$ppp->{$package}}return (wantarray && %errors)? (\%checked_in,\%errors): \%checked_in}sub _version_ok {my ($self,$pp)=@_;return if length($pp->{version}|| 0)> 16;return 1}sub _perm_check {my ($self,$package)=@_;my$userid=$self->{USERID};my$module=$self->{PERMISSIONS}->module_permissions($package);return 1 if!$module;return 1 if defined$module->m && $module->m eq $userid;return 1 if defined$module->f && $module->f eq $userid;return 1 if defined$module->c && grep {$_ eq $userid}@{$module->c};return}sub _parse_version {my$self=shift;use strict;my$pmfile=$self->{PMFILE};my$tmpfile=File::Spec->catfile(File::Spec->tmpdir,"ParsePMFile$$" .rand(1000));my$pmcp=$pmfile;for ($pmcp){s/([^\\](\\\\)*)@/$1\\@/g}my($v);{package main;my$pid;if ($self->{FORK}|| $FORK){$pid=fork();die "Can't fork: $!" unless defined$pid}if ($pid){waitpid($pid,0);if (open my$fh,'<',$tmpfile){$v=<$fh>}}else {my$comp;my$eval=qq{
                  local(\$^W) = 0;
                  Parse::PMFile::_parse_version_safely("$pmcp");
              };unless ($self->{UNSAFE}|| $UNSAFE){$comp=Safe->new;$comp->permit("entereval");$comp->share("*Parse::PMFile::_parse_version_safely");$comp->share("*version::new");$comp->share("*version::numify");$comp->share_from('main',['*version::','*charstar::','*Exporter::','*DynaLoader::']);$comp->share_from('version',['&qv']);$comp->permit(":base_math");$comp->deny(qw/enteriter iter unstack goto/)}version->import('qv')if$self->{UNSAFE}|| $UNSAFE;{no strict;$v=$comp ? $comp->reval($eval): eval$eval}if ($@){my$err=$@;if (ref$err){if ($err->{line}=~ /([\$*])([\w\:\']*)\bVERSION\b.*?\=(.*)/){local($^W)=0;my ($sigil,$vstr)=($1,$3);$self->_restore_overloaded_stuff(1)if$err->{line}=~ /use\s+version\b|version\->|qv\(/;$v=$comp ? $comp->reval($vstr): eval$vstr;$v=$$v if$sigil eq '*' && ref$v}if ($@ or!$v){$self->_verbose(1,sprintf("reval failed: err[%s] for eval[%s]",JSON::PP::encode_json($err),$eval,));$v=JSON::PP::encode_json($err)}}else {$v=JSON::PP::encode_json({openerr=>$err })}}if (defined$v){no warnings;$v=$v->numify if ref($v)=~ /^version(::vpp)?$/}else {$v=""}if ($self->{FORK}|| $FORK){open my$fh,'>:utf8',$tmpfile;print$fh $v;exit 0}else {utf8::encode($v);$v=undef if defined$v &&!length$v;$comp->erase if ($comp);$self->_restore_overloaded_stuff}}}unlink$tmpfile if ($self->{FORK}|| $FORK)&& -e $tmpfile;return$self->_normalize_version($v)}sub _restore_overloaded_stuff {my ($self,$used_version_in_safe)=@_;return if$self->{UNSAFE}|| $UNSAFE;no strict 'refs';no warnings 'redefine';my$restored;if ($INC{'version/vxs.pm'}){*{'version::(""'}=\&version::vxs::stringify;*{'version::(0+'}=\&version::vxs::numify;*{'version::(cmp'}=\&version::vxs::VCMP;*{'version::(<=>'}=\&version::vxs::VCMP;*{'version::(bool'}=\&version::vxs::boolean;$restored=1}if ($INC{'version/vpp.pm'}){{package charstar;overload->import}if (!$used_version_in_safe){package version::vpp;overload->import}unless ($restored){*{'version::(""'}=\&version::vpp::stringify;*{'version::(0+'}=\&version::vpp::numify;*{'version::(cmp'}=\&version::vpp::vcmp;*{'version::(<=>'}=\&version::vpp::vcmp;*{'version::(bool'}=\&version::vpp::vbool}*{'version::vpp::(""'}=\&version::vpp::stringify;*{'version::vpp::(0+'}=\&version::vpp::numify;*{'version::vpp::(cmp'}=\&version::vpp::vcmp;*{'version::vpp::(<=>'}=\&version::vpp::vcmp;*{'version::vpp::(bool'}=\&version::vpp::vbool;*{'charstar::(""'}=\&charstar::thischar;*{'charstar::(0+'}=\&charstar::thischar;*{'charstar::(++'}=\&charstar::increment;*{'charstar::(--'}=\&charstar::decrement;*{'charstar::(+'}=\&charstar::plus;*{'charstar::(-'}=\&charstar::minus;*{'charstar::(*'}=\&charstar::multiply;*{'charstar::(cmp'}=\&charstar::cmp;*{'charstar::(<=>'}=\&charstar::spaceship;*{'charstar::(bool'}=\&charstar::thischar;*{'charstar::(='}=\&charstar::clone;$restored=1}if (!$restored){*{'version::(""'}=\&version::stringify;*{'version::(0+'}=\&version::numify;*{'version::(cmp'}=\&version::vcmp;*{'version::(<=>'}=\&version::vcmp;*{'version::(bool'}=\&version::boolean}}sub _packages_per_pmfile {my$self=shift;my$ppp={};my$pmfile=$self->{PMFILE};my$filemtime=$self->{MTIME};my$version=$self->{VERSION};open my$fh,"<","$pmfile" or return$ppp;local $/="\n";my$inpod=0;PLINE: while (<$fh>){chomp;my($pline)=$_;$inpod=$pline =~ /^=(?!cut)/ ? 1 : $pline =~ /^=cut/ ? 0 : $inpod;next if$inpod;next if substr($pline,0,4)eq "=cut";$pline =~ s/\#.*//;next if$pline =~ /^\s*$/;if ($pline =~ /^__(?:END|DATA)__\b/ and $pmfile !~ /\.PL$/){last PLINE}my$pkg;my$strict_version;if ($pline =~ m{
                        # (.*) # takes too much time if $pline is long
                        #(?<![*\$\\@%&]) # no sigils
                        ^[\s\{;]*
                        \bpackage\s+
                        ([\w\:\']+)
                        \s*
                        (?: $ | [\}\;] | \{ | \s+($version::STRICT) )
                      }x){$pkg=$1;$strict_version=$2;if ($pkg eq "DB"){next PLINE}}if ($pkg){$pkg =~ s/\'/::/g;next PLINE unless$pkg =~ /^[A-Za-z]/;next PLINE unless$pkg =~ /\w$/;next PLINE if$pkg eq "main";next PLINE if length($pkg)> 128;$ppp->{$pkg}{parsed}++;$ppp->{$pkg}{infile}=$pmfile;if ($self->_simile($pmfile,$pkg)){$ppp->{$pkg}{simile}=$pmfile;if ($self->_version_from_meta_ok){my$provides=$self->{META_CONTENT}{provides};if (exists$provides->{$pkg}){if (defined$provides->{$pkg}{version}){my$v=$provides->{$pkg}{version};if ($v =~ /[_\s]/ &&!$self->{ALLOW_DEV_VERSION}&&!$ALLOW_DEV_VERSION){next PLINE}unless (eval {$version=$self->_normalize_version($v);1}){$self->_verbose(1,"error with version in $pmfile: $@");next}$ppp->{$pkg}{version}=$version}else {$ppp->{$pkg}{version}="undef"}}}else {if (defined$strict_version){$ppp->{$pkg}{version}=$strict_version }else {$ppp->{$pkg}{version}=defined$version ? $version : ""}no warnings;if ($version eq 'undef'){$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}}else {$ppp->{$pkg}{version}=$version if$version > $ppp->{$pkg}{version}|| $version gt $ppp->{$pkg}{version}}}}else {$ppp->{$pkg}{version}=$version unless defined$ppp->{$pkg}{version}&& length($ppp->{$pkg}{version})}$ppp->{$pkg}{filemtime}=$filemtime}else {}}close$fh;$ppp}{no strict;sub _parse_version_safely {my($parsefile)=@_;my$result;local*FH;local $/="\n";open(FH,$parsefile)or die "Could not open '$parsefile': $!";my$inpod=0;while (<FH>){$inpod=/^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;next if$inpod || /^\s*#/;last if /^__(?:END|DATA)__\b/;chop;if (my ($ver)=/package \s+ \S+ \s+ (\S+) \s* [;{]/x){return$ver if version::is_lax($ver)}next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*(?<![!><=])\=(?![=>])/;my$current_parsed_line=$_;my$eval=qq{
                  package #
                      ExtUtils::MakeMaker::_version;
  
                  local $1$2;
                  \$$2=undef; do {
                      $_
                  }; \$$2
              };local $^W=0;local$SIG{__WARN__}=sub {};$result=__clean_eval($eval);if ($@ or!defined$result){die +{eval=>$eval,line=>$current_parsed_line,file=>$parsefile,err=>$@,}}last}close FH;$result="undef" unless defined$result;if ((ref$result)=~ /^version(?:::vpp)?\b/){no warnings;$result=$result->numify}return$result}}sub _filter_ppps {my($self,@ppps)=@_;my@res;MANI: for my$ppp (@ppps){if ($self->{META_CONTENT}){my$no_index=$self->{META_CONTENT}{no_index}|| $self->{META_CONTENT}{private};if (ref($no_index)eq 'HASH'){my%map=(package=>qr{\z},namespace=>qr{::},);for my$k (qw(package namespace)){next unless my$v=$no_index->{$k};my$rest=$map{$k};if (ref$v eq "ARRAY"){for my$ve (@$v){$ve =~ s|::$||;if ($ppp =~ /^$ve$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to ve[$ve]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to ve[$ve]")}}}else {$v =~ s|::$||;if ($ppp =~ /^$v$rest/){$self->_verbose(1,"Skipping ppp[$ppp] due to v[$v]");next MANI}else {$self->_verbose(1,"NOT skipping ppp[$ppp] due to v[$v]")}}}}else {$self->_verbose(1,"No keyword 'no_index' or 'private' in META_CONTENT")}}else {}push@res,$ppp}$self->_verbose(1,"Result of filter_ppps: res[@res]");@res}sub _simile {my($self,$file,$package)=@_;$file =~ s|.*/||;$file =~ s|\.pm(?:\.PL)?||;my$ret=$package =~ m/\b\Q$file\E$/;$ret ||= 0;unless ($ret){$ret=1 if lc$file eq 'version'}$self->_verbose(1,"Result of simile(): file[$file] package[$package] ret[$ret]\n");$ret}sub _normalize_version {my($self,$v)=@_;$v="undef" unless defined$v;my$dv=Dumpvalue->new;my$sdv=$dv->stringify($v,1);$self->_verbose(1,"Result of normalize_version: sdv[$sdv]\n");return$v if$v eq "undef";return$v if$v =~ /^\{.*\}$/;$v =~ s/^\s+//;$v =~ s/\s+\z//;if ($v =~ /_/){return$v }if (!version::is_lax($v)){return JSON::PP::encode_json({x_normalize=>'version::is_lax failed',version=>$v })}my$vv=eval {no warnings;version->new($v)->numify};if ($@){return JSON::PP::encode_json({x_normalize=>$@,version=>$v })}if ($vv eq $v){}else {my$forced=$self->_force_numeric($v);if ($forced eq $vv){}elsif ($forced =~ /^v(.+)/){no warnings;$vv=version->new($1)->numify}else {if ($forced==$vv){$vv=$forced}}}return$vv}sub _force_numeric {my($self,$v)=@_;$v=$self->_readable($v);if ($v =~ /^(\+?)(\d*)(\.(\d*))?/ && (defined $2 && length $2 || defined $4 && length $4)){my$two=defined $2 ? $2 : "";my$three=defined $3 ? $3 : "";$v="$two$three"}$v}sub _version_from_meta_ok {my($self)=@_;return$self->{VERSION_FROM_META_OK}if exists$self->{VERSION_FROM_META_OK};my$c=$self->{META_CONTENT};return($self->{VERSION_FROM_META_OK}=0)unless$c->{provides};my ($mb_v)=(defined$c->{generated_by}? $c->{generated_by}: '')=~ /Module::Build version ([\d\.]+)/;return($self->{VERSION_FROM_META_OK}=1)unless$mb_v;return($self->{VERSION_FROM_META_OK}=1)if$mb_v eq '0.250.0';if ($mb_v >= 0.19 && $mb_v < 0.26 &&!keys %{$c->{provides}}){return($self->{VERSION_FROM_META_OK}=0)}return($self->{VERSION_FROM_META_OK}=1)}sub _verbose {my($self,$level,@what)=@_;warn@what if$level <= ((ref$self && $self->{VERBOSE})|| $VERBOSE)}sub _vcmp {my($self,$l,$r)=@_;local($^W)=0;$self->_verbose(9,"l[$l] r[$r]");return 0 if$l eq $r;for ($l,$r){s/_//g}$self->_verbose(9,"l[$l] r[$r]");for ($l,$r){next unless tr/.// > 1 || /^v/;s/^v?/v/;1 while s/\.0+(\d)/.$1/}$self->_verbose(9,"l[$l] r[$r]");if ($l=~/^v/ <=> $r=~/^v/){for ($l,$r){next if /^v/;$_=$self->_float2vv($_)}}$self->_verbose(9,"l[$l] r[$r]");my$lvstring="v0";my$rvstring="v0";if ($] >= 5.006 && $l =~ /^v/ && $r =~ /^v/){$lvstring=$self->_vstring($l);$rvstring=$self->_vstring($r);$self->_verbose(9,sprintf "lv[%vd] rv[%vd]",$lvstring,$rvstring)}return (($l ne "undef")<=> ($r ne "undef")|| $lvstring cmp $rvstring || $l <=> $r || $l cmp $r)}sub _vgt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)> 0}sub _vlt {my($self,$l,$r)=@_;$self->_vcmp($l,$r)< 0}sub _vge {my($self,$l,$r)=@_;$self->_vcmp($l,$r)>= 0}sub _vle {my($self,$l,$r)=@_;$self->_vcmp($l,$r)<= 0}sub _vstring {my($self,$n)=@_;$n =~ s/^v// or die "Parse::PMFile::_vstring() called with invalid arg [$n]";pack "U*",split /\./,$n}sub _float2vv {my($self,$n)=@_;my($rev)=int($n);$rev ||= 0;my($mantissa)=$n =~ /\.(\d{1,12})/;$mantissa ||= 0;$mantissa .= "0" while length($mantissa)%3;my$ret="v" .$rev;while ($mantissa){$mantissa =~ s/(\d{1,3})// or die "Panic: length>0 but not a digit? mantissa[$mantissa]";$ret .= ".".int($1)}$ret =~ s/(\.0)+/.0/;$ret}sub _readable {my($self,$n)=@_;$n =~ /^([\w\-\+\.]+)/;return $1 if defined $1 && length($1)>0;if ($] < 5.006){$self->_verbose(9,"Suspicious version string seen [$n]\n");return$n}my$better=sprintf "v%vd",$n;$self->_verbose(9,"n[$n] better[$better]");return$better}1;
PARSE_PMFILE

$fatpacked{"Path/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'PATH_TINY';
  use 5.008001;use strict;use warnings;package Path::Tiny;our$VERSION='0.122';use Config;use Exporter 5.57 (qw/import/);use File::Spec 0.86 ();use Carp ();our@EXPORT=qw/path/;our@EXPORT_OK=qw/cwd rootdir tempfile tempdir/;use constant {PATH=>0,CANON=>1,VOL=>2,DIR=>3,FILE=>4,TEMP=>5,IS_WIN32=>($^O eq 'MSWin32'),};use overload (q{""}=>sub {$_[0]->[PATH]},bool=>sub () {1},fallback=>1,);sub FREEZE {return $_[0]->[PATH]}sub THAW {return path($_[2])}{no warnings 'once';*TO_JSON=*FREEZE};my$HAS_UU;sub _check_UU {local$SIG{__DIE__};!!eval {require Unicode::UTF8;Unicode::UTF8->VERSION(0.58);1}}my$HAS_PU;sub _check_PU {local$SIG{__DIE__};!!eval {require Encode;require PerlIO::utf8_strict;PerlIO::utf8_strict->VERSION(0.003);1}}my$HAS_FLOCK=$Config{d_flock}|| $Config{d_fcntl_can_lock}|| $Config{d_lockf};my$SLASH=qr{[\\/]};my$NOTSLASH=qr{[^\\/]};my$DRV_VOL=qr{[a-z]:}i;my$UNC_VOL=qr{$SLASH $SLASH $NOTSLASH+ $SLASH $NOTSLASH+}x;my$WIN32_ROOT=qr{(?: $UNC_VOL $SLASH | $DRV_VOL $SLASH | $SLASH )}x;sub _win32_vol {my ($path,$drv)=@_;require Cwd;my$dcwd=eval {Cwd::getdcwd($drv)};$dcwd="$drv" unless defined$dcwd && length$dcwd;$dcwd =~ s{$SLASH?\z}{/};$path =~ s{^$DRV_VOL}{$dcwd};return$path}sub _is_root {return IS_WIN32()? ($_[0]=~ /^$WIN32_ROOT\z/): ($_[0]eq '/')}BEGIN {*_same=IS_WIN32()? sub {lc($_[0])eq lc($_[1])}: sub {$_[0]eq $_[1]}}my%MODEBITS=(om=>0007,gm=>0070,um=>0700);{my$m=0;$MODEBITS{$_}=(1 << $m++)for qw/ox ow or gx gw gr ux uw ur/};sub _symbolic_chmod {my ($mode,$symbolic)=@_;for my$clause (split /,\s*/,$symbolic){if ($clause =~ m{\A([augo]+)([=+-])([rwx]+)\z}){my ($who,$action,$perms)=($1,$2,$3);$who =~ s/a/ugo/g;for my$w (split //,$who){my$p=0;$p |= $MODEBITS{"$w$_"}for split //,$perms;if ($action eq '='){$mode=($mode & ~$MODEBITS{"${w}m"})| $p}else {$mode=$action eq "+" ? ($mode | $p): ($mode & ~$p)}}}else {Carp::croak("Invalid mode clause '$clause' for chmod()")}}return$mode}{package flock;use warnings::register}my$WARNED_NO_FLOCK=0;sub _throw {my ($self,$function,$file,$msg)=@_;if ($function =~ /^flock/ && $! =~ /operation not supported|function not implemented/i &&!warnings::fatal_enabled('flock')){if (!$WARNED_NO_FLOCK){warnings::warn(flock=>"Flock not available: '$!': continuing in unsafe mode");$WARNED_NO_FLOCK++}}else {$msg=$! unless defined$msg;Path::Tiny::Error->throw($function,(defined$file ? $file : $self->[PATH]),$msg)}return}sub _get_args {my ($raw,@valid)=@_;if (defined($raw)&& ref($raw)ne 'HASH'){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Options for $called_as must be a hash reference")}my$cooked={};for my$k (@valid){$cooked->{$k}=delete$raw->{$k}if exists$raw->{$k}}if (keys %$raw){my (undef,undef,undef,$called_as)=caller(1);$called_as =~ s{^.*::}{};Carp::croak("Invalid option(s) for $called_as: " .join(", ",keys %$raw))}return$cooked}sub path {my$path=shift;Carp::croak("Path::Tiny paths require defined, positive-length parts")unless 1 + @_==grep {defined && length}$path,@_;if (!@_ && ref($path)eq __PACKAGE__ &&!$path->[TEMP]){return$path}$path="$path";if (IS_WIN32()){$path=_win32_vol($path,$1)if$path =~ m{^($DRV_VOL)(?:$NOTSLASH|\z)};$path .= "/" if$path =~ m{^$UNC_VOL\z}}if (@_){$path .= (_is_root($path)? "" : "/").join("/",@_)}my$cpath=$path=File::Spec->canonpath($path);$path =~ tr[\\][/] if IS_WIN32();$path="/" if$path eq '/..';$path .= "/" if IS_WIN32()&& $path =~ m{^$UNC_VOL\z};if (_is_root($path)){$path =~ s{/?\z}{/}}else {$path =~ s{/\z}{}}if ($path =~ m{^(~[^/]*).*}){require File::Glob;my ($homedir)=File::Glob::bsd_glob($1);$homedir =~ tr[\\][/] if IS_WIN32();$path =~ s{^(~[^/]*)}{$homedir}}bless [$path,$cpath ],__PACKAGE__}sub new {shift;path(@_)}sub cwd {require Cwd;return path(Cwd::getcwd())}sub rootdir {path(File::Spec->rootdir)}sub tempfile {my ($opts,$maybe_template,$args)=_parse_file_temp_args(tempfile=>@_);$args->{TEMPLATE}=$maybe_template->[0]if @$maybe_template;require File::Temp;my$temp=File::Temp->new(TMPDIR=>1,%$args);close$temp;my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;return$self}sub tempdir {my ($opts,$maybe_template,$args)=_parse_file_temp_args(tempdir=>@_);require File::Temp;my$temp=File::Temp->newdir(@$maybe_template,TMPDIR=>1,%$args);my$self=$opts->{realpath}? path($temp)->realpath : path($temp)->absolute;$self->[TEMP]=$temp;$temp->{REALNAME}=$self->[CANON]if IS_WIN32;return$self}sub _parse_file_temp_args {my$called_as=shift;if (@_ && $_[0]eq 'Path::Tiny'){shift}elsif (@_ && eval{$_[0]->isa('Path::Tiny')}){my$dir=shift;if (!$dir->is_dir){$dir->_throw($called_as,$dir,"is not a directory object")}push @_,DIR=>$dir->stringify}my$opts=(@_ && ref $_[0]eq 'HASH')? shift @_ : {};$opts=_get_args($opts,qw/realpath/);my$leading_template=(scalar(@_)% 2==1 ? shift(@_): '');my%args=@_;%args=map {uc($_),$args{$_}}keys%args;my@template=(exists$args{TEMPLATE}? delete$args{TEMPLATE}: $leading_template ? $leading_template : ());return ($opts,\@template,\%args)}sub _splitpath {my ($self)=@_;@{$self}[VOL,DIR,FILE ]=File::Spec->splitpath($self->[PATH])}sub _resolve_symlinks {my ($self)=@_;my$new=$self;my ($count,%seen)=0;while (-l $new->[PATH]){if ($seen{$new->[PATH]}++){$self->_throw('readlink',$self->[PATH],"symlink loop detected")}if (++$count > 100){$self->_throw('readlink',$self->[PATH],"maximum symlink depth exceeded")}my$resolved=readlink$new->[PATH]or $new->_throw('readlink',$new->[PATH]);$resolved=path($resolved);$new=$resolved->is_absolute ? $resolved : $new->sibling($resolved)}return$new}sub absolute {my ($self,$base)=@_;if (IS_WIN32){return$self if length$self->volume;if ($self->is_absolute){require Cwd;my ($drv)=Win32::GetCwd()=~ /^($DRV_VOL | $UNC_VOL)/x;return path($drv .$self->[PATH])}}else {return$self if$self->is_absolute}require Cwd;return path(Cwd::getcwd(),$_[0]->[PATH])unless defined$base;$base=path($base);return path(($base->is_absolute ? $base : $base->absolute),$_[0]->[PATH])}sub append {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$mode=$args->{truncate}? ">" : ">>";my$fh=$self->filehandle({locked=>1 },$mode,$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close')}sub append_raw {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);$args->{binmode}=':unix';append($self,$args,@data)}sub append_utf8 {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode truncate/);if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){$args->{binmode}=":unix";append($self,$args,map {Unicode::UTF8::encode_utf8($_)}@data)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";append($self,$args,@data)}else {$args->{binmode}=":unix:encoding(UTF-8)";append($self,$args,@data)}}sub assert {my ($self,$assertion)=@_;return$self unless$assertion;if (ref$assertion eq 'CODE'){local $_=$self;$assertion->()or Path::Tiny::Error->throw("assert",$self->[PATH],"failed assertion")}else {Carp::croak("argument to assert must be a code reference argument")}return$self}sub basename {my ($self,@suffixes)=@_;$self->_splitpath unless defined$self->[FILE];my$file=$self->[FILE];for my$s (@suffixes){my$re=ref($s)eq 'Regexp' ? qr/$s\z/ : qr/\Q$s\E\z/;last if$file =~ s/$re//}return$file}sub canonpath {$_[0]->[CANON]}sub cached_temp {my$self=shift;$self->_throw("cached_temp",$self,"has no cached File::Temp object")unless defined$self->[TEMP];return$self->[TEMP]}sub child {my ($self,@parts)=@_;return path($self->[PATH],@parts)}sub children {my ($self,$filter)=@_;my$dh;opendir$dh,$self->[PATH]or $self->_throw('opendir');my@children=readdir$dh;closedir$dh or $self->_throw('closedir');if (not defined$filter){@children=grep {$_ ne '.' && $_ ne '..'}@children}elsif ($filter && ref($filter)eq 'Regexp'){@children=grep {$_ ne '.' && $_ ne '..' && $_ =~ $filter}@children}else {Carp::croak("Invalid argument '$filter' for children()")}return map {path($self->[PATH],$_)}@children}sub chmod {my ($self,$new_mode)=@_;my$mode;if ($new_mode =~ /\d/){$mode=($new_mode =~ /^0/ ? oct($new_mode): $new_mode)}elsif ($new_mode =~ /[=+-]/){$mode=_symbolic_chmod($self->stat->mode & 07777,$new_mode)}else {Carp::croak("Invalid mode argument '$new_mode' for chmod()")}CORE::chmod($mode,$self->[PATH])or $self->_throw("chmod");return 1}sub copy {my ($self,$dest)=@_;require File::Copy;File::Copy::copy($self->[PATH],$dest)or Carp::croak("copy failed for $self to $dest: $!");return -d $dest ? path($dest,$self->basename): path($dest)}sub digest {my ($self,@opts)=@_;my$args=(@opts && ref$opts[0]eq 'HASH')? shift@opts : {};$args=_get_args($args,qw/chunk_size/);unshift@opts,'SHA-256' unless@opts;require Digest;my$digest=Digest->new(@opts);if ($args->{chunk_size}){my$fh=$self->filehandle({locked=>1 },"<",":unix");my$buf;$digest->add($buf)while read$fh,$buf,$args->{chunk_size}}else {$digest->add($self->slurp_raw)}return$digest->hexdigest}sub dirname {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return length$self->[DIR]? $self->[DIR]: "."}sub edit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp(exists($args->{binmode})? {binmode=>$args->{binmode}}: ());$cb->();$self->spew($args,$_);return}sub edit_utf8 {my ($self,$cb)=@_;Carp::croak("Callback for edit_utf8() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';local $_=$self->slurp_utf8;$cb->();$self->spew_utf8($_);return}sub edit_raw {$_[2]={binmode=>":unix" };goto&edit}sub edit_lines {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/binmode/);Carp::croak("Callback for edit_lines() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$temp_fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);my$in_fh=$self->filehandle({locked=>1 },'<',$binmode);local $_;while (<$in_fh>){$cb->();$temp_fh->print($_)}close$temp_fh or $self->_throw('close',$temp);close$in_fh or $self->_throw('close');return$temp->move($resolved_path)}sub edit_lines_raw {$_[2]={binmode=>":unix" };goto&edit_lines}sub edit_lines_utf8 {$_[2]={binmode=>":raw:encoding(UTF-8)" };goto&edit_lines}sub exists {-e $_[0]->[PATH]}sub is_file {-e $_[0]->[PATH]&&!-d _}sub is_dir {-d $_[0]->[PATH]}sub filehandle {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked exclusive/);$args->{locked}=1 if$args->{exclusive};my ($opentype,$binmode)=@args;$opentype="<" unless defined$opentype;Carp::croak("Invalid file mode '$opentype'")unless grep {$opentype eq $_}qw/< +< > +> >> +>>/;$binmode=((caller(0))[10]|| {})->{'open' .substr($opentype,-1,1)}unless defined$binmode;$binmode="" unless defined$binmode;my ($fh,$lock,$trunc);if ($HAS_FLOCK && $args->{locked}&&!$ENV{PERL_PATH_TINY_NO_FLOCK}){require Fcntl;if (grep {$opentype eq $_}qw(> +>)){my$flags=$opentype eq ">" ? Fcntl::O_WRONLY(): Fcntl::O_RDWR();$flags |= Fcntl::O_CREAT();$flags |= Fcntl::O_EXCL()if$args->{exclusive};sysopen($fh,$self->[PATH],$flags)or $self->_throw("sysopen");if ($binmode =~ s/^:unix//){binmode($fh,":raw")or $self->_throw("binmode (:raw)");while (1 < (my$layers=()=PerlIO::get_layers($fh,output=>1))){binmode($fh,":pop")or $self->_throw("binmode (:pop)")}}if (length$binmode){binmode($fh,$binmode)or $self->_throw("binmode ($binmode)")}$lock=Fcntl::LOCK_EX();$trunc=1}elsif ($^O eq 'aix' && $opentype eq "<"){if (-w $self->[PATH]){$opentype="+<";$lock=Fcntl::LOCK_EX()}}else {$lock=$opentype eq "<" ? Fcntl::LOCK_SH(): Fcntl::LOCK_EX()}}unless ($fh){my$mode=$opentype .$binmode;open$fh,$mode,$self->[PATH]or $self->_throw("open ($mode)")}do {flock($fh,$lock)or $self->_throw("flock ($lock)")}if$lock;do {truncate($fh,0)or $self->_throw("truncate")}if$trunc;return$fh}sub is_absolute {substr($_[0]->dirname,0,1)eq '/'}sub is_relative {substr($_[0]->dirname,0,1)ne '/'}sub is_rootdir {my ($self)=@_;$self->_splitpath unless defined$self->[DIR];return$self->[DIR]eq '/' && $self->[FILE]eq ''}sub iterator {my$self=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);my@dirs=$self;my$current;return sub {my$next;while (@dirs){if (ref$dirs[0]eq 'Path::Tiny'){if (!-r $dirs[0]){shift@dirs and next}$current=$dirs[0];my$dh;opendir($dh,$current->[PATH])or $self->_throw('opendir',$current->[PATH]);$dirs[0]=$dh;if (-l $current->[PATH]&&!$args->{follow_symlinks}){shift@dirs and next}}while (defined($next=readdir$dirs[0])){next if$next eq '.' || $next eq '..';my$path=$current->child($next);push@dirs,$path if$args->{recurse}&& -d $path &&!(!$args->{follow_symlinks}&& -l $path);return$path}shift@dirs}return}}sub lines {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);my$chomp=$args->{chomp};if ($args->{count}){my ($counter,$mod,@result)=(0,abs($args->{count}));while (my$line=<$fh>){$line =~ s/(?:\x{0d}?\x{0a}|\x{0d})\z// if$chomp;$result[$counter++ ]=$line;last if$counter==$args->{count};$counter %= $mod}splice(@result,0,0,splice(@result,$counter))if@result==$mod && $counter % $mod;return@result}elsif ($chomp){return map {s/(?:\x{0d}?\x{0a}|\x{0d})\z//;$_}<$fh>}else {return wantarray ? <$fh> : (my$count=()=<$fh>)}}sub lines_raw {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ($args->{chomp}&&!$args->{count}){return split /\n/,slurp_raw($self)}else {$args->{binmode}=":raw";return lines($self,$args)}}my$CRLF=qr/(?:\x{0d}?\x{0a}|\x{0d})/;sub lines_utf8 {my$self=shift;my$args=_get_args(shift,qw/binmode chomp count/);if ((defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU()))&& $args->{chomp}&&!$args->{count}){my$slurp=slurp_utf8($self);$slurp =~ s/$CRLF\z//;return split$CRLF,$slurp,-1}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$args->{binmode}=":unix:utf8_strict";return lines($self,$args)}else {$args->{binmode}=":raw:encoding(UTF-8)";return lines($self,$args)}}sub mkpath {my ($self,$args)=@_;$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};require File::Path;my@dirs=File::Path::make_path($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("mkpath failed for $file: $message")}return@dirs}sub move {my ($self,$dst)=@_;return rename($self->[PATH],$dst)|| $self->_throw('rename',$self->[PATH]."' -> '$dst")}my%opens=(opena=>">>",openr=>"<",openw=>">",openrw=>"+<");while (my ($k,$v)=each%opens){no strict 'refs';*{$k}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);my ($binmode)=@args;$binmode=((caller(0))[10]|| {})->{'open' .substr($v,-1,1)}unless defined$binmode;$self->filehandle($args,$v,$binmode)};*{$k ."_raw"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw")};*{$k ."_utf8"}=sub {my ($self,@args)=@_;my$args=(@args && ref$args[0]eq 'HASH')? shift@args : {};$args=_get_args($args,qw/locked/);$self->filehandle($args,$v,":raw:encoding(UTF-8)")}}sub parent {my ($self,$level)=@_;$level=1 unless defined$level && $level > 0;$self->_splitpath unless defined$self->[FILE];my$parent;if (length$self->[FILE]){if ($self->[FILE]eq '.' || $self->[FILE]eq ".."){$parent=path($self->[PATH]."/..")}else {$parent=path(_non_empty($self->[VOL].$self->[DIR]))}}elsif (length$self->[DIR]){if ($self->[DIR]=~ m{(?:^\.\./|/\.\./|/\.\.\z)}){$parent=path($self->[VOL].$self->[DIR]."/..")}else {(my$dir=$self->[DIR])=~ s{/[^\/]+/\z}{/};$parent=path($self->[VOL].$dir)}}else {$parent=path(_non_empty($self->[VOL]))}return$level==1 ? $parent : $parent->parent($level - 1)}sub _non_empty {my ($string)=shift;return ((defined($string)&& length($string))? $string : ".")}sub realpath {my$self=shift;$self=$self->_resolve_symlinks;require Cwd;$self->_splitpath if!defined$self->[FILE];my$check_parent=length$self->[FILE]&& $self->[FILE]ne '.' && $self->[FILE]ne '..';my$realpath=eval {local$SIG{__WARN__}=sub {};Cwd::realpath($check_parent ? $self->parent->[PATH]: $self->[PATH])};$self->_throw("resolving realpath")unless defined$realpath && length$realpath && -e $realpath;return ($check_parent ? path($realpath,$self->[FILE]): path($realpath))}sub relative {my ($self,$base)=@_;$base=path(defined$base && length$base ? $base : '.');$self=$self->absolute if$self->is_relative;$base=$base->absolute if$base->is_relative;$self=$self->absolute if!length$self->volume && length$base->volume;$base=$base->absolute if length$self->volume &&!length$base->volume;if (!_same($self->volume,$base->volume)){Carp::croak("relative() can't cross volumes: '$self' vs '$base'")}return path(".")if _same($self->[PATH],$base->[PATH]);if ($base->subsumes($self)){$base="" if$base->is_rootdir;my$relative="$self";$relative =~ s{\A\Q$base/}{};return path($relative)}my (@common,@self_parts,@base_parts);@base_parts=split /\//,$base->_just_filepath;if ($self->is_rootdir){@common=("");shift@base_parts}else {@self_parts=split /\//,$self->_just_filepath;while (@self_parts && @base_parts && _same($self_parts[0],$base_parts[0])){push@common,shift@base_parts;shift@self_parts}}if (my$new_base=$self->_resolve_between(\@common,\@base_parts)){return$self->relative($new_base)}my@new_path=(("..")x (0+ @base_parts),@self_parts);return path(@new_path)}sub _just_filepath {my$self=shift;my$self_vol=$self->volume;return "$self" if!length$self_vol;(my$self_path="$self")=~ s{\A\Q$self_vol}{};return$self_path}sub _resolve_between {my ($self,$common,$base)=@_;my$path=$self->volume .join("/",@$common);my$changed=0;for my$p (@$base){$path .= "/$p";if ($p eq '..'){$changed=1;if (-e $path){$path=path($path)->realpath->[PATH]}else {$path =~ s{/[^/]+/..\z}{/}}}if (-l $path){$changed=1;$path=path($path)->realpath->[PATH]}}return$changed ? path($path): undef}sub remove {my$self=shift;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];return unlink($self->[PATH])|| $self->_throw('unlink')}sub remove_tree {my ($self,$args)=@_;return 0 if!-e $self->[PATH]&&!-l $self->[PATH];$args={}unless ref$args eq 'HASH';my$err;$args->{error}=\$err unless defined$args->{error};$args->{safe}=1 unless defined$args->{safe};require File::Path;my$count=File::Path::remove_tree($self->[PATH],$args);if ($err && @$err){my ($file,$message)=%{$err->[0]};Carp::croak("remove_tree failed for $file: $message")}return$count}sub sibling {my$self=shift;return path($self->parent->[PATH],@_)}sub size {-s $_[0]->[PATH]}my%formats=('ls'=>[1024,log(1024),["",map {" $_"}qw/K M G T/ ]],'iec'=>[1024,log(1024),["",map {" $_"}qw/KiB MiB GiB TiB/ ]],'si'=>[1000,log(1000),["",map {" $_"}qw/kB MB GB TB/ ]],);sub _formats {return$formats{$_[0]}}sub size_human {my$self=shift;my$args=_get_args(shift,qw/format/);my$format=defined$args->{format}? $args->{format}: "ls";my$fmt_opts=$formats{$format}or Carp::croak("Invalid format '$format' for size_human()");my$size=-s $self->[PATH];return defined$size ? _human_size($size,@$fmt_opts): ""}sub _ceil {return $_[0]==int($_[0])? $_[0]: int($_[0]+1)}sub _human_size {my ($size,$base,$log_base,$suffixes)=@_;return "0" if$size==0;my$mag=int(log($size)/ $log_base);$size /= $base**$mag;$size=$mag==0 ? $size : length(int($size))==1 ? _ceil($size * 10)/ 10 : _ceil($size);if ($size >= $base){$size /= $base;$mag++}my$fmt=($mag==0 || length(int($size))> 1)? "%.0f%s" : "%.1f%s";return sprintf($fmt,$size,$suffixes->[$mag])}sub slurp {my$self=shift;my$args=_get_args(shift,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open<'}unless defined$binmode;my$fh=$self->filehandle({locked=>1 },"<",$binmode);if ((defined($binmode)? $binmode : "")eq ":unix" and my$size=-s $fh){my$buf;read$fh,$buf,$size;return$buf}else {local $/;return scalar <$fh>}}sub slurp_raw {$_[1]={binmode=>":unix" };goto&slurp}sub slurp_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){return Unicode::UTF8::decode_utf8(slurp($_[0],{binmode=>":unix" }))}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){$_[1]={binmode=>":unix:utf8_strict" };goto&slurp}else {$_[1]={binmode=>":raw:encoding(UTF-8)" };goto&slurp}}sub spew {my ($self,@data)=@_;my$args=(@data && ref$data[0]eq 'HASH')? shift@data : {};$args=_get_args($args,qw/binmode/);my$binmode=$args->{binmode};$binmode=((caller(0))[10]|| {})->{'open>'}unless defined$binmode;my$resolved_path=$self->_resolve_symlinks;my$temp=path($resolved_path .$$ .int(rand(2**31)));my$fh=$temp->filehandle({exclusive=>1,locked=>1 },">",$binmode);print {$fh}map {ref eq 'ARRAY' ? @$_ : $_}@data;close$fh or $self->_throw('close',$temp->[PATH]);return$temp->move($resolved_path)}sub spew_raw {splice @_,1,0,{binmode=>":unix" };goto&spew}sub spew_utf8 {if (defined($HAS_UU)? $HAS_UU : ($HAS_UU=_check_UU())){my$self=shift;spew($self,{binmode=>":unix" },map {Unicode::UTF8::encode_utf8($_)}map {ref eq 'ARRAY' ? @$_ : $_}@_)}elsif (defined($HAS_PU)? $HAS_PU : ($HAS_PU=_check_PU())){splice @_,1,0,{binmode=>":unix:utf8_strict" };goto&spew}else {splice @_,1,0,{binmode=>":unix:encoding(UTF-8)" };goto&spew}}sub stat {my$self=shift;require File::stat;return File::stat::stat($self->[PATH])|| $self->_throw('stat')}sub lstat {my$self=shift;require File::stat;return File::stat::lstat($self->[PATH])|| $self->_throw('lstat')}sub stringify {$_[0]->[PATH]}sub subsumes {my$self=shift;Carp::croak("subsumes() requires a defined, positive-length argument")unless defined $_[0];my$other=path(shift);if ($self->is_absolute &&!$other->is_absolute){$other=$other->absolute}elsif ($other->is_absolute &&!$self->is_absolute){$self=$self->absolute}if (length$self->volume &&!length$other->volume){$other=$other->absolute}elsif (length$other->volume &&!length$self->volume){$self=$self->absolute}if ($self->[PATH]eq '.'){return!!1}elsif ($self->is_rootdir){return$other->[PATH]=~ m{^\Q$self->[PATH]\E}}else {return$other->[PATH]=~ m{^\Q$self->[PATH]\E(?:/|\z)}}}sub touch {my ($self,$epoch)=@_;if (!-e $self->[PATH]){my$fh=$self->openw;close$fh or $self->_throw('close')}if (defined$epoch){utime$epoch,$epoch,$self->[PATH]or $self->_throw("utime ($epoch)")}else {utime undef,undef,$self->[PATH]or $self->_throw("utime ()")}return$self}sub touchpath {my ($self)=@_;my$parent=$self->parent;$parent->mkpath unless$parent->exists;$self->touch}sub visit {my$self=shift;my$cb=shift;my$args=_get_args(shift,qw/recurse follow_symlinks/);Carp::croak("Callback for visit() must be a code reference")unless defined($cb)&& ref($cb)eq 'CODE';my$next=$self->iterator($args);my$state={};while (my$file=$next->()){local $_=$file;my$r=$cb->($file,$state);last if ref($r)eq 'SCALAR' &&!$$r}return$state}sub volume {my ($self)=@_;$self->_splitpath unless defined$self->[VOL];return$self->[VOL]}package Path::Tiny::Error;our@CARP_NOT=qw/Path::Tiny/;use overload (q{""}=>sub {(shift)->{msg}},fallback=>1);sub throw {my ($class,$op,$file,$err)=@_;chomp(my$trace=Carp::shortmess);my$msg="Error $op on '$file': $err$trace\n";die bless {op=>$op,file=>$file,err=>$err,msg=>$msg },$class}1;
PATH_TINY

$fatpacked{"Scope/Guard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SCOPE_GUARD';
  package Scope::Guard;use strict;use warnings;use Carp qw(confess);use Exporter ();our@ISA=qw(Exporter);our@EXPORT_OK=qw(guard scope_guard);our$VERSION='0.21';sub new {confess "Can't create a Scope::Guard in void context" unless (defined wantarray);my$class=shift;my$handler=shift()|| die 'Scope::Guard::new: no handler supplied';my$ref=ref$handler || '';die "Scope::Guard::new: invalid handler - expected CODE ref, got: '$ref'" unless ref($handler)eq 'CODE';bless [0,$handler ],ref$class || $class}sub dismiss {my$self=shift;my$dismiss=@_ ? shift : 1;$self->[0]=$dismiss}sub guard(&) {__PACKAGE__->new(shift)}sub scope_guard($) {__PACKAGE__->new(shift)}sub DESTROY {my$self=shift;my ($dismiss,$handler)=@$self;$handler->()unless ($dismiss)}1;
SCOPE_GUARD

$fatpacked{"String/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'STRING_SHELLQUOTE';
  package String::ShellQuote;use strict;use vars qw($VERSION @ISA @EXPORT);require Exporter;$VERSION='1.04';@ISA=qw(Exporter);@EXPORT=qw(shell_quote shell_quote_best_effort shell_comment_quote);sub croak {require Carp;goto&Carp::croak}sub _shell_quote_backend {my@in=@_;my@err=();if (0){require RS::Handy;print RS::Handy::data_dump(\@in)}return \@err,'' unless@in;my$ret='';my$saw_non_equal=0;for (@in){if (!defined $_ or $_ eq ''){$_="''";next}if (s/\x00//g){push@err,"No way to quote string containing null (\\000) bytes"}my$escape=0;if (/=/){if (!$saw_non_equal){$escape=1}}else {$saw_non_equal=1}if (m|[^\w!%+,\-./:=@^]|){$escape=1}if ($escape || (!$saw_non_equal && /=/)){s/'/'\\''/g;s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;$_="'$_'";s/^''//;s/''$//}}continue {$ret .= "$_ "}chop$ret;return \@err,$ret}sub shell_quote {my ($rerr,$s)=_shell_quote_backend @_;if (@$rerr){my%seen;@$rerr=grep {!$seen{$_}++}@$rerr;my$s=join '',map {"shell_quote(): $_\n"}@$rerr;chomp$s;croak$s}return$s}sub shell_quote_best_effort {my ($rerr,$s)=_shell_quote_backend @_;return$s}sub shell_comment_quote {return '' unless @_;unless (@_==1){croak "Too many arguments to shell_comment_quote " ."(got " .@_ ." expected 1)"}local $_=shift;s/\n/\n#/g;return $_}1;
STRING_SHELLQUOTE

$fatpacked{"Sub/Info.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_INFO';
  package Sub::Info;use strict;use warnings;our$VERSION='0.002';use Carp qw/croak/;use B();use Importer Importer=>'import';our@EXPORT_OK=qw{sub_info};sub sub_info {my ($sub,@all_lines)=@_;my%in=map {$_=>1}@all_lines;croak "sub_info requires a coderef as its first argument" unless ref($sub)eq 'CODE';my$cobj=B::svref_2object($sub);my$name=$cobj->GV->NAME;my$file=$cobj->FILE;my$package=$cobj->GV->STASH->NAME;my$op=$cobj->START;while ($op){push@all_lines=>$op->line if$op->can('line');last unless$op->can('next');$op=$op->next}my ($start,$end,@lines);if (@all_lines){@all_lines=sort {$a <=> $b}@all_lines;($start,$end)=($all_lines[0],$all_lines[-1]);if ($start < $end){$start-- unless$start <= 1 || $in{$start};$end++ unless$in{$end}}@lines=($start,$end)}return {ref=>$sub,cobj=>$cobj,name=>$name,file=>$file,package=>$package,start_line=>$start,end_line=>$end,all_lines=>\@all_lines,lines=>\@lines,}}1;
SUB_INFO

$fatpacked{"Sub/Uplevel.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'SUB_UPLEVEL';
  package Sub::Uplevel;use 5.006;use strict;our$VERSION='0.2800';our$CHECK_FRAMES;BEGIN {$CHECK_FRAMES=!!$CHECK_FRAMES}use constant CHECK_FRAMES=>$CHECK_FRAMES;if (not defined*CORE::GLOBAL::caller{CODE}){*CORE::GLOBAL::caller=\&_normal_caller}my@reload_list=qw/Exporter Exporter::Heavy/;sub import {no strict 'refs';my ($class,@args)=@_;for my$tag (@args,'uplevel'){if ($tag eq 'uplevel'){my$caller=caller(0);*{"$caller\::uplevel"}=\&uplevel}elsif($tag eq ':aggressive'){_force_reload(@reload_list)}else {die qq{"$tag" is not exported by the $class module\n}}}return}sub _force_reload {no warnings 'redefine';local $^W=0;for my$m (@_){$m =~ s{::}{/}g;$m .= ".pm";require$m if delete$INC{$m}}}our (@Up_Frames,$Caller_Proxy);sub _apparent_stack_height {my$height=1;while (1){last if!defined scalar$Caller_Proxy->($height);$height++}return$height - 1}sub uplevel {my$old_W=$^W;$^W=0;local$Caller_Proxy=*CORE::GLOBAL::caller{CODE}if*CORE::GLOBAL::caller{CODE}!=\&_uplevel_caller;local*CORE::GLOBAL::caller=\&_uplevel_caller;$^W=$old_W;if (CHECK_FRAMES and $_[0]>= _apparent_stack_height()){require Carp;Carp::carp("uplevel $_[0] is more than the caller stack")}local@Up_Frames=(shift,@Up_Frames);my$function=shift;return$function->(@_)}sub _normal_caller (;$) {my ($height)=@_;$height++;my@caller=CORE::caller($height);if (CORE::caller()eq 'DB'){package DB;@caller=CORE::caller($height)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}sub _uplevel_caller (;$) {my$height=$_[0]|| 0;return$Caller_Proxy->($height + 1)if!@Up_Frames;my$saw_uplevel=0;my$adjust=0;my$test_caller;for (my$up=0;$up <= $height + $adjust;$up++ ){$test_caller=scalar CORE::caller($up + 1);if($test_caller && $test_caller eq __PACKAGE__){$adjust += 1 + $Up_Frames[$saw_uplevel];$saw_uplevel++}}my@caller=$Caller_Proxy->($height + $adjust + 1);if (CORE::caller()eq 'DB'){package DB;@caller=$Sub::Uplevel::Caller_Proxy->($height + $adjust + 1)}return if!@caller;return$caller[0]if!wantarray;return @_ ? @caller : @caller[0..2]}1;
SUB_UPLEVEL

$fatpacked{"Term/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE';
  package Term::Table;use strict;use warnings;our$VERSION='0.016';use Term::Table::Cell();use Term::Table::Util qw/term_size uni_length USE_GCS/;use Scalar::Util qw/blessed/;use List::Util qw/max sum/;use Carp qw/croak carp/;use Term::Table::HashBase qw/rows _columns collapse max_width mark_tail sanitize show_header auto_columns no_collapse header allow_overflow pad/;sub BORDER_SIZE() {4}sub DIV_SIZE() {3}sub CELL_PAD_SIZE() {2}sub init {my$self=shift;croak "You cannot have a table with no rows" unless$self->{+ROWS}&& @{$self->{+ROWS}};$self->{+MAX_WIDTH}||= term_size();$self->{+NO_COLLAPSE}||= {};if (ref($self->{+NO_COLLAPSE})eq 'ARRAY'){$self->{+NO_COLLAPSE}={map {($_=>1)}@{$self->{+NO_COLLAPSE}}}}if ($self->{+NO_COLLAPSE}&& $self->{+HEADER}){my$header=$self->{+HEADER};for(my$idx=0;$idx < @$header;$idx++){$self->{+NO_COLLAPSE}->{$idx}||= $self->{+NO_COLLAPSE}->{$header->[$idx]}}}$self->{+PAD}=4 unless defined$self->{+PAD};$self->{+COLLAPSE}=1 unless defined$self->{+COLLAPSE};$self->{+SANITIZE}=1 unless defined$self->{+SANITIZE};$self->{+MARK_TAIL}=1 unless defined$self->{+MARK_TAIL};if($self->{+HEADER}){$self->{+SHOW_HEADER}=1 unless defined$self->{+SHOW_HEADER}}else {$self->{+HEADER}=[];$self->{+AUTO_COLUMNS}=1;$self->{+SHOW_HEADER}=0}}sub columns {my$self=shift;$self->regen_columns unless$self->{+_COLUMNS};return$self->{+_COLUMNS}}sub regen_columns {my$self=shift;my$has_header=$self->{+SHOW_HEADER}&& @{$self->{+HEADER}};my%new_col=(width=>0,count=>$has_header ? -1 : 0);my$cols=[map {{%new_col}}@{$self->{+HEADER}}];my@rows=@{$self->{+ROWS}};for my$row ($has_header ? ($self->{+HEADER},@rows): (@rows)){for my$ci (0 .. max(@$cols - 1,@$row - 1)){$cols->[$ci]||= {%new_col}if$self->{+AUTO_COLUMNS};my$c=$cols->[$ci]or next;$c->{idx}||= $ci;$c->{rows}||= [];my$r=$row->[$ci];$r=Term::Table::Cell->new(value=>$r)unless blessed($r)&& ($r->isa('Term::Table::Cell')|| $r->isa('Term::Table::CellStack')|| $r->isa('Term::Table::Spacer'));$r->sanitize if$self->{+SANITIZE};$r->mark_tail if$self->{+MARK_TAIL};my$rs=$r->width;$c->{width}=$rs if$rs > $c->{width};$c->{count}++ if$rs;push @{$c->{rows}}=>$r}}@$cols=grep {$_->{count}> 0 || $self->{+NO_COLLAPSE}->{$_->{idx}}}@$cols if$self->{+COLLAPSE};my$current=sum(map {$_->{width}}@$cols);my$border=sum(BORDER_SIZE,$self->{+PAD},DIV_SIZE * (@$cols - 1));my$total=$current + $border;if ($total > $self->{+MAX_WIDTH}){my$fair=($self->{+MAX_WIDTH}- $border)/ @$cols;if ($fair < 1){return$self->{+_COLUMNS}=$cols if$self->{+ALLOW_OVERFLOW};croak "Table is too large ($total including $self->{+PAD} padding) to fit into max-width ($self->{+MAX_WIDTH})"}my$under=0;my@fix;for my$c (@$cols){if ($c->{width}> $fair){push@fix=>$c}else {$under += $c->{width}}}$fair=int(($self->{+MAX_WIDTH}- $border - $under)/ @fix);if ($fair < 1){return$self->{+_COLUMNS}=$cols if$self->{+ALLOW_OVERFLOW};croak "Table is too large ($total including $self->{+PAD} padding) to fit into max-width ($self->{+MAX_WIDTH})"}$_->{width}=$fair for@fix}$self->{+_COLUMNS}=$cols}sub render {my$self=shift;my$cols=$self->columns;for my$col (@$cols){for my$cell (@{$col->{rows}}){$cell->reset}}my$width=sum(BORDER_SIZE,$self->{+PAD},DIV_SIZE * @$cols,map {$_->{width}}@$cols);my$border='+' .join('+',map {'-' x ($_->{width}+ CELL_PAD_SIZE)}@$cols).'+';my$template='|' .join('|',map {my$w=$_->{width}+ CELL_PAD_SIZE;'%s'}@$cols).'|';my$spacer='|' .join('|',map {' ' x ($_->{width}+ CELL_PAD_SIZE)}@$cols).'|';my@out=($border);my ($row,$split,$found)=(0,0,0);while(1){my@row;my$is_spacer=0;for my$col (@$cols){my$r=$col->{rows}->[$row];unless($r){push@row=>'';next}my ($v,$vw);if ($r->isa('Term::Table::Cell')){my$lw=$r->border_left_width;my$rw=$r->border_right_width;$vw=$col->{width}- $lw - $rw;$v=$r->break->next($vw)}elsif ($r->isa('Term::Table::CellStack')){($v,$vw)=$r->break->next($col->{width})}elsif ($r->isa('Term::Table::Spacer')){$is_spacer=1}if ($is_spacer){last}elsif (defined$v){$found++;my$bcolor=$r->border_color || '';my$vcolor=$r->value_color || '';my$reset=$r->reset_color || '';if (my$need=$vw - uni_length($v)){$v .= ' ' x $need}my$rt="${reset}${bcolor}\%s${reset} ${vcolor}\%s${reset} ${bcolor}\%s${reset}";push@row=>sprintf($rt,$r->border_left || '',$v,$r->border_right || '')}else {push@row=>' ' x ($col->{width}+ 2)}}if (!grep {$_ && m/\S/}@row){last unless$found || $is_spacer;push@out=>$border if$row==0 && $self->{+SHOW_HEADER}&& @{$self->{+HEADER}};push@out=>$spacer if$split > 1 || $is_spacer;$row++;$split=0;$found=0;next}if ($split==1 && @out > 1 && $out[-2]ne $border && $out[-2]ne $spacer){my$last=pop@out;push@out=>($spacer,$last)}push@out=>sprintf($template,@row);$split++}pop@out while@out && $out[-1]eq $spacer;unless (USE_GCS){for my$row (@out){next unless$row =~ m/[^\x00-\x7F]/;unshift@out=>"Unicode::GCString is not installed, table may not display all unicode characters properly";last}}return (@out,$border)}sub display {my$self=shift;my ($fh)=@_;my@parts=map "$_\n",$self->render;print$fh @parts if$fh;print@parts}1;
TERM_TABLE

$fatpacked{"Term/Table/Cell.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_CELL';
  package Term::Table::Cell;use strict;use warnings;our$VERSION='0.016';use Term::Table::LineBreak();use Term::Table::Util qw/uni_length/;use List::Util qw/sum/;use Term::Table::HashBase qw/value border_left border_right _break _widths border_color value_color reset_color/;my%CHAR_MAP=("\n"=>"\\n\n","\a"=>'\\a',"\b"=>'\\b',"\e"=>'\\e',"\f"=>'\\f',"\r"=>'\\r',"\t"=>'\\t'," "=>' ',);sub init {my$self=shift;$self->{+VALUE}=defined$self->{+VALUE}? "$self->{+VALUE}" : ''}sub char_id {my$class=shift;my ($char)=@_;return "\\N{U+" .sprintf("\%X",ord($char))."}"}sub show_char {my$class=shift;my ($char,%props)=@_;return$char if$props{no_newline}&& $char eq "\n";return$CHAR_MAP{$char}|| $class->char_id($char)}sub sanitize {my$self=shift;$self->{+VALUE}=~ s/([\s\t\p{Zl}\p{C}\p{Zp}])/$self->show_char($1)/ge}sub mark_tail {my$self=shift;$self->{+VALUE}=~ s/([\s\t\p{Zl}\p{C}\p{Zp}])$/$1 eq ' ' ? $self->char_id($1) : $self->show_char($1, no_newline => 1)/se}sub value_width {my$self=shift;my$w=$self->{+_WIDTHS}||= {};return$w->{value}if defined$w->{value};my@parts=split /(\n)/,$self->{+VALUE};my$max=0;while (@parts){my$text=shift@parts;my$sep=shift@parts || '';my$len=uni_length("$text");$max=$len if$len > $max}return$w->{value}=$max}sub border_left_width {my$self=shift;$self->{+_WIDTHS}->{left}||= uni_length($self->{+BORDER_LEFT}|| '')}sub border_right_width {my$self=shift;$self->{+_WIDTHS}->{right}||= uni_length($self->{+BORDER_RIGHT}|| '')}sub width {my$self=shift;$self->{+_WIDTHS}->{all}||= sum(map {$self->$_}qw/value_width border_left_width border_right_width/)}sub break {my$self=shift;$self->{+_BREAK}||= Term::Table::LineBreak->new(string=>$self->{+VALUE})}sub reset {my$self=shift;delete$self->{+_BREAK}}1;
TERM_TABLE_CELL

$fatpacked{"Term/Table/CellStack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_CELLSTACK';
  package Term::Table::CellStack;use strict;use warnings;our$VERSION='0.016';use Term::Table::HashBase qw/-cells -idx/;use List::Util qw/max/;sub init {my$self=shift;$self->{+CELLS}||= []}sub add_cell {my$self=shift;push @{$self->{+CELLS}}=>@_}sub add_cells {my$self=shift;push @{$self->{+CELLS}}=>@_}sub sanitize {my$self=shift;$_->sanitize(@_)for @{$self->{+CELLS}}}sub mark_tail {my$self=shift;$_->mark_tail(@_)for @{$self->{+CELLS}}}my@proxy=qw{border_left border_right border_color value_color reset_color border_left_width border_right_width};for my$meth (@proxy){no strict 'refs';*$meth=sub {my$self=shift;$self->{+CELLS}->[$self->{+IDX}]->$meth}}for my$meth (qw{value_width width}){no strict 'refs';*$meth=sub {my$self=shift;return max(map {$_->$meth}@{$self->{+CELLS}})}}sub next {my$self=shift;my ($cw)=@_;while ($self->{+IDX}< @{$self->{+CELLS}}){my$cell=$self->{+CELLS}->[$self->{+IDX}];my$lw=$cell->border_left_width;my$rw=$cell->border_right_width;my$vw=$cw - $lw - $rw;my$it=$cell->break->next($vw);return ($it,$vw)if$it;$self->{+IDX}++}return}sub break {$_[0]}sub reset {my$self=shift;$self->{+IDX}=0;$_->reset for @{$self->{+CELLS}}}1;
TERM_TABLE_CELLSTACK

$fatpacked{"Term/Table/HashBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_HASHBASE';
  package Term::Table::HashBase;use strict;use warnings;our$VERSION='0.016';{no warnings 'once';$Term::Table::HashBase::HB_VERSION='0.008';*Term::Table::HashBase::ATTR_SUBS=\%Object::HashBase::ATTR_SUBS;*Term::Table::HashBase::ATTR_LIST=\%Object::HashBase::ATTR_LIST;*Term::Table::HashBase::VERSION=\%Object::HashBase::VERSION;*Term::Table::HashBase::CAN_CACHE=\%Object::HashBase::CAN_CACHE}require Carp;{no warnings 'once';$Carp::Internal{+__PACKAGE__}=1}BEGIN {*_isa=($] >= 5.010 && require mro)? \&mro::get_linear_isa : sub {no strict 'refs';my@packages=($_[0]);my%seen;for my$package (@packages){push@packages,grep!$seen{$_}++,@{"$package\::ISA"}}return \@packages}}my%SPEC=('^'=>{reader=>1,writer=>0,dep_writer=>1,read_only=>0,strip=>1},'-'=>{reader=>1,writer=>0,dep_writer=>0,read_only=>1,strip=>1},'>'=>{reader=>0,writer=>1,dep_writer=>0,read_only=>0,strip=>1},'<'=>{reader=>1,writer=>0,dep_writer=>0,read_only=>0,strip=>1},'+'=>{reader=>0,writer=>0,dep_writer=>0,read_only=>0,strip=>1},);sub import {my$class=shift;my$into=caller;my$ver=$Term::Table::HashBase::HB_VERSION || $Term::Table::HashBase::VERSION;$Term::Table::HashBase::VERSION{$into}=$ver if!$Term::Table::HashBase::VERSION{$into}|| $Term::Table::HashBase::VERSION{$into}> $ver;my$isa=_isa($into);my$attr_list=$Term::Table::HashBase::ATTR_LIST{$into}||= [];my$attr_subs=$Term::Table::HashBase::ATTR_SUBS{$into}||= {};my%subs=(($into->can('new')? (): (new=>\&_new)),(map %{$Term::Table::HashBase::ATTR_SUBS{$_}|| {}},@{$isa}[1 .. $#$isa]),(map {my$p=substr($_,0,1);my$x=$_;my$spec=$SPEC{$p}|| {reader=>1,writer=>1};substr($x,0,1)='' if$spec->{strip};push @$attr_list=>$x;my ($sub,$attr)=(uc$x,$x);$attr_subs->{$sub}=sub() {$attr};my%out=($sub=>$attr_subs->{$sub});$out{$attr}=sub {$_[0]->{$attr}}if$spec->{reader};$out{"set_$attr"}=sub {$_[0]->{$attr}=$_[1]}if$spec->{writer};$out{"set_$attr"}=sub {Carp::croak("'$attr' is read-only")}if$spec->{read_only};$out{"set_$attr"}=sub {Carp::carp("set_$attr() is deprecated");$_[0]->{$attr}=$_[1]}if$spec->{dep_writer};%out}@_),);no strict 'refs';*{"$into\::$_"}=$subs{$_}for keys%subs}sub attr_list {my$class=shift;my$isa=_isa($class);my%seen;my@list=grep {!$seen{$_}++}map {my@out;if (0.004 > ($Term::Table::HashBase::VERSION{$_}|| 0)){Carp::carp("$_ uses an inlined version of Term::Table::HashBase too old to support attr_list()")}else {my$list=$Term::Table::HashBase::ATTR_LIST{$_};@out=$list ? @$list : ()}@out}reverse @$isa;return@list}sub _new {my$class=shift;my$self;if (@_==1){my$arg=shift;my$type=ref($arg);if ($type eq 'HASH'){$self=bless({%$arg},$class)}else {Carp::croak("Not sure what to do with '$type' in $class constructor")unless$type eq 'ARRAY';my%proto;my@attributes=attr_list($class);while (@$arg){my$val=shift @$arg;my$key=shift@attributes or Carp::croak("Too many arguments for $class constructor");$proto{$key}=$val}$self=bless(\%proto,$class)}}else {$self=bless({@_},$class)}$Term::Table::HashBase::CAN_CACHE{$class}=$self->can('init')unless exists$Term::Table::HashBase::CAN_CACHE{$class};$self->init if$Term::Table::HashBase::CAN_CACHE{$class};$self}1;
TERM_TABLE_HASHBASE

$fatpacked{"Term/Table/LineBreak.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_LINEBREAK';
  package Term::Table::LineBreak;use strict;use warnings;our$VERSION='0.016';use Carp qw/croak/;use Scalar::Util qw/blessed/;use Term::Table::Util qw/uni_length/;use Term::Table::HashBase qw/string gcstring _len _parts idx/;sub init {my$self=shift;croak "string is a required attribute" unless defined$self->{+STRING}}sub columns {uni_length($_[0]->{+STRING})}sub break {my$self=shift;my ($len)=@_;$self->{+_LEN}=$len;$self->{+IDX}=0;my$str=$self->{+STRING}."";my@parts;my@chars=split //,$str;while (@chars){my$size=0;my$part='';until ($size==$len){my$char=shift@chars;$char='' unless defined$char;my$l=uni_length("$char");last unless$l;last if$char eq "\n";if ($size + $l > $len){unshift@chars=>$char;last}$size += $l;$part .= $char}shift@chars if$size==$len && @chars && $chars[0]eq "\n";until ($size==$len){$part .= ' ';$size += 1}push@parts=>$part}$self->{+_PARTS}=\@parts}sub next {my$self=shift;if (@_){my ($len)=@_;$self->break($len)if!$self->{+_LEN}|| $self->{+_LEN}!=$len}else {croak "String has not yet been broken" unless$self->{+_PARTS}}my$idx=$self->{+IDX}++;my$parts=$self->{+_PARTS};return undef if$idx >= @$parts;return$parts->[$idx]}1;
TERM_TABLE_LINEBREAK

$fatpacked{"Term/Table/Spacer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_SPACER';
  package Term::Table::Spacer;use strict;use warnings;our$VERSION='0.016';sub new {bless {},$_[0]}sub width {1}sub sanitize {}sub mark_tail {}sub reset {}1;
TERM_TABLE_SPACER

$fatpacked{"Term/Table/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TERM_TABLE_UTIL';
  package Term::Table::Util;use strict;use warnings;use Config qw/%Config/;our$VERSION='0.016';use Importer Importer=>'import';our@EXPORT_OK=qw/term_size USE_GCS USE_TERM_READKEY USE_TERM_SIZE_ANY uni_length/;sub DEFAULT_SIZE() {80}my$IO;BEGIN {open($IO,'>&',*STDOUT)or die "Could not clone STDOUT"}sub try(&) {my$code=shift;local ($@,$?,$!);my$ok=eval {$code->();1};my$err=$@;return ($ok,$err)}my ($tsa)=try {require Term::Size::Any;Term::Size::Any->import('chars')};my ($trk)=try {require Term::ReadKey};$trk &&= Term::ReadKey->can('GetTerminalSize');if (!-t $IO){*USE_TERM_READKEY=sub() {0};*USE_TERM_SIZE_ANY=sub() {0};*term_size=sub {return$ENV{TABLE_TERM_SIZE}if$ENV{TABLE_TERM_SIZE};return DEFAULT_SIZE}}elsif ($tsa){*USE_TERM_READKEY=sub() {0};*USE_TERM_SIZE_ANY=sub() {1};*_term_size=sub {my$size=chars($IO);return DEFAULT_SIZE if!$size;return DEFAULT_SIZE if$size < DEFAULT_SIZE;return$size}}elsif ($trk){*USE_TERM_READKEY=sub() {1};*USE_TERM_SIZE_ANY=sub() {0};*_term_size=sub {my$total;try {my@warnings;{local$SIG{__WARN__}=sub {push@warnings=>@_};($total)=Term::ReadKey::GetTerminalSize($IO)}@warnings=grep {$_ !~ m/Unable to get Terminal Size/}@warnings;warn@warnings if@warnings};return DEFAULT_SIZE if!$total;return DEFAULT_SIZE if$total < DEFAULT_SIZE;return$total}}else {*USE_TERM_READKEY=sub() {0};*USE_TERM_SIZE_ANY=sub() {0};*term_size=sub {return$ENV{TABLE_TERM_SIZE}if$ENV{TABLE_TERM_SIZE};return DEFAULT_SIZE}}if (USE_TERM_READKEY()|| USE_TERM_SIZE_ANY()){if (index($Config{sig_name},'WINCH')>= 0){my$changed=0;my$polled=-1;$SIG{WINCH}=sub {$changed++};my$size;*term_size=sub {return$ENV{TABLE_TERM_SIZE}if$ENV{TABLE_TERM_SIZE};unless ($changed==$polled){$polled=$changed;$size=_term_size()}return$size}}else {*term_size=sub {return$ENV{TABLE_TERM_SIZE}if$ENV{TABLE_TERM_SIZE};_term_size()}}}my ($gcs,$err)=try {require Unicode::GCString};if ($gcs){*USE_GCS=sub() {1};*uni_length=sub {Unicode::GCString->new($_[0])->columns}}else {*USE_GCS=sub() {0};*uni_length=sub {length($_[0])}}1;
TERM_TABLE_UTIL

$fatpacked{"Test/Deep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP';
  use strict;use warnings;package Test::Deep;use Carp qw(confess);use Test::Deep::Cache;use Test::Deep::Stack;use Test::Deep::RegexpVersion;require overload;use Scalar::Util;my$Test;unless (defined$Test::Deep::NoTest::NoTest){require Test::Builder;$Test=Test::Builder->new}our ($Stack,%Compared,$CompareCache,%WrapCache,$Shallow);our$VERSION='1.130';$VERSION =~ tr/_//d;require Exporter;our@ISA=qw(Exporter);our$Snobby=1;our$Expects=0;our$LeafWrapper;our$DNE=\"";our$DNE_ADDR=Scalar::Util::refaddr($DNE);my@constructors=(All=>"",Any=>"",Array=>"",ArrayEach=>"array_each",ArrayElementsOnly=>"",ArrayLength=>"",ArrayLengthOnly=>"",Blessed=>"",Boolean=>"bool",Code=>"",Hash=>"",HashEach=>"hash_each",HashKeys=>"",HashKeysOnly=>"",Ignore=>"",Isa=>"Isa",ListMethods=>"",Methods=>"",None=>"",Number=>"num",Obj=>"obj_isa",RefType=>"",Regexp=>"re",RegexpMatches=>"",RegexpOnly=>"",RegexpRef=>"",RegexpRefOnly=>"",ScalarRef=>"scalref",ScalarRefOnly=>"",Shallow=>"",String=>"str",);my@CONSTRUCTORS_FROM_CLASSES;while (my ($pkg,$name)=splice@constructors,0,2){$name=lc($pkg)unless$name;my$full_pkg="Test::Deep::$pkg";my$file="$full_pkg.pm";$file =~ s#::#/#g;my$sub=sub {require$file;return$full_pkg->new(@_)};{no strict 'refs';*{$name}=$sub}push@CONSTRUCTORS_FROM_CLASSES,$name}{our@EXPORT_OK=qw(descend render_stack cmp_details deep_diag true false);our%EXPORT_TAGS;$EXPORT_TAGS{preload}=[];$EXPORT_TAGS{v0}=[qw(Isa blessed obj_isa all any array array_each arrayelementsonly arraylength arraylengthonly bag bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash hash_each hashkeys hashkeysonly ignore isa listmethods methods noclass none noneof num re reftype regexpmatches regexponly regexpref regexprefonly scalarrefonly scalref set shallow str subbagof subhashof subsetof superbagof superhashof supersetof useclass) ];$EXPORT_TAGS{v1}=[qw(obj_isa all any array array_each arrayelementsonly arraylength arraylengthonly bag bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash hash_each hashkeys hashkeysonly ignore listmethods methods noclass none noneof num re reftype regexpmatches regexponly regexpref regexprefonly scalarrefonly scalref set shallow str subbagof subhashof subsetof superbagof superhashof supersetof useclass) ];our@EXPORT=@{$EXPORT_TAGS{v0 }};$EXPORT_TAGS{all}=[@EXPORT,@EXPORT_OK ]}sub import {my$self=shift;my$from_notest=grep {$_ eq '_notest'}@_;if ($from_notest){@_=grep {$_ ne '_notest'}@_}else {require Test::Builder;$Test=Test::Builder->new}my@sans_preload=grep {;$_ ne ':preload'}@_;if (@_!=@sans_preload){require Test::Deep::All;require Test::Deep::Any;require Test::Deep::Array;require Test::Deep::ArrayEach;require Test::Deep::ArrayElementsOnly;require Test::Deep::ArrayLength;require Test::Deep::ArrayLengthOnly;require Test::Deep::Blessed;require Test::Deep::Boolean;require Test::Deep::Cache::Simple;require Test::Deep::Cache;require Test::Deep::Class;require Test::Deep::Cmp;require Test::Deep::Code;require Test::Deep::Hash;require Test::Deep::HashEach;require Test::Deep::HashElements;require Test::Deep::HashKeys;require Test::Deep::HashKeysOnly;require Test::Deep::Ignore;require Test::Deep::Isa;require Test::Deep::ListMethods;require Test::Deep::Methods;require Test::Deep::MM;require Test::Deep::None;require Test::Deep::Number;require Test::Deep::Obj;require Test::Deep::Ref;require Test::Deep::RefType;require Test::Deep::Regexp;require Test::Deep::RegexpMatches;require Test::Deep::RegexpOnly;require Test::Deep::RegexpRef;require Test::Deep::RegexpRefOnly;require Test::Deep::RegexpVersion;require Test::Deep::ScalarRef;require Test::Deep::ScalarRefOnly;require Test::Deep::Set;require Test::Deep::Shallow;require Test::Deep::Stack;require Test::Deep::String}$self->export_to_level(1,$self,@_)}sub isa {if (@_==1){goto&Isa}else {goto&UNIVERSAL::isa}}sub cmp_deeply {my ($d1,$d2,$name)=@_;my ($ok,$stack)=cmp_details($d1,$d2);if (not $Test->ok($ok,$name)){my$diag=deep_diag($stack);$Test->diag($diag)}return$ok}sub cmp_details {my ($d1,$d2)=@_;local$Stack=Test::Deep::Stack->new;local$CompareCache=Test::Deep::Cache->new;local%WrapCache;my$ok=descend($d1,$d2);return ($ok,$Stack)}sub eq_deeply {my ($d1,$d2)=@_;my ($ok)=cmp_details($d1,$d2);return$ok}sub eq_deeply_cache {my ($d1,$d2,$name)=@_;local$Stack=Test::Deep::Stack->new;$CompareCache->local;my$ok=descend($d1,$d2);$CompareCache->finish($ok);return$ok}sub deep_diag {my$stack=shift;local$Stack=$stack;my$where=render_stack('$data',$stack);confess "No stack to diagnose" unless$stack;my$last=$stack->getLast;my$diag;my$message;my$got;my$expected;my$exp=$last->{exp};if (Scalar::Util::blessed($exp)){if ($exp->can("diagnostics")){$diag=$exp->diagnostics($where,$last);$diag =~ s/\n+$/\n/}else {if ($exp->can("diag_message")){$message=$exp->diag_message($where)}}}if (not defined$diag){$got=$exp->renderGot($last->{got})unless defined$got;$expected=$exp->renderExp unless defined$expected;$message="Compared $where" unless defined$message;$diag=<<EOM}return$diag}sub render_val {my$val=shift;my$rendered;if (defined$val){$rendered=ref($val)? (Scalar::Util::refaddr($val)eq $DNE_ADDR ? "Does not exist" : overload::StrVal($val)): qq('$val')}else {$rendered="undef"}return$rendered}sub descend {my ($d1,$d2)=@_;if (!ref$d1 and!ref$d2){if (defined$d1){return 1 if defined$d2 and $d1 eq $d2}else {return 1 if!defined$d2}}if (!$Expects and Scalar::Util::blessed($d1)and $d1->isa("Test::Deep::Cmp")){my$where=$Stack->render('$data');confess "Found a special comparison in $where\nYou can only use specials in the expects structure"}if (ref$d1 and ref$d2){if ($Expects and Scalar::Util::blessed($d1)and $d1->isa("Test::Deep::Cmp")){return 0 unless Test::Deep::blessed(Scalar::Util::blessed($d2))->descend($d1);if ($d1->can("compare")){return$d1->compare($d2)}}my$s1=Scalar::Util::refaddr($d1);my$s2=Scalar::Util::refaddr($d2);if ($s1 eq $s2){return 1}if ($CompareCache->cmp($d1,$d2)){return 1}else {$CompareCache->add($d1,$d2)}}$d2=wrap($d2);$Stack->push({exp=>$d2,got=>$d1});if (ref($d1)and (Scalar::Util::refaddr($d1)==$DNE_ADDR)){return 0}if ($d2->descend($d1)){$Stack->pop;return 1}else {return 0}}sub wrap {my$data=shift;my$class=Scalar::Util::blessed($data);return$data if defined$class and $data->isa("Test::Deep::Cmp");if (defined$class and $data->can('as_test_deep_cmp')){my$cmp=$data->as_test_deep_cmp;return$cmp if$cmp->isa('Test::Deep::Cmp');Carp::confess("object in expected structure provides as_test_deep_cmp but it did not return a Test::Deep::Cmp")}my$reftype=_td_reftype($data);my$cmp;if($reftype eq ''){$cmp=$Test::Deep::LeafWrapper ? $Test::Deep::LeafWrapper->($data): shallow($data)}else {my$addr=Scalar::Util::refaddr($data);return$WrapCache{$addr}if$WrapCache{$addr};if($reftype eq 'ARRAY'){$cmp=array($data)}elsif($reftype eq 'HASH'){$cmp=hash($data)}elsif($reftype eq 'SCALAR' or $reftype eq 'REF'){$cmp=scalref($data)}elsif(($reftype eq 'Regexp')or ($reftype eq 'REGEXP')){$cmp=regexpref($data)}else {$cmp=$Test::Deep::LeafWrapper ? $Test::Deep::LeafWrapper->($data): shallow($data)}$WrapCache{$addr}=$cmp}return$cmp}sub _td_reftype {my$val=shift;my$reftype=Scalar::Util::reftype($val);return '' unless defined$reftype;return$reftype unless$Test::Deep::RegexpVersion::OldStyle;my$blessed=Scalar::Util::blessed($val);return$reftype unless defined$blessed;if ($blessed && $blessed eq "Regexp" and $reftype eq "SCALAR"){$reftype="Regexp"}return$reftype}sub render_stack {my ($var,$stack)=@_;return$stack->render($var)}sub cmp_methods {local$Test::Builder::Level=$Test::Builder::Level + 1;return cmp_deeply(shift,methods(@{shift()}),shift)}sub requireclass {require Test::Deep::Class;my$val=shift;return Test::Deep::Class->new(1,$val)}*useclass=\&requireclass;sub noclass {require Test::Deep::Class;my$val=shift;return Test::Deep::Class->new(0,$val)}sub set {require Test::Deep::Set;return Test::Deep::Set->new(1,"",@_)}sub supersetof {require Test::Deep::Set;return Test::Deep::Set->new(1,"sup",@_)}sub subsetof {require Test::Deep::Set;return Test::Deep::Set->new(1,"sub",@_)}sub noneof {require Test::Deep::Set;return Test::Deep::Set->new(1,"none",@_)}sub cmp_set {local$Test::Builder::Level=$Test::Builder::Level + 1;return cmp_deeply(shift,set(@{shift()}),shift)}sub bag {require Test::Deep::Set;return Test::Deep::Set->new(0,"",@_)}sub superbagof {require Test::Deep::Set;return Test::Deep::Set->new(0,"sup",@_)}sub subbagof {require Test::Deep::Set;return Test::Deep::Set->new(0,"sub",@_)}sub cmp_bag {local$Test::Builder::Level=$Test::Builder::Level + 1;my$ref=ref($_[1])|| "";confess "Argument 2 to cmp_bag is not an ARRAY ref (".render_val($_[1]).")" unless$ref eq "ARRAY";return cmp_deeply(shift,bag(@{shift()}),shift)}sub superhashof {require Test::Deep::Hash;my$val=shift;return Test::Deep::SuperHash->new($val)}sub subhashof {require Test::Deep::Hash;my$val=shift;return Test::Deep::SubHash->new($val)}sub true {bool(1)}sub false {bool(0)}sub builder {if (@_){$Test=shift}return$Test}1;
  $message
     got : $got
  expect : $expected
  EOM
TEST_DEEP

$fatpacked{"Test/Deep/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ALL';
  use strict;use warnings;package Test::Deep::All;use Scalar::Util ();use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {(Scalar::Util::blessed($_)&& $_->isa('Test::Deep::All'))? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;my$data=$self->data;my$index=1;for my$cmp (@{$self->{val}}){$data->{index}=$index;$index++;next if Test::Deep::descend($got,$cmp);return 0}return 1}sub render_stack {my$self=shift;my$var=shift;my$data=shift;my$max=@{$self->{val}};return "(Part $data->{index} of $max in $var)"}1;
TEST_DEEP_ALL

$fatpacked{"Test/Deep/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ANY';
  use strict;use warnings;package Test::Deep::Any;use Scalar::Util ();use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {(Scalar::Util::blessed($_)&& $_->isa('Test::Deep::Any'))? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;for my$cmp (@{$self->{val}}){return 1 if Test::Deep::eq_deeply_cache($got,$cmp)}return 0}sub renderExp {my$self=shift;my@expect=map {;Test::Deep::wrap($_)}@{$self->{val}};my$things=join(", ",map {$_->renderExp}@expect);return "Any of ( $things )"}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$got=$self->renderGot($last->{got});my$exp=$self->renderExp;my$diag=<<EOM;$diag =~ s/\n+$/\n/;return$diag}4;
  Comparing $where with Any
  got      : $got
  expected : $exp
  EOM
TEST_DEEP_ANY

$fatpacked{"Test/Deep/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAY';
  use strict;use warnings;package Test::Deep::Array;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless Test::Deep::descend($got,Test::Deep::arraylength(scalar @$exp));return 0 unless$self->test_class($got);return Test::Deep::descend($got,Test::Deep::arrayelementsonly($exp))}sub reset_arrow {return 0}1;
TEST_DEEP_ARRAY

$fatpacked{"Test/Deep/ArrayEach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYEACH';
  use strict;use warnings;package Test::Deep::ArrayEach;use Test::Deep::Cmp;use Scalar::Util ();sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return unless ref$got && Scalar::Util::reftype($got)eq 'ARRAY';my$exp=[($self->{val})x @$got ];return Test::Deep::descend($got,$exp)}sub renderExp {my$self=shift;my$exp=shift;return '[ ' .$self->SUPER::renderExp($self->{val}).', ... ]'}1;
TEST_DEEP_ARRAYEACH

$fatpacked{"Test/Deep/ArrayElementsOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYELEMENTSONLY';
  use strict;use warnings;package Test::Deep::ArrayElementsOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;for my$i (0..$#{$exp}){$data->{index}=$i;my$got_elem=$got->[$i];my$exp_elem=$exp->[$i];return 0 unless Test::Deep::descend($got_elem,$exp_elem)}return 1}sub render_stack {my$self=shift;my ($var,$data)=@_;$var .= "->" unless$Test::Deep::Stack->incArrow;$var .= "[$data->{index}]";return$var}sub reset_arrow {return 0}1;
TEST_DEEP_ARRAYELEMENTSONLY

$fatpacked{"Test/Deep/ArrayLength.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYLENGTH';
  use strict;use warnings;package Test::Deep::ArrayLength;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_reftype($got,"ARRAY");return Test::Deep::descend($got,Test::Deep::arraylengthonly($exp))}1;
TEST_DEEP_ARRAYLENGTH

$fatpacked{"Test/Deep/ArrayLengthOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYLENGTHONLY';
  use strict;use warnings;package Test::Deep::ArrayLengthOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$len=$self->{val};return @$got==$len}sub render_stack {my$self=shift;my ($var,$data)=@_;return "array length of $var"}sub renderVal {my$self=shift;my$val=shift;return "array with $val element(s)"}sub renderGot {my$self=shift;my$got=shift;return$self->renderVal(@$got + 0)}sub renderExp {my$self=shift;return$self->renderVal($self->{val})}1;
TEST_DEEP_ARRAYLENGTHONLY

$fatpacked{"Test/Deep/Blessed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_BLESSED';
  use strict;use warnings;package Test::Deep::Blessed;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$blessed=blessed($got);return Test::Deep::descend($blessed,Test::Deep::shallow($exp))}sub render_stack {my$self=shift;my$var=shift;return "blessed($var)"}sub renderGot {my$self=shift;my$got=shift;$self->SUPER::renderGot(blessed($got))}1;
TEST_DEEP_BLESSED

$fatpacked{"Test/Deep/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_BOOLEAN';
  use strict;use warnings;package Test::Deep::Boolean;use Test::Deep::Cmp;sub init {my$self=shift;$self->{val}=shift()? 1 : 0}sub descend {my$self=shift;my$got=shift;return!($got xor $self->{val})}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a boolean"}sub renderExp {my$self=shift;$self->renderGot($self->{val})}sub renderGot {my$self=shift;my$val=shift;return ($val ? "true" : "false")." (".Test::Deep::render_val($val).")"}1;
TEST_DEEP_BOOLEAN

$fatpacked{"Test/Deep/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CACHE';
  use strict;use warnings;package Test::Deep::Cache;use Test::Deep::Cache::Simple;sub new {my$pkg=shift;my$self=bless {},$pkg;$self->{expects}=[Test::Deep::Cache::Simple->new];$self->{normal}=[Test::Deep::Cache::Simple->new];$self->local;return$self}sub add {my$self=shift;my$type=$self->type;$self->{$type}->[-1]->add(@_)}sub cmp {my$self=shift;my$type=$self->type;for my$cache (@{$self->{$type}}){return 1 if$cache->cmp(@_)}return 0}sub local {my$self=shift;for my$type (qw(expects normal)){push(@{$self->{$type}},Test::Deep::Cache::Simple->new)}}sub finish {my$self=shift;my$keep=shift;for my$type (qw(expects normal)){my$caches=$self->{$type};my$last=pop @$caches;$caches->[-1]->absorb($last)if$keep}}sub type {return$Test::Deep::Expects ? "expects" : "normal"}1;
TEST_DEEP_CACHE

$fatpacked{"Test/Deep/Cache/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CACHE_SIMPLE';
  use strict;use warnings;package Test::Deep::Cache::Simple;use Carp qw(confess);use Scalar::Util qw(refaddr);BEGIN {if (grep /^weaken$/,@Scalar::Util::EXPORT_FAIL){*weaken=sub {}}else {Scalar::Util->import('weaken')}}sub new {my$pkg=shift;my$self=bless {},$pkg;return$self}sub add {my$self=shift;my ($d1,$d2)=@_;{local$SIG{__DIE__};local $@;eval{weaken($d1)};eval{weaken($d2)}}$self->{fn_get_key(@_)}=[$d1,$d2]}sub cmp {my$self=shift;my$key=fn_get_key(@_);my$pair=$self->{$key};if (ref($pair->[0])and ref($pair->[1])){return 1}else {delete$self->{$key};return 0}}sub absorb {my$self=shift;my$other=shift;@{$self}{keys %$other}=values %$other}sub fn_get_key {return join(",",sort (map {refaddr($_)}@_))}1;
TEST_DEEP_CACHE_SIMPLE

$fatpacked{"Test/Deep/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CLASS';
  use strict;use warnings;package Test::Deep::Class;use Test::Deep::Cmp;sub init {my$self=shift;my$snobby=shift;my$val=shift;$self->{snobby}=$snobby;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;local$Test::Deep::Snobby=$self->{snobby};Test::Deep::wrap($self->{val})->descend($got)}1;
TEST_DEEP_CLASS

$fatpacked{"Test/Deep/Cmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CMP';
  use strict;use warnings;package Test::Deep::Cmp;use overload '&'=>\&make_all,'|'=>\&make_any,'""'=>\&string,fallback=>1,;use Scalar::Util ();sub import {my$pkg=shift;my$callpkg=caller();if ($callpkg =~ /^Test::Deep::/){no strict 'refs';push @{$callpkg."::ISA"},$pkg}}sub new {my$pkg=shift;my$self=bless {},$pkg;$self->init(@_);return$self}sub init {}sub make_all {my ($e1,$e2)=@_;return Test::Deep::all($e1,$e2)}sub make_any {my ($e1,$e2)=@_;return Test::Deep::any($e1,$e2)}sub cmp {my ($a1,$a2,$rev)=@_;($a1,$a2)=($a2,$a1)if$rev;return (overload::StrVal($a1)cmp overload::StrVal($a2))}sub string {my$self=shift;return overload::StrVal($self)}sub render_stack {my$self=shift;my$var=shift;return$var}sub renderExp {my$self=shift;return$self->renderGot($self->{val})}sub renderGot {my$self=shift;return Test::Deep::render_val(@_)}sub reset_arrow {return 1}sub data {my$self=shift;return$Test::Deep::Stack->getLast}1;
TEST_DEEP_CMP

$fatpacked{"Test/Deep/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CODE';
  use strict;use warnings;package Test::Deep::Code;use Test::Deep::Cmp;sub init {my$self=shift;my$code=shift || die "No coderef supplied";$self->{code}=$code}sub descend {my$self=shift;my$got=shift;my ($ok,$diag)=&{$self->{code}}($got);$self->data->{diag}=$diag;return$ok}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$error=$last->{diag};my$data=Test::Deep::render_val($last->{got});my$diag=<<EOM;if (defined($error)){$diag .= <<EOM}else {$diag .= <<EOM}return$diag}1;
  Ran coderef at $where on
  
  $data
  EOM
  and it said
  $error
  EOM
  it failed but it didn't say why.
  EOM
TEST_DEEP_CODE

$fatpacked{"Test/Deep/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASH';
  use strict;use warnings;package Test::Deep::Hash;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;return 0 unless Test::Deep::descend($got,$self->hash_keys($exp));return 0 unless$self->test_class($got);return Test::Deep::descend($got,$self->hash_elements($exp))}sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::HashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::HashKeys->new(keys %$exp)}sub reset_arrow {return 0}package Test::Deep::SuperHash;use base 'Test::Deep::Hash';sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::SuperHashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::SuperHashKeys->new(keys %$exp)}package Test::Deep::SubHash;use base 'Test::Deep::Hash';sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::SubHashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::SubHashKeys->new(keys %$exp)}1;
TEST_DEEP_HASH

$fatpacked{"Test/Deep/HashEach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHEACH';
  use strict;use warnings;package Test::Deep::HashEach;use Test::Deep::Cmp;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my%exp;@exp{keys %$got}=($self->{val})x (keys %$got);return Test::Deep::descend($got,\%exp)}1;
TEST_DEEP_HASHEACH

$fatpacked{"Test/Deep/HashElements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHELEMENTS';
  use strict;use warnings;package Test::Deep::HashElements;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;my$master=$self->getMaster($got,$exp);for my$key (keys %$master){$data->{index}=$key;my$got_elem=exists$got->{$key}? $got->{$key}: $Test::Deep::DNE;my$exp_elem=exists$exp->{$key}? $exp->{$key}: $Test::Deep::DNE;next if Test::Deep::descend($got_elem,$exp_elem);return 0}return 1}sub getMaster {my$self=shift;my ($got,$exp)=@_;return keys %$got > keys %$exp ? $got : $exp}sub render_stack {my$self=shift;my ($var,$data)=@_;$var .= "->" unless$Test::Deep::Stack->incArrow;$var .= '{"'.quotemeta($data->{index}).'"}';return$var}sub reset_arrow {return 0}package Test::Deep::SuperHashElements;use base 'Test::Deep::HashElements';sub getMaster {my$self=shift;my ($got,$exp)=@_;return$exp}package Test::Deep::SubHashElements;use base 'Test::Deep::HashElements';sub getMaster {my$self=shift;my ($got,$exp)=@_;return$got}1;
TEST_DEEP_HASHELEMENTS

$fatpacked{"Test/Deep/HashKeys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHKEYS';
  use strict;use warnings;package Test::Deep::HashKeys;use Test::Deep::Ref;sub init {my$self=shift;my%keys;@keys{@_}=();$self->{val}=\%keys;$self->{keys}=[sort @_]}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_reftype($got,"HASH");return Test::Deep::descend($got,$self->hashkeysonly($exp))}sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::HashKeysOnly->new(keys %$exp)}package Test::Deep::SuperHashKeys;use base 'Test::Deep::HashKeys';sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::SuperHashKeysOnly->new(keys %$exp)}package Test::Deep::SubHashKeys;use base 'Test::Deep::HashKeys';sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::SubHashKeysOnly->new(keys %$exp)}1;
TEST_DEEP_HASHKEYS

$fatpacked{"Test/Deep/HashKeysOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHKEYSONLY';
  use strict;use warnings;package Test::Deep::HashKeysOnly;use Test::Deep::Ref;sub init {my$self=shift;my%keys;@keys{@_}=();$self->{val}=\%keys;$self->{keys}=[sort @_]}sub descend {my$self=shift;my$hash=shift;my$data=$self->data;my$exp=$self->{val};my%got;@got{keys %$hash}=();my@missing;my@extra;while (my ($key,$value)=each %$exp){if (exists$got{$key}){delete$got{$key}}else {push(@missing,$key)}}my@diags;if (@missing and (not $self->ignoreMissing)){push(@diags,"Missing: ".nice_list(\@missing))}if (%got and (not $self->ignoreExtra)){push(@diags,"Extra: ".nice_list([keys%got]))}if (@diags){$data->{diag}=join("\n",@diags);return 0}return 1}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$type=$self->{IgnoreDupes}? "Set" : "Bag";my$error=$last->{diag};my$diag=<<EOM;return$diag}sub nice_list {my$list=shift;return join(", ",(map {"'$_'"}sort @$list),)}sub ignoreMissing {return 0}sub ignoreExtra {return 0}package Test::Deep::SuperHashKeysOnly;use base 'Test::Deep::HashKeysOnly';sub ignoreMissing {return 0}sub ignoreExtra {return 1}package Test::Deep::SubHashKeysOnly;use base 'Test::Deep::HashKeysOnly';sub ignoreMissing {return 1}sub ignoreExtra {return 0}1;
  Comparing hash keys of $where
  $error
  EOM
TEST_DEEP_HASHKEYSONLY

$fatpacked{"Test/Deep/Ignore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_IGNORE';
  use strict;use warnings;package Test::Deep::Ignore;use Test::Deep::Cmp;my$Singleton=__PACKAGE__->SUPER::new;sub new {return$Singleton}sub descend {return 1}1;
TEST_DEEP_IGNORE

$fatpacked{"Test/Deep/Isa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ISA';
  use strict;use warnings;package Test::Deep::Isa;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return Scalar::Util::blessed($got)? $got->isa($self->{val}): ref($got)eq $self->{val}}sub diag_message {my$self=shift;my$where=shift;return "Checking class of $where with isa()"}sub renderExp {my$self=shift;return "blessed into or ref of type '$self->{val}'"}1;
TEST_DEEP_ISA

$fatpacked{"Test/Deep/ListMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_LISTMETHODS';
  use strict;use warnings;package Test::Deep::ListMethods;use base 'Test::Deep::Methods';sub call_method {my$self=shift;return [$self->SUPER::call_method(@_)]}sub render_stack {my$self=shift;my$var=$self->SUPER::render_stack(@_);return "[$var]"}1;
TEST_DEEP_LISTMETHODS

$fatpacked{"Test/Deep/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_MM';
  use strict;use warnings;package Test::Deep::MM;sub import {my$self=shift;my ($pkg)=caller();my$mpkg=$pkg."::Methods";for my$attr (@_){if ($attr =~ /^[a-z]/){no strict 'refs';*{$mpkg."::$attr"}=\&{$attr}}else {my$get_name=$mpkg."::get$attr";my$set_name=$mpkg."::set$attr";my$get_sub=sub {return $_[0]->{$attr}};my$set_sub=sub {return $_[0]->{$attr}=$_[1]};{no strict 'refs';*$get_name=$get_sub;*$set_name=$set_sub;push(@{$pkg."::ISA"},$mpkg)}}}}sub new {my$pkg=shift;my$self=bless {},$pkg;$self->init(@_);return$self}sub init {my$self=shift;while (@_){my$name=shift || confess("No name");my$method="set$name";$self->$method(shift)}}1;
TEST_DEEP_MM

$fatpacked{"Test/Deep/Methods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_METHODS';
  use strict;use warnings;package Test::Deep::Methods;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my@methods;while (@_){my$name=shift;my$value=shift;push(@methods,[ref($name)? $name : [$name ],$value ])}$self->{methods}=\@methods}sub descend {my$self=shift;my$got=shift;my$data=$self->data;for my$method (@{$self->{methods}}){$data->{method}=$method;my ($call,$exp_res)=@$method;my ($name,@args)=@$call;local $@;my$got_res;if (!eval {$got_res=$self->call_method($got,$call);1}){die $@ unless $@ =~ /\ACan't locate object method "\Q$name"/;$got_res=$Test::Deep::DNE}next if Test::Deep::descend($got_res,$exp_res);return 0}return 1}sub call_method {my$self=shift;my ($got,$call)=@_;my ($name,@args)=@$call;return$got->$name(@args)}sub render_stack {my$self=shift;my ($var,$data)=@_;my$method=$data->{method};my ($call,$expect)=@$method;my ($name,@args)=@$call;my$args=@args ? "(".join(", ",@args).")" : "";$var .= "->$name$args";return$var}1;
TEST_DEEP_METHODS

$fatpacked{"Test/Deep/NoTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NOTEST';
  use strict;use warnings;package Test::Deep::NoTest;our$NoTest;{local$NoTest=1;require Test::Deep}sub import {my$import=Test::Deep->can("import");my$pkg=shift;unshift(@_,"Test::Deep");push @_,'_notest';goto &$import}1;
TEST_DEEP_NOTEST

$fatpacked{"Test/Deep/None.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NONE';
  use strict;use warnings;package Test::Deep::None;use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {eval {$_->isa('Test::Deep::None')}? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;for my$cmp (@{$self->{val}}){return 0 if Test::Deep::eq_deeply_cache($got,$cmp)}return 1}sub renderExp {my$self=shift;my@expect=map {;Test::Deep::wrap($_)}@{$self->{val}};my$things=join(", ",map {$_->renderExp}@expect);return "None of ( $things )"}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$got=$self->renderGot($last->{got});my$exp=$self->renderExp;my$diag=<<EOM;$diag =~ s/\n+$/\n/;return$diag}1;
  Comparing $where with None
  got      : $got
  expected : $exp
  EOM
TEST_DEEP_NONE

$fatpacked{"Test/Deep/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NUMBER';
  use strict;use warnings;package Test::Deep::Number;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;$self->{val}=shift(@_)+ 0;$self->{tolerance}=shift}sub descend {my$self=shift;my$got=shift;$self->data->{got_string}=$got;{no warnings 'numeric';$got += 0}$self->data->{got}=$got;if (defined(my$tolerance=$self->{tolerance})){return abs($got - $self->{val})<= $tolerance}else {return$got==$self->{val}}}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a number"}sub renderGot {my$self=shift;my$val=shift;my$got_string=$self->data->{got_string};if ("$val" ne "$got_string"){$got_string=$self->SUPER::renderGot($got_string);return "$val ($got_string)"}else {return$val}}sub renderExp {my$self=shift;my$exp=$self->{val};if (defined(my$tolerance=$self->{tolerance})){return "$exp +/- $tolerance"}else {return$exp}}1;
TEST_DEEP_NUMBER

$fatpacked{"Test/Deep/Obj.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_OBJ';
  use strict;use warnings;package Test::Deep::Obj;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return Scalar::Util::blessed($got)&& $got->isa($self->{val})}sub diag_message {my$self=shift;my$where=shift;return "Checking class of $where with isa()"}sub renderExp {my$self=shift;return "blessed into '$self->{val}' or subclass of '$self->{val}'"}1;
TEST_DEEP_OBJ

$fatpacked{"Test/Deep/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REF';
  use strict;use warnings;package Test::Deep::Ref;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub test_class {my$self=shift;my$got=shift;my$exp=$self->{val};if ($Test::Deep::Snobby){return Test::Deep::descend($got,Test::Deep::blessed(blessed($exp)))}else {return 1}}sub test_reftype {my$self=shift;my$got=shift;my$reftype=shift;return Test::Deep::descend($got,Test::Deep::reftype($reftype))}1;
TEST_DEEP_REF

$fatpacked{"Test/Deep/RefType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REFTYPE';
  use strict;use warnings;package Test::Deep::RefType;use Test::Deep::Cmp;use Scalar::Util qw(reftype);sub init {my$self=shift;$self->{val}=shift}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$reftype=reftype($got);return Test::Deep::descend($reftype,Test::Deep::shallow($exp))}sub render_stack {my$self=shift;my$var=shift;return "reftype($var)"}sub renderGot {my$self=shift;my$got=shift;$self->SUPER::renderGot(reftype($got))}1;
TEST_DEEP_REFTYPE

$fatpacked{"Test/Deep/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXP';
  use strict;use warnings;package Test::Deep::Regexp;use Test::Deep::Cmp;use Test::Deep::RegexpMatches;sub init {my$self=shift;my$val=shift;$val=ref$val ? $val : qr/$val/;$self->{val}=$val;if (my$matches=shift){$self->{matches}=Test::Deep::regexpmatches($matches,$val);$self->{flags}=shift || ""}}sub descend {my$self=shift;my$got=shift;my$re=$self->{val};if (my$match_exp=$self->{matches}){my$flags=$self->{flags};my@match_got;if ($flags eq "g"){@match_got=$got =~ /$re/g}else {@match_got=$got =~ /$re/}if (@match_got){return Test::Deep::descend(\@match_got,$match_exp)}else {return 0}}else {return ($got =~ $re)? 1 : 0}}sub diag_message {my$self=shift;my$where=shift;return "Using Regexp on $where"}sub render_stack1 {my$self=shift;my$stack=shift;return "($stack =~ $self->{regex})"}sub renderExp {my$self=shift;return "$self->{val}"}sub renderGot {my$self=shift;my$got=shift;if (defined (my$class=Scalar::Util::blessed($got))){my$ostr=qq{$got};if ($ostr ne overload::StrVal($got)){return qq{'$ostr' (instance of $class)}}}return Test::Deep::render_val($got)}1;
TEST_DEEP_REGEXP

$fatpacked{"Test/Deep/RegexpMatches.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPMATCHES';
  use strict;use warnings;package Test::Deep::RegexpMatches;use Test::Deep::Array;use base 'Test::Deep::Array';use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$val=Test::Deep::array($val)unless blessed($val)and $val->isa("Test::Deep::Cmp");$self->{val}=$val;$self->{regex}=shift}sub descend {my$self=shift;my$got=shift;return Test::Deep::descend($got,$self->{val})}sub render_stack {my$self=shift;my$stack=shift;$stack="[$stack =~ $self->{regex}]";return$stack}sub reset_arrow {return 1}1;
TEST_DEEP_REGEXPMATCHES

$fatpacked{"Test/Deep/RegexpOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPONLY';
  use strict;use warnings;package Test::Deep::RegexpOnly;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$val=ref$val ? $val : qr/$val/;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$re=$self->{val};return$got =~ $self->{val}? 1 : 0}sub diag_message {my$self=shift;my$where=shift;return "Using Regexp on $where"}sub renderExp {my$self=shift;return "$self->{val}"}1;
TEST_DEEP_REGEXPONLY

$fatpacked{"Test/Deep/RegexpRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPREF';
  use strict;use warnings;package Test::Deep::RegexpRef;use Test::Deep::Ref;use Test::Deep::RegexpVersion;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};if ($Test::Deep::RegexpVersion::OldStyle){return 0 unless$self->test_class($got,"Regexp");return 0 unless$self->test_reftype($got,"SCALAR")}else {return 0 unless$self->test_reftype($got,"REGEXP")}return Test::Deep::descend($got,Test::Deep::regexprefonly($exp))}sub renderGot {my$self=shift;return shift().""}1;
TEST_DEEP_REGEXPREF

$fatpacked{"Test/Deep/RegexpRefOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPREFONLY';
  use strict;use warnings;package Test::Deep::RegexpRefOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return$got eq $exp}sub render_stack {my$self=shift;my ($var,$data)=@_;return "m/$var/"}sub renderGot {my$self=shift;return shift().""}1;
TEST_DEEP_REGEXPREFONLY

$fatpacked{"Test/Deep/RegexpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPVERSION';
  use strict;use warnings;package Test::Deep::RegexpVersion;our$OldStyle=($] < 5.011);1;
TEST_DEEP_REGEXPVERSION

$fatpacked{"Test/Deep/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SCALARREF';
  use strict;use warnings;package Test::Deep::ScalarRef;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_class($got);return 0 unless$self->test_reftype($got,Scalar::Util::reftype($exp));return Test::Deep::descend($got,Test::Deep::scalarrefonly($exp))}1;
TEST_DEEP_SCALARREF

$fatpacked{"Test/Deep/ScalarRefOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SCALARREFONLY';
  use strict;use warnings;package Test::Deep::ScalarRefOnly;use Test::Deep::Cmp;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return Test::Deep::descend($$got,$$exp)}sub render_stack {my$self=shift;my ($var,$data)=@_;return "\${$var}"}1;
TEST_DEEP_SCALARREFONLY

$fatpacked{"Test/Deep/Set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SET';
  use strict;use warnings;package Test::Deep::Set;use Test::Deep::Cmp;sub init {my$self=shift;$self->{IgnoreDupes}=shift;$self->{SubSup}=shift;$self->{val}=[];$self->add(@_)}sub descend {my$self=shift;my$d1=shift;my$d2=$self->{val};my$IgnoreDupes=$self->{IgnoreDupes};my$data=$self->data;my$SubSup=$self->{SubSup};my$type=$IgnoreDupes ? "Set" : "Bag";my$diag;if (ref$d1 ne 'ARRAY'){my$got=Test::Deep::render_val($d1);$diag=<<EOM}if (not $diag){my@got=@$d1;my@found;my@missing;for my$expect (@$d2){my$found=0;for (my$i=$#got;$i >= 0;$i--){if (Test::Deep::eq_deeply_cache($got[$i],$expect)){$found=1;push(@found,$expect);splice(@got,$i,1);last unless$IgnoreDupes}}push(@missing,$expect)unless$found}my@diags;if (@missing and $SubSup ne "sub" && $SubSup ne "none"){push(@diags,"Missing: ".nice_list(\@missing))}if (@got and $SubSup ne "sup" && $SubSup ne "none"){my$got=__PACKAGE__->new($IgnoreDupes,"",@got);push(@diags,"Extra: ".nice_list($got->{val}))}if (@found and $SubSup eq "none"){my$found=__PACKAGE__->new($IgnoreDupes,"",@found);push(@diags,"Extra: ".nice_list($found->{val}))}$diag=join("\n",@diags)}if ($diag){$data->{diag}=$diag;return 0}else {return 1}}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$type=$self->{IgnoreDupes}? "Set" : "Bag";$type="Sub$type" if$self->{SubSup}eq "sub";$type="Super$type" if$self->{SubSup}eq "sup";$type="NoneOf" if$self->{SubSup}eq "none";my$error=$last->{diag};my$diag=<<EOM;return$diag}sub add {my$self=shift;my@array=@_;my$IgnoreDupes=$self->{IgnoreDupes};my$already=$self->{val};local$Test::Deep::Expects=1;for my$new_elem (@array){my$want_push=1;my$push_this=$new_elem;for my$old_elem (@$already){if (Test::Deep::eq_deeply($new_elem,$old_elem)){$push_this=$old_elem;$want_push=!$IgnoreDupes;last}}push(@$already,$push_this)if$want_push}@$already=sort {(defined$a ? $a : "")cmp (defined$b ? $b : "")}@$already}sub nice_list {my$list=shift;my@scalars=grep!ref $_,@$list;my$refs=grep ref $_,@$list;my@ref_string="$refs reference" if$refs;$ref_string[0].= "s" if$refs > 1;return join(", ",(map {Test::Deep::render_val($_)}sort {(defined$a ? $a : "")cmp (defined$b ? $b : "")}@scalars),@ref_string)}sub compare {my$self=shift;my$other=shift;return 0 if$self->{IgnoreDupes}!=$other->{IgnoreDupes};return Test::Deep::descend($self->{val},$other->{val})}1;
  got    : $got
  expect : An array to use as a $type
  EOM
  Comparing $where as a $type
  $error
  EOM
TEST_DEEP_SET

$fatpacked{"Test/Deep/Shallow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SHALLOW';
  use strict;use warnings;package Test::Deep::Shallow;use Test::Deep::Cmp;use Scalar::Util qw(refaddr);sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$ok;if (!defined$got and!defined$exp){$ok=1}elsif (defined$got xor defined$exp){$ok=0}elsif (ref$got and ref$exp){$ok=refaddr($got)==refaddr($exp)}elsif (ref$got xor ref$exp){$ok=0}else {$ok=$got eq $exp}return$ok}1;
TEST_DEEP_SHALLOW

$fatpacked{"Test/Deep/Stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_STACK';
  use strict;use warnings;package Test::Deep::Stack;use Carp qw(confess);use Scalar::Util;use Test::Deep::MM qw(new init Stack Arrow);sub init {my$self=shift;$self->SUPER::init(@_);$self->setStack([])unless$self->getStack}sub push {my$self=shift;push(@{$self->getStack},@_)}sub pop {my$self=shift;return pop @{$self->getStack}}sub render {my$self=shift;my$var=shift;my$stack=$self->getStack;$self->setArrow(0);for my$data (@$stack){my$exp=$data->{exp};if (Scalar::Util::blessed($exp)and $exp->isa("Test::Deep::Cmp")){$var=$exp->render_stack($var,$data);$self->setArrow(0)if$exp->reset_arrow}else {confess "Don't know how to render '$exp'"}}return$var}sub getLast {my$self=shift;return$self->getStack->[-1]}sub incArrow {my$self=shift;my$a=$self->getArrow;$self->setArrow($a + 1);return$a}sub length {my$self=shift;return @{$self->getStack}+ 0}1;
TEST_DEEP_STACK

$fatpacked{"Test/Deep/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_STRING';
  use strict;use warnings;package Test::Deep::String;use Test::Deep::Cmp;sub init {my$self=shift;$self->{val}=shift}sub descend {my$self=shift;my$got=shift()."";$self->data->{got}=$got;return$got eq $self->{val}}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a string"}1;
TEST_DEEP_STRING

$fatpacked{"Test/FailWarnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FAILWARNINGS';
  use 5.008001;use strict;use warnings;package Test::FailWarnings;our$VERSION='0.008';use Test::More 0.86;use Cwd qw/getcwd/;use File::Spec;use Carp;our$ALLOW_DEPS=0;our@ALLOW_FROM=();my$ORIG_DIR=getcwd();sub import {my ($class,@args)=@_;croak("import arguments must be key/value pairs")unless@args % 2==0;my%opts=@args;$ALLOW_DEPS=$opts{'-allow_deps'};if ($opts{'-allow_from'}){@ALLOW_FROM=ref$opts{'-allow_from'}? @{$opts{'-allow_from'}}: $opts{'-allow_from'}}$SIG{__WARN__}=\&handler}sub handler {my$msg=shift;$msg='' unless defined$msg;chomp$msg;my ($package,$filename,$line)=_find_source();if ($ALLOW_DEPS){$filename=File::Spec->abs2rel($filename,$ORIG_DIR)if File::Spec->file_name_is_absolute($filename);return if$filename !~ /^(?:t|xt|lib|blib)/}return if grep {$package eq $_}@ALLOW_FROM;if ($msg !~ m/at .*? line \d/){chomp$msg;$msg="'$msg' at $filename line $line."}else {$msg="'$msg'"}my$builder=Test::More->builder;$builder->ok(0,"Test::FailWarnings should catch no warnings")or $builder->diag("Warning was $msg")}sub _find_source {my$i=1;while (1){my ($pkg,$filename,$line)=caller($i++);return caller($i - 2)unless defined$pkg;next if$pkg =~ /^(?:Carp|warnings)/;return ($pkg,$filename,$line)}}1;
TEST_FAILWARNINGS

$fatpacked{"Test/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FATAL';
  use strict;use warnings;package Test::Fatal;$Test::Fatal::VERSION='0.016';use Carp ();use Try::Tiny 0.07;use Exporter 5.57 'import';our@EXPORT=qw(exception);our@EXPORT_OK=qw(exception success dies_ok lives_ok);our ($REAL_TBL,$REAL_CALCULATED_TBL)=(1,1);sub exception (&) {my$code=shift;return try {my$incremented=defined$Test::Builder::Level ? $Test::Builder::Level - $REAL_CALCULATED_TBL : 0;local$Test::Builder::Level=$REAL_CALCULATED_TBL;if ($incremented){$Test::Builder::Level += 5;for my$i (1..$incremented){my$caller=caller($Test::Builder::Level - 2);if ($caller eq __PACKAGE__){$Test::Builder::Level=$Test::Builder::Level + 5}else {$Test::Builder::Level=$Test::Builder::Level + 1}}}local$REAL_CALCULATED_TBL=$Test::Builder::Level;local$Carp::MaxArgNums=-1;$code->();return undef}catch {return $_ if $_;my$problem=defined $_ ? 'false' : 'undef';Carp::confess("$problem exception caught by Test::Fatal::exception")}}sub success (&;@) {my$code=shift;return finally(sub {return if @_;$code->()},@_)}my$Tester;sub dies_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$tap_pos=$Tester->current_test;my$exception=exception(\&$code);$name ||= $tap_pos!=$Tester->current_test ? "...and code should throw an exception" : "code should throw an exception";my$ok=$Tester->ok($exception,$name);$ok or $Tester->diag("expected an exception but none was raised");return$ok}sub lives_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$tap_pos=$Tester->current_test;my$exception=exception(\&$code);$name ||= $tap_pos!=$Tester->current_test ? "...and code should not throw an exception" : "code should not throw an exception";my$ok=$Tester->ok(!$exception,$name);$ok or $Tester->diag("expected return but an exception was raised");return$ok}1;
TEST_FATAL

$fatpacked{"Test/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FILE';
  package Test::File;use strict;use vars qw(@EXPORT $VERSION);use Carp qw(carp);use Exporter qw(import);use File::Spec;use Test::Builder;@EXPORT=qw(file_exists_ok file_not_exists_ok file_empty_ok file_not_empty_ok file_size_ok file_max_size_ok file_min_size_ok file_readable_ok file_not_readable_ok file_writeable_ok file_writable_ok file_not_writeable_ok file_not_writable_ok file_executable_ok file_not_executable_ok file_mode_is file_mode_isnt file_mode_has file_mode_hasnt file_is_symlink_ok file_is_not_symlink_ok symlink_target_exists_ok symlink_target_is symlink_target_dangles_ok dir_exists_ok dir_contains_ok link_count_is_ok link_count_gt_ok link_count_lt_ok owner_is owner_isnt group_is group_isnt file_line_count_is file_line_count_isnt file_line_count_between file_contains_like file_contains_unlike file_contains_utf8_like file_contains_utf8_unlike file_contains_encoded_like file_contains_encoded_unlike file_mtime_gt_ok file_mtime_lt_ok file_mtime_age_ok);$VERSION='1.992';my$Test=Test::Builder->new();sub _is_plain_file {my$filename=_normalize(shift);my$message=do {if(!-e $filename){"does not exist"}elsif(!-f _){"is not a plain file"}elsif(-d _){"is a directory"}else {()}};if($message){$Test->diag("file [$filename] $message");return 0}return 1}sub _normalize {my$file=shift;return unless defined$file;return$file =~ m|/| ? File::Spec->catfile(split m|/|,$file): $file}sub _win32 {return 0 if $^O eq 'darwin';return$ENV{PRETEND_TO_BE_WIN32}if defined$ENV{PRETEND_TO_BE_WIN32};return $^O =~ m/Win/ || $^O eq 'msys'}sub _no_symlinks_here {!eval {symlink("","");1}}sub _obviously_non_multi_user {for my$os (qw(dos MacOS)){return 1 if $^O eq $os}return 0 if $^O eq 'MSWin32';eval {my$holder=getpwuid(0)};return 1 if $@;eval {my$holder=getgrgid(0)};return 1 if $@;return 0}sub file_exists_ok {my$filename=_normalize(shift);my$name=shift || "$filename exists";my$ok=-e $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] does not exist");$Test->ok(0,$name)}}sub file_not_exists_ok {my$filename=_normalize(shift);my$name=shift || "$filename does not exist";my$ok=not -e $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] exists");$Test->ok(0,$name)}}sub file_empty_ok {my$filename=_normalize(shift);my$name=shift || "$filename is empty";return$Test->ok(0,$name)unless _is_plain_file($filename);my$ok=-z $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] exists with non-zero size");$Test->ok(0,$name)}}sub file_not_empty_ok {my$filename=_normalize(shift);my$name=shift || "$filename is not empty";return$Test->ok(0,$name)unless _is_plain_file($filename);my$ok=not -z _;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] exists with zero size");$Test->ok(0,$name)}}sub file_size_ok {my$filename=_normalize(shift);my$expected=int shift;my$name=shift || "$filename has right size";return$Test->ok(0,$name)unless _is_plain_file($filename);my$ok=(-s $filename)==$expected;if($ok){$Test->ok(1,$name)}else {my$actual=-s $filename;$Test->diag("file [$filename] has actual size [$actual] not [$expected]");$Test->ok(0,$name)}}sub file_max_size_ok {my$filename=_normalize(shift);my$max=int shift;my$name=shift || "$filename is under $max bytes";return$Test->ok(0,$name)unless _is_plain_file($filename);my$ok=(-s $filename)<= $max;if($ok){$Test->ok(1,$name)}else {my$actual=-s $filename;$Test->diag("file [$filename] has actual size [$actual] " ."greater than [$max]");$Test->ok(0,$name)}}sub file_min_size_ok {my$filename=_normalize(shift);my$min=int shift;my$name=shift || "$filename is over $min bytes";return$Test->ok(0,$name)unless _is_plain_file($filename);my$ok=(-s $filename)>= $min;if($ok){$Test->ok(1,$name)}else {my$actual=-s $filename;$Test->diag("file [$filename] has actual size "."[$actual] less than [$min]");$Test->ok(0,$name)}}sub _ENOFILE () {-1}sub _ECANTOPEN () {-2}sub _ENOTPLAIN () {-3}sub _file_line_counter {my$filename=shift;return _ENOFILE unless -e $filename;return _ENOTPLAIN unless -f $filename;return _ECANTOPEN unless open my($fh),"<",$filename;my$count=0;while(<$fh>){$count++}return$count}sub file_line_count_is {my$filename=_normalize(shift);my$expected=shift;my$name=do {no warnings 'uninitialized';shift || "$filename line count is $expected lines"};return$Test->ok(0,$name)unless _is_plain_file($filename);unless(defined$expected && int($expected)==$expected){no warnings 'uninitialized';$Test->diag("file_line_count_is expects a positive whole number for " ."the second argument. Got [$expected]");return$Test->ok(0,$name)}my$got=_file_line_counter($filename);if($got eq _ENOFILE){$Test->diag("file [$filename] does not exist");$Test->ok(0,$name)}elsif($got eq _ENOTPLAIN){$Test->diag("file [$filename] is not a plain file");$Test->ok(0,$name)}elsif($got==_ECANTOPEN){$Test->diag("file [$filename] could not be opened: \$! is [$!]");$Test->ok(0,$name)}elsif($got==$expected){$Test->ok(1,$name)}else {$Test->diag("expected [$expected] lines in [$filename], " ."got [$got] lines");$Test->ok(0,$name)}}sub file_line_count_isnt {my$filename=_normalize(shift);my$expected=shift;my$name=do {no warnings 'uninitialized';shift || "$filename line count is not $expected lines"};return$Test->ok(0,$name)unless _is_plain_file($filename);unless(defined$expected && int($expected)==$expected){no warnings 'uninitialized';$Test->diag("file_line_count_is expects a positive whole number for " ."the second argument. Got [$expected]");return$Test->ok(0,$name)}my$got=_file_line_counter($filename);if($got eq _ENOFILE){$Test->diag("file [$filename] does not exist");$Test->ok(0,$name)}elsif($got eq _ENOTPLAIN){$Test->diag("file [$filename] is not a plain file");$Test->ok(0,$name)}elsif($got==_ECANTOPEN){$Test->diag("file [$filename] could not be opened: \$! is [$!]");$Test->ok(0,$name)}elsif($got!=$expected){$Test->ok(1,$name)}else {$Test->diag("expected something other than [$expected] lines in [$filename], " ."but got [$got] lines");$Test->ok(0,$name)}}sub file_line_count_between {my$filename=_normalize(shift);my$min=shift;my$max=shift;my$name=do {no warnings 'uninitialized';shift || "$filename line count is between [$min] and [$max] lines"};return$Test->ok(0,$name)unless _is_plain_file($filename);for my$ref (\$min,\$max){unless(defined $$ref && int($$ref)==$$ref){no warnings 'uninitialized';$Test->diag("file_line_count_between expects positive whole numbers for " ."the second and third arguments. Got [$min] and [$max]");return$Test->ok(0,$name)}}my$got=_file_line_counter($filename);if($got eq _ENOFILE){$Test->diag("file [$filename] does not exist");$Test->ok(0,$name)}elsif($got eq _ENOTPLAIN){$Test->diag("file [$filename] is not a plain file");$Test->ok(0,$name)}elsif($got==_ECANTOPEN){$Test->diag("file [$filename] could not be opened: \$! is [$!]");$Test->ok(0,$name)}elsif($min <= $got and $got <= $max){$Test->ok(1,$name)}else {$Test->diag("expected a line count between [$min] and [$max] " ."in [$filename], but got [$got] lines");$Test->ok(0,$name)}}sub file_contains_like {local$Test::Builder::Level=$Test::Builder::Level + 1;_file_contains(like=>"contains",undef,@_)}sub file_contains_unlike {local$Test::Builder::Level=$Test::Builder::Level + 1;_file_contains(unlike=>"doesn't contain",undef,@_)}sub file_contains_utf8_like {local$Test::Builder::Level=$Test::Builder::Level + 1;_file_contains(like=>"contains",'UTF-8',@_)}sub file_contains_utf8_unlike {local$Test::Builder::Level=$Test::Builder::Level + 1;_file_contains(unlike=>"doesn't contain",'UTF-8',@_)}sub file_contains_encoded_like {local$Test::Builder::Level=$Test::Builder::Level + 1;my$filename=shift;my$encoding=shift;_file_contains(like=>"contains",$encoding,$filename,@_)}sub file_contains_encoded_unlike {local$Test::Builder::Level=$Test::Builder::Level + 1;my$filename=shift;my$encoding=shift;_file_contains(unlike=>"doesn't contain",$encoding,$filename,@_)}sub _file_contains {my$method=shift;my$verb=shift;my$encoding=shift;my$filename=_normalize(shift);my$patterns=shift;my$name=shift;my (@patterns,%patterns);if (ref$patterns eq 'ARRAY'){@patterns=@$patterns;%patterns=map {$_=>$name || "$filename $verb $_"}@patterns}else {@patterns=($patterns);%patterns=($patterns=>$name || "$filename $verb $patterns")}$name=$patterns{$patterns[0]};return$Test->ok(0,$name)unless _is_plain_file($filename);unless(-r $filename){$Test->diag("file [$filename] is not readable");return$Test->ok(0,$name)}my$file_contents;{unless (open(FH,$filename)){$Test->diag("file [$filename] could not be opened: \$! is [$!]");return$Test->ok(0,$name)}if (defined$encoding){binmode FH,":encoding($encoding)"}local $/=undef;$file_contents=<FH>;close FH}for my$p (@patterns){$Test->$method($file_contents,$p,$patterns{$p})}}sub file_readable_ok {my$filename=_normalize(shift);my$name=shift || "$filename is readable";my$ok=-r $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] is not readable");$Test->ok(0,$name)}}sub file_not_readable_ok {my$filename=_normalize(shift);my$name=shift || "$filename is not readable";my$ok=not -r $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] is readable");$Test->ok(0,$name)}}sub file_writeable_ok {carp "file_writeable_ok is now file_writable_ok";&file_writable_ok}sub file_writable_ok {my$filename=_normalize(shift);my$name=shift || "$filename is writable";my$ok=-w $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] is not writable");$Test->ok(0,$name)}}sub file_not_writeable_ok {carp "file_not_writeable_ok is now file_not_writable_ok";&file_not_writable_ok}sub file_not_writable_ok {my$filename=_normalize(shift);my$name=shift || "$filename is not writable";my$ok=not -w $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] is writable");$Test->ok(0,$name)}}sub file_executable_ok {if(_win32()){$Test->skip("file_executable_ok doesn't work on Windows");return}my$filename=_normalize(shift);my$name=shift || "$filename is executable";my$ok=-x $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] is not executable");$Test->ok(0,$name)}}sub file_not_executable_ok {if(_win32()){$Test->skip("file_not_executable_ok doesn't work on Windows");return}my$filename=_normalize(shift);my$name=shift || "$filename is not executable";my$ok=not -x $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] is executable");$Test->ok(0,$name)}}sub file_mode_is {if(_win32()){$Test->skip("file_mode_is doesn't work on Windows");return}my$filename=_normalize(shift);my$mode=shift;my$name=shift || sprintf("%s mode is %04o",$filename,$mode);my$ok=-e $filename && ((stat($filename))[2]& 07777)==$mode;if($ok){$Test->ok(1,$name)}else {$Test->diag(sprintf("file [%s] mode is not %04o",$filename,$mode));$Test->ok(0,$name)}}sub file_mode_isnt {if(_win32()){$Test->skip("file_mode_isnt doesn't work on Windows");return}my$filename=_normalize(shift);my$mode=shift;my$name=shift || sprintf("%s mode is not %04o",$filename,$mode);my$ok=not (-e $filename && ((stat($filename))[2]& 07777)==$mode);if($ok){$Test->ok(1,$name)}else {$Test->diag(sprintf("file [%s] mode is %04o",$filename,$mode));$Test->ok(0,$name)}}sub file_mode_has {if(_win32()){$Test->skip("file_mode_has doesn't work on Windows");return}my$filename=_normalize(shift);my$mode=shift;my$name=shift || sprintf("%s mode has all bits of %04o",$filename,$mode);my$present=-e $filename;my$gotmode=$present ? (stat($filename))[2]: undef;my$ok=$present && ($gotmode & $mode)==$mode;if($ok){$Test->ok(1,$name)}else {my$missing=($gotmode ^ $mode)& $mode;$Test->diag(sprintf("file [%s] mode is missing component %04o",$filename,$missing));$Test->ok(0,$name)}}sub file_mode_hasnt {if(_win32()){$Test->skip("file_mode_hasnt doesn't work on Windows");return}my$filename=_normalize(shift);my$mode=shift;my$name=shift || sprintf("%s mode has no bits of %04o",$filename,$mode);my$present=-e $filename;my$gotmode=$present ? (stat($filename))[2]: undef;my$ok=$present && ($gotmode & $mode)==0;if($ok){$Test->ok(1,$name)}else {my$bad=$gotmode & $mode;$Test->diag(sprintf("file [%s] mode has forbidden component %04o",$filename,$bad));$Test->ok(0,$name)}}sub file_is_symlink_ok {if(_no_symlinks_here()){$Test->skip("file_is_symlink_ok doesn't work on systems without symlinks");return}my$file=shift;my$name=shift || "$file is a symlink";if(-l $file){$Test->ok(1,$name)}else {$Test->diag("file [$file] is not a symlink");$Test->ok(0,$name)}}sub file_is_not_symlink_ok {if(_no_symlinks_here()){$Test->skip("file_is_symlink_ok doesn't work on systems without symlinks");return}my$file=shift;my$name=shift || "$file is not a symlink";unless(-e $file){$Test->diag("file [$file] does not exist");return$Test->ok(0,$name)}if(!-l $file){$Test->ok(1,$name)}else {$Test->diag("file [$file] is a symlink");$Test->ok(0,$name)}}sub symlink_target_exists_ok {if(_no_symlinks_here()){$Test->skip("symlink_target_exists_ok doesn't work on systems without symlinks");return}my$file=shift;my$dest=shift || readlink($file);my$name=shift || "$file is a symlink";unless(-l $file){$Test->diag("file [$file] is not a symlink");return$Test->ok(0,$name)}unless(-e $dest){$Test->diag("symlink [$file] points to non-existent target [$dest]");return$Test->ok(0,$name)}my$actual=readlink($file);unless($dest eq $actual){$Test->diag("symlink [$file] points to\n" ."         got: $actual\n" ."    expected: $dest\n");return$Test->ok(0,$name)}$Test->ok(1,$name)}sub symlink_target_dangles_ok {if(_no_symlinks_here()){$Test->skip("symlink_target_dangles_ok doesn't work on systems without symlinks");return}my$file=shift;my$dest=readlink($file);my$name=shift || "$file is a symlink";unless(-l $file){$Test->diag("file [$file] is not a symlink");return$Test->ok(0,$name)}if(-e $dest){$Test->diag("symlink [$file] points to existing file [$dest] but shouldn't");return$Test->ok(0,$name)}$Test->ok(1,$name)}sub symlink_target_is {if(_no_symlinks_here()){$Test->skip("symlink_target_is doesn't work on systems without symlinks");return}my$file=shift;my$dest=shift;my$name=shift || "symlink $file points to $dest";unless(-l $file){$Test->diag("file [$file] is not a symlink");return$Test->ok(0,$name)}my$actual_dest=readlink($file);my$link_error=$!;unless(defined$actual_dest){$Test->diag("symlink [$file] does not have a defined target");$Test->diag("readlink error: $link_error")if defined$link_error;return$Test->ok(0,$name)}if($dest eq $actual_dest){$Test->ok(1,$name)}else {$Test->ok(0,$name);$Test->diag("       got: $actual_dest");$Test->diag("  expected: $dest")}}sub symlink_target_is_absolute_ok {if(_no_symlinks_here()){$Test->skip("symlink_target_exists_ok doesn't work on systems without symlinks");return}my($from,$from_base,$to,$to_base,$name)=@_;my$link=readlink($from);my$link_err=defined($link)? '' : $!;my$link_abs=abs_path(rel2abs($link,$from_base));my$to_abs=abs_path(rel2abs($to,$to_base));if (defined($link_abs)&& defined($to_abs)&& $link_abs eq $to_abs){$Test->ok(1,$name)}else {$Test->ok(0,$name);$link ||= 'undefined';$link_abs ||= 'undefined';$to_abs ||= 'undefined';$Test->diag("    link: $from");$Test->diag("     got: $link");$Test->diag("    (abs): $link_abs");$Test->diag("  expected: $to");$Test->diag("    (abs): $to_abs");$Test->diag("  readlink() error: $link_err")if ($link_err)}}sub dir_exists_ok {my$filename=_normalize(shift);my$name=shift || "$filename is a directory";unless(-e $filename){$Test->diag("directory [$filename] does not exist");return$Test->ok(0,$name)}my$ok=-d $filename;if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] exists but is not a directory");$Test->ok(0,$name)}}sub dir_contains_ok {my$dirname=_normalize(shift);my$filename=_normalize(shift);my$name=shift || "directory $dirname contains file $filename";unless(-d $dirname){$Test->diag("directory [$dirname] does not exist");return$Test->ok(0,$name)}my$ok=-e File::Spec->catfile($dirname,$filename);if($ok){$Test->ok(1,$name)}else {$Test->diag("file [$filename] does not exist in directory $dirname");$Test->ok(0,$name)}}sub link_count_is_ok {my$file=shift;my$count=int(0 + shift);my$name=shift || "$file has a link count of [$count]";my$actual=(stat$file)[3];unless($actual==$count){$Test->diag("file [$file] points has [$actual] links: expected [$count]");return$Test->ok(0,$name)}$Test->ok(1,$name)}sub link_count_gt_ok {my$file=shift;my$count=int(0 + shift);my$name=shift || "$file has a link count of [$count]";my$actual=(stat$file)[3];unless($actual > $count){$Test->diag("file [$file] points has [$actual] links: "."expected more than [$count]");return$Test->ok(0,$name)}$Test->ok(1,$name)}sub link_count_lt_ok {my$file=shift;my$count=int(0 + shift);my$name=shift || "$file has a link count of [$count]";my$actual=(stat$file)[3];unless($actual < $count){$Test->diag("file [$file] points has [$actual] links: "."expected less than [$count]");return$Test->ok(0,$name)}$Test->ok(1,$name)}sub _dm_skeleton {no warnings 'uninitialized';if(_obviously_non_multi_user()){my$calling_sub=(caller(1))[3];$Test->skip($calling_sub ." only works on a multi-user OS");return 'skip'}my$filename=_normalize(shift);my$testing_for=shift;my$name=shift;unless(defined$filename){$Test->diag("file name not specified");return$Test->ok(0,$name)}unless(-e $filename){$Test->diag("file [$filename] does not exist");return$Test->ok(0,$name)}return}sub owner_is {my$filename=shift;my$owner=shift;my$name=shift || "$filename belongs to $owner";my$err=_dm_skeleton($filename,$owner,$name);return if(defined($err)&& $err eq 'skip');return$err if defined($err);my$owner_uid=_get_uid($owner);unless(defined$owner_uid){$Test->diag("user [$owner] does not exist on this system");return$Test->ok(0,$name)}my$file_uid=(stat$filename)[4];unless(defined$file_uid){$Test->skip("stat failed to return owner uid for $filename");return}return$Test->ok(1,$name)if$file_uid==$owner_uid;my$real_owner=(getpwuid$file_uid)[0];unless(defined$real_owner){$Test->diag("file does not belong to $owner");return$Test->ok(0,$name)}$Test->diag("file [$filename] belongs to $real_owner ($file_uid), "."not $owner ($owner_uid)");return$Test->ok(0,$name)}sub owner_isnt {my$filename=shift;my$owner=shift;my$name=shift || "$filename doesn't belong to $owner";my$err=_dm_skeleton($filename,$owner,$name);return if(defined($err)&& $err eq 'skip');return$err if defined($err);my$owner_uid=_get_uid($owner);unless(defined$owner_uid){return$Test->ok(1,$name)}my$file_uid=(stat$filename)[4];return$Test->ok(1,$name)if$file_uid!=$owner_uid;$Test->diag("file [$filename] belongs to $owner ($owner_uid)");return$Test->ok(0,$name)}sub group_is {my$filename=shift;my$group=shift;my$name=(shift || "$filename belongs to group $group");my$err=_dm_skeleton($filename,$group,$name);return if(defined($err)&& $err eq 'skip');return$err if defined($err);my$group_gid=_get_gid($group);unless(defined$group_gid){$Test->diag("group [$group] does not exist on this system");return$Test->ok(0,$name)}my$file_gid=(stat$filename)[5];unless(defined$file_gid){$Test->skip("stat failed to return group gid for $filename");return}return$Test->ok(1,$name)if$file_gid==$group_gid;my$real_group=(getgrgid$file_gid)[0];unless(defined$real_group){$Test->diag("file does not belong to $group");return$Test->ok(0,$name)}$Test->diag("file [$filename] belongs to $real_group ($file_gid), "."not $group ($group_gid)");return$Test->ok(0,$name)}sub group_isnt {my$filename=shift;my$group=shift;my$name=shift || "$filename does not belong to group $group";my$err=_dm_skeleton($filename,$group,$name);return if(defined($err)&& $err eq 'skip');return$err if defined($err);my$group_gid=_get_gid($group);my$file_gid=(stat$filename)[5];unless(defined$file_gid){$Test->skip("stat failed to return group gid for $filename");return}return$Test->ok(1,$name)if$file_gid!=$group_gid;$Test->diag("file [$filename] belongs to $group ($group_gid)");return$Test->ok(0,$name)}sub _get_uid {my$arg=shift;my$from_uid=(getpwuid($arg))[2]if$arg =~ /\A[0-9]+\z/;my$from_nam=(getpwnam($arg))[2];return do {if(defined$from_uid and not defined$from_nam){$arg}elsif(not defined$from_uid and defined$from_nam){$from_nam}elsif(not defined$from_uid and not defined$from_nam){undef}else {carp("Found both a UID or name for <$arg>. Guessing the UID is <$arg>.");$arg}}}sub _get_gid {my$arg=shift;my$from_gid=(getgrgid($arg))[2]if$arg =~ /\A[0-9]+\z/;my$from_nam=(getgrnam($arg))[2];return do {if(defined$from_gid and not defined$from_nam){$arg}elsif(not defined$from_gid and defined$from_nam){$from_nam}elsif(not defined$from_gid and not defined$from_nam){undef}else {carp("Found both a GID or name for <$arg>. Guessing the GID is <$arg>.");$arg}}}sub file_mtime_age_ok {my$filename=shift;my$within_secs=shift || 0;my$name=shift || "$filename mtime within $within_secs seconds of current time";my$time=time();my$filetime=_stat_file($filename,9);return if ($filetime==-1);return$Test->ok(1,$name)if ($filetime + $within_secs > $time-1);$Test->diag("file [$filename] mtime [$filetime] is not $within_secs seconds within current system time [$time].");return$Test->ok(0,$name)}sub file_mtime_gt_ok {my$filename=shift;my$time=int shift;my$name=shift || "$filename mtime is greater than unix timestamp $time";my$filetime=_stat_file($filename,9);return if ($filetime==-1);return$Test->ok(1,$name)if ($filetime > $time);$Test->diag("file [$filename] mtime [$filetime] not greater than $time");$Test->ok(0,$name)}sub file_mtime_lt_ok {my$filename=shift;my$time=int shift;my$name=shift || "$filename mtime less than unix timestamp $time";my$filetime=_stat_file($filename,9);return if ($filetime==-1);return$Test->ok(1,$name)if ($filetime < $time);$Test->diag("file [$filename] mtime [$filetime] not less than $time");$Test->ok(0,$name)}sub _stat_file {my$filename=_normalize(shift);my$attr_pos=shift;unless(defined$filename){$Test->diag("file name not specified");return 0}unless(-e $filename){$Test->diag("file [$filename] does not exist");return 0}my$filetime=(stat($filename))[$attr_pos];unless($filetime){$Test->diag("stat of $filename failed");return -1}return$filetime}"The quick brown fox jumped over the lazy dog";
TEST_FILE

$fatpacked{"Test/Needs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_NEEDS';
  package Test::Needs;use strict;use warnings;no warnings 'once';our$VERSION='0.002009';$VERSION =~ tr/_//d;BEGIN {*_WORK_AROUND_HINT_LEAKAGE ="$]" < 5.011 &&!("$]" >= 5.009004 && "$]" < 5.010001)? sub(){1}: sub(){0};*_WORK_AROUND_BROKEN_MODULE_STATE ="$]" < 5.009 ? sub(){1}: sub(){0};if ("$]" >= 5.006001 && "$]" <= 5.006002){require utf8;utf8->import}}our@EXPORT=qw(test_needs);our$Level=0;sub _try_require {local %^H if _WORK_AROUND_HINT_LEAKAGE;my ($module)=@_;(my$file="$module.pm")=~ s{::|'}{/}g;my$err;{local $@;eval {require$file}or $err=$@}if (defined$err){delete$INC{$file}if _WORK_AROUND_BROKEN_MODULE_STATE;die$err unless$err =~ /\ACan't locate \Q$file\E/;return!1}!0}sub _croak {my$message=join '',@_;my$i=1;while (my ($p,$f,$l)=caller($i++)){next if$p =~ /\ATest::Needs(?:::|\z)/;die "$message at $f line $l.\n"}die$message}sub _try_version {my ($module,$version)=@_;local $@;!!eval {$module->VERSION($version);1}}sub _numify_version {for ($_[0]){return !$_ ? 0 : /^[0-9]+(?:\.[0-9]+)?$/ ? sprintf('%.6f',$_): /^v?([0-9]+(?:\.[0-9]+)*)$/ ? sprintf('%d.%03d%03d',((split /\./,$1),0,0)[0..2]): /^([\x05-\x07])(.*)$/s ? sprintf('%d.%03d%03d',((map ord,/(.)/gs),0,0)[0..2]): _croak qq{version "$_" does not look like a number}}}sub _find_missing {my@bad=map {my ($module,$version)=@$_;$module eq 'perl' ? do {$version=_numify_version($version);"$]" < $version ? (sprintf "perl %s (have %.6f)",$version,$]): ()}: $module =~ /^\d|[^\w:]|:::|[^:]:[^:]|^:|:$/ ? _croak sprintf qq{"%s" does not look like a module name},$module : _try_require($module)? (defined$version &&!_try_version($module,$version)? "$module $version (have ".(defined$module->VERSION ? $module->VERSION : 'undef').')' : ()): $version ? "$module $version" : $module}_pairs(@_);@bad ? "Need " .join(', ',@bad): undef}sub import {my$class=shift;my$target=caller;if (@_){local$Level=$Level + 1;test_needs(@_)}no strict 'refs';*{"${target}::$_"}=\&{"${class}::$_"}for @{"${class}::EXPORT"}}sub test_needs {my$missing=_find_missing(@_);local$Level=$Level + 1;if ($missing){if ($ENV{RELEASE_TESTING}){_fail("$missing due to RELEASE_TESTING")}else {_skip($missing)}}return 1}sub _skip {local$Level=$Level + 1;_fail_or_skip($_[0],0)}sub _fail {local$Level=$Level + 1;_fail_or_skip($_[0],1)}sub _pairs {map +(ref eq 'HASH' ? do {my$arg=$_;map [$_=>$arg->{$_}],sort keys %$arg}: ref eq 'ARRAY' ? do {my$arg=$_;map [@{$arg}[$_*2,$_*2+1]],0 .. int($#$arg / 2)}: [$_ ]),@_}sub _fail_or_skip {my ($message,$fail)=@_;if ($INC{'Test2/API.pm'}){my$ctx=Test2::API::context(level=>$Level);my$hub=$ctx->hub;if ($fail){$ctx->ok(0,"Test::Needs modules available",[$message])}else {my$plan=$hub->plan;my$tests=$hub->count;if ($plan || $tests){my$skips =$plan && $plan ne 'NO PLAN' ? $plan - $tests : 1;$ctx->skip("Test::Needs modules not available")for 1 .. $skips;$ctx->note($message)}else {$ctx->plan(0,'SKIP',$message)}}$ctx->done_testing;$ctx->release if$Test2::API::VERSION < 1.302053;$ctx->send_event('+'._t2_terminate_event())}elsif ($INC{'Test/Builder.pm'}){local$Test::Builder::Level=$Test::Builder::Level + $Level;my$tb=Test::Builder->new;my$has_plan=Test::Builder->can('has_plan')? 'has_plan' : sub {$_[0]->expected_tests || eval {$_[0]->current_test($_[0]->current_test);'no_plan'}};if ($fail){$tb->plan(tests=>1)unless$tb->$has_plan;$tb->ok(0,"Test::Needs modules available");$tb->diag($message)}else {my$plan=$tb->$has_plan;my$tests=$tb->current_test;if ($plan || $tests){my$skips =$plan && $plan ne 'no_plan' ? $plan - $tests : 1;$tb->skip("Test::Needs modules not available")for 1 .. $skips;Test::Builder->can('note')? $tb->note($message): print "# $message\n"}else {$tb->skip_all($message)}}$tb->done_testing if Test::Builder->can('done_testing');die bless {}=>'Test::Builder::Exception' if Test::Builder->can('parent')&& $tb->parent}else {if ($fail){print "1..1\n";print "not ok 1 - Test::Needs modules available\n";print STDERR "# $message\n";exit 1}else {print "1..0 # SKIP $message\n"}}exit 0}my$terminate_event;sub _t2_terminate_event () {return$terminate_event if$terminate_event;local $@;$terminate_event=eval sprintf <<'END_CODE',__LINE__+2,__FILE__ or die "$@";(my$pm="$terminate_event.pm")=~ s{::}{/}g;$INC{$pm}=__FILE__;$terminate_event}1;
  #line %d "%s"
      package # hide
        Test::Needs::Event::Terminate;
      use Test2::Event ();
      our @ISA = qw(Test2::Event);
      sub no_display { 1 }
      sub terminate { 0 }
      __PACKAGE__;
  END_CODE
TEST_NEEDS

$fatpacked{"Test/Warn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_WARN';
  package Test::Warn;use 5.006;use strict;use warnings;use Sub::Uplevel 0.12;our$VERSION='0.36';require Exporter;our@ISA=qw(Exporter);our%EXPORT_TAGS=('all'=>[qw(@EXPORT) ]);our@EXPORT_OK=(@{$EXPORT_TAGS{'all'}});our@EXPORT=qw(warning_is warnings_are warning_like warnings_like warnings_exist);use Test::Builder;my$Tester=Test::Builder->new;{no warnings 'once';*warning_is=*warnings_are;*warning_like=*warnings_like}sub warnings_are (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);push@got_warning,_canonical_got_warning($called_from,shift())};uplevel 1,$block;my$ok=_cmp_is(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub warnings_like (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);push@got_warning,_canonical_got_warning($called_from,shift())};uplevel 1,$block;my$ok=_cmp_like(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub warnings_exist (&$;$) {my$block=shift;my@exp_warning=map {_canonical_exp_warning($_)}_to_array_if_necessary(shift()|| []);my$testname=shift;my@got_warning=();local$SIG{__WARN__}=sub {my ($called_from)=caller(0);my$wrn_text=shift;my$wrn_rec=_canonical_got_warning($called_from,$wrn_text);for my$wrn (@exp_warning){if (_cmp_got_to_exp_warning_like($wrn_rec,$wrn)){push@got_warning,$wrn_rec;return}}warn$wrn_text};uplevel 1,$block;my$ok=_cmp_like(\@got_warning,\@exp_warning);$Tester->ok($ok,$testname);$ok or _diag_found_warning(@got_warning),_diag_exp_warning(@exp_warning);return$ok}sub _to_array_if_necessary {return (ref($_[0])eq 'ARRAY')? @{$_[0]}: ($_[0])}sub _canonical_got_warning {my ($called_from,$msg)=@_;my$warn_kind=$called_from eq 'Carp' ? 'carped' : 'warn';my@warning_stack=split /\n/,$msg;return {$warn_kind=>$warning_stack[0]}}sub _canonical_exp_warning {my ($exp)=@_;if (ref($exp)eq 'HASH'){my$to_carp=$exp->{carped}or return;return (ref($to_carp)eq 'ARRAY')? map({{carped=>$_}}grep {defined $_}@$to_carp): +{carped=>$to_carp}}return {warn=>$exp}}sub _cmp_got_to_exp_warning {my ($got_kind,$got_msg)=%{shift()};my ($exp_kind,$exp_msg)=%{shift()};return 0 if ($got_kind eq 'warn')&& ($exp_kind eq 'carped');my$cmp;if ($exp_msg =~ /\n$/s){$cmp="$got_msg\n" eq $exp_msg}else {$cmp=$got_msg =~ /^\Q$exp_msg\E at .+ line \d+\.?$/s}return$cmp}sub _cmp_got_to_exp_warning_like {my ($got_kind,$got_msg)=%{shift()};my ($exp_kind,$exp_msg)=%{shift()};return 0 if ($got_kind eq 'warn')&& ($exp_kind eq 'carped');if (my$re=$Tester->maybe_regex($exp_msg)){my$cmp=$got_msg =~ /$re/;return$cmp}else {return Test::Warn::Categorization::warning_like_category($got_msg,$exp_msg)}}sub _cmp_is {my@got=@{shift()};my@exp=@{shift()};scalar@got==scalar@exp or return 0;my$cmp=1;$cmp &&= _cmp_got_to_exp_warning($got[$_],$exp[$_])for (0 .. $#got);return$cmp}sub _cmp_like {my@got=@{shift()};my@exp=@{shift()};scalar@got==scalar@exp or return 0;my$cmp=1;$cmp &&= _cmp_got_to_exp_warning_like($got[$_],$exp[$_])for (0 .. $#got);return$cmp}sub _diag_found_warning {for (@_){if (ref($_)eq 'HASH'){${$_}{carped}? $Tester->diag("found carped warning: ${$_}{carped}"): $Tester->diag("found warning: ${$_}{warn}")}else {$Tester->diag("found warning: $_")}}$Tester->diag("didn't find a warning")unless @_}sub _diag_exp_warning {for (@_){if (ref($_)eq 'HASH'){${$_}{carped}? $Tester->diag("expected to find carped warning: ${$_}{carped}"): $Tester->diag("expected to find warning: ${$_}{warn}")}else {$Tester->diag("expected to find warning: $_")}}$Tester->diag("didn't expect to find a warning")unless @_}package Test::Warn::Categorization;use Carp;my$bits=\%warnings::Bits;my@warnings=sort grep {my$warn_bits=$bits->{$_}}keys %$bits;my%warnings_in_category=('utf8'=>['Wide character in \w+\b',],);sub _warning_category_regexp {my$category=shift;my$category_bits=$bits->{$category}or return;my@category_warnings =grep {($bits->{$_}& $category_bits)eq $bits->{$_}}@warnings;my@list=map {exists$warnings_in_category{$_}? (@{$warnings_in_category{$_}}): ($_)}@category_warnings;my$re=join "|",@list;return qr/$re/}sub warning_like_category {my ($warning,$category)=@_;my$re=_warning_category_regexp($category)or carp("Unknown warning category '$category'"),return;my$ok=$warning =~ /$re/;return$ok}1;
TEST_WARN

$fatpacked{"Test/Warnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_WARNINGS';
  use strict;use warnings;package Test::Warnings;our$VERSION='0.031';use parent 'Exporter';use Test::Builder;our@EXPORT_OK=qw(allow_warnings allowing_warnings had_no_warnings warnings warning);our%EXPORT_TAGS=(all=>\@EXPORT_OK);my$warnings_allowed;my$forbidden_warnings_found;my$done_testing_called;my$no_end_test;my$fail_on_warning;my$report_warnings;my@collected_warnings;sub import {my$class=shift @_;my%names;@names{@_}=();$no_end_test=exists$names{':no_end_test'};$fail_on_warning=exists$names{':fail_on_warning'};$report_warnings=exists$names{':report_warnings'};delete@names{qw(:no_end_test :fail_on_warning :report_warnings)};__PACKAGE__->export_to_level(1,$class,keys%names)}my$tb;sub _builder(;$) {if (not @_){$tb ||= Test::Builder->new;return$tb}$tb=shift}my$_orig_warn_handler=$SIG{__WARN__};$SIG{__WARN__}=sub {if ($warnings_allowed){Test::Builder->new->note($_[0])}else {$forbidden_warnings_found++;push@collected_warnings,$_[0]if$report_warnings;goto &$_orig_warn_handler if$_orig_warn_handler and ((ref$_orig_warn_handler eq 'CODE')or ($_orig_warn_handler ne 'DEFAULT' and $_orig_warn_handler ne 'IGNORE' and defined &$_orig_warn_handler));if ($_[0]=~ /\n$/){warn $_[0]}else {require Carp;Carp::carp($_[0])}_builder->ok(0,'unexpected warning')if$fail_on_warning}};sub warnings(;&) {if (!@_){return 'warnings'}my$code=shift;my@warnings;local$SIG{__WARN__}=sub {push@warnings,shift};$code->();@warnings}sub warning(&) {my@warnings=&warnings(@_);return@warnings==1 ? $warnings[0]: \@warnings}if (Test::Builder->can('done_testing')){no strict 'refs';my$orig=*{'Test::Builder::done_testing'}{CODE};no warnings 'redefine';*{'Test::Builder::done_testing'}=sub {my$builder=_builder;my$in_subtest_sub=$builder->can('in_subtest');if (not $no_end_test and not ($in_subtest_sub ? $builder->$in_subtest_sub : $builder->parent)){local$Test::Builder::Level=$Test::Builder::Level + 3;had_no_warnings('no (unexpected) warnings (via done_testing)');$done_testing_called=1}$orig->(@_)}}END {if (not $no_end_test and not $done_testing_called and (_builder->expected_tests or _builder->current_test > 0)){local$Test::Builder::Level=$Test::Builder::Level + 1;had_no_warnings('no (unexpected) warnings (via END block)')}}sub allow_warnings(;$) {$warnings_allowed=@_ || defined $_[0]? $_[0]: 1}sub allowing_warnings() {$warnings_allowed}sub had_no_warnings(;$) {_builder->ok(!$forbidden_warnings_found,shift || 'no (unexpected) warnings');if ($report_warnings and $forbidden_warnings_found){_builder->diag("Got the following unexpected warnings:");for my$i (1 .. @collected_warnings){_builder->diag("  $i: $collected_warnings[ $i - 1 ]")}}}1;
TEST_WARNINGS

$fatpacked{"Test2/AsyncSubtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST';
  package Test2::AsyncSubtest;use strict;use warnings;use Test2::IPC;our$VERSION='0.000144';our@CARP_NOT=qw/Test2::Util::HashBase/;use Carp qw/croak cluck confess/;use Test2::Util qw/get_tid CAN_THREAD CAN_FORK/;use Scalar::Util qw/blessed weaken/;use List::Util qw/first/;use Scope::Guard();use Test2::API();use Test2::API::Context();use Test2::Util::Trace();use Time::HiRes();use Test2::AsyncSubtest::Hub();use Test2::AsyncSubtest::Event::Attach();use Test2::AsyncSubtest::Event::Detach();use Test2::Util::HashBase qw{name hub trace frame send_to events finished active stack id cid uuid children _in_use _attached pid tid start_stamp stop_stamp};sub CAN_REALLY_THREAD {return 0 unless CAN_THREAD;return 0 unless eval {require threads;threads->VERSION('1.34');1};return 1}my$UUID_VIA=Test2::API::_add_uuid_via_ref();my$CID=1;my@STACK;sub TOP {@STACK ? $STACK[-1]: undef}sub init {my$self=shift;croak "'name' is a required attribute" unless$self->{+NAME};my$to=$self->{+SEND_TO}||= Test2::API::test2_stack()->top;$self->{+STACK}=[@STACK];$_->{+_IN_USE}++ for reverse@STACK;$self->{+TID}=get_tid;$self->{+PID}=$$;$self->{+CID}='AsyncSubtest-' .$CID++;$self->{+ID}=1;$self->{+FINISHED}=0;$self->{+ACTIVE}=0;$self->{+_IN_USE}=0;$self->{+CHILDREN}=[];$self->{+UUID}=${$UUID_VIA}->()if defined $$UUID_VIA;unless($self->{+HUB}){my$ipc=Test2::API::test2_ipc();my$formatter=Test2::API::test2_stack->top->format;my$args=delete$self->{hub_init_args}|| {};my$hub=Test2::AsyncSubtest::Hub->new(%$args,ipc=>$ipc,nested=>$to->nested + 1,buffered=>1,formatter=>$formatter,);weaken($hub->{ast}=$self);$self->{+HUB}=$hub}$self->{+TRACE}||= Test2::Util::Trace->new(frame=>$self->{+FRAME}|| [caller(1)],buffered=>$to->buffered,nested=>$to->nested,cid=>$self->{+CID},uuid=>$self->{+UUID},hid=>$to->hid,huuid=>$to->uuid,);my$hub=$self->{+HUB};$hub->set_ast_ids({})unless$hub->ast_ids;$hub->listen($self->_listener)}sub _listener {my$self=shift;my$events=$self->{+EVENTS}||= [];sub {push @$events=>$_[1]}}sub context {my$self=shift;my$send_to=$self->{+SEND_TO};confess "Attempt to close AsyncSubtest when original parent hub (a non async-subtest?) has ended" if$send_to->ended;return Test2::API::Context->new(trace=>$self->{+TRACE},hub=>$send_to,)}sub _gen_event {my$self=shift;my ($type,$id,$hub)=@_;my$class="Test2::AsyncSubtest::Event::$type";return$class->new(id=>$id,trace=>Test2::Util::Trace->new(frame=>[caller(1)],buffered=>$hub->buffered,nested=>$hub->nested,cid=>$self->{+CID},uuid=>$self->{+UUID},hid=>$hub->hid,huuid=>$hub->uuid,),)}sub cleave {my$self=shift;my$id=$self->{+ID}++;$self->{+HUB}->ast_ids->{$id}=0;return$id}sub attach {my$self=shift;my ($id)=@_;croak "An ID is required" unless$id;croak "ID $id is not valid" unless defined$self->{+HUB}->ast_ids->{$id};croak "ID $id is already attached" if$self->{+HUB}->ast_ids->{$id};croak "You must attach INSIDE the child process/thread" if$self->{+HUB}->is_local;$self->{+_ATTACHED}=[$$,get_tid,$id ];$self->{+HUB}->send($self->_gen_event('Attach',$id,$self->{+HUB}))}sub detach {my$self=shift;if ($self->{+PID}==$$ && $self->{+TID}==get_tid){cluck "You must detach INSIDE the child process/thread ($$, " .get_tid ." instead of $self->{+PID}, $self->{+TID})";return}my$att=$self->{+_ATTACHED}or croak "Not attached";croak "Attempt to detach from wrong child" unless$att->[0]==$$ && $att->[1]==get_tid;my$id=$att->[2];$self->{+HUB}->send($self->_gen_event('Detach',$id,$self->{+HUB}));delete$self->{+_ATTACHED}}sub ready {return!shift->pending}sub pending {my$self=shift;my$hub=$self->{+HUB};return -1 unless$hub->is_local;$hub->cull;return$self->{+_IN_USE}+ keys %{$self->{+HUB}->ast_ids}}sub run {my$self=shift;my ($code,@args)=@_;croak "AsyncSubtest->run() takes a codeblock as the first argument" unless$code && ref($code)eq 'CODE';$self->start;my ($ok,$err,$finished);T2_SUBTEST_WRAPPER: {$ok=eval {$code->(@args);1};$err=$@;if (!$ok && $err =~ m/Label not found for "last T2_SUBTEST_WRAPPER"/){$ok=undef;$err=undef}else {$finished=1}}$self->stop;my$hub=$self->{+HUB};if (!$finished){if(my$bailed=$hub->bailed_out){my$ctx=$self->context;$ctx->bail($bailed->reason);return}my$code=$hub->exit_code;$ok=!$code;$err="Subtest ended with exit code $code" if$code}unless ($ok){my$e=Test2::Event::Exception->new(error=>$err,trace=>Test2::Util::Trace->new(frame=>[caller(0)],buffered=>$hub->buffered,nested=>$hub->nested,cid=>$self->{+CID},uuid=>$self->{+UUID},hid=>$hub->hid,huuid=>$hub->uuid,),);$hub->send($e)}return$hub->is_passing}sub start {my$self=shift;croak "Subtest is already complete" if$self->{+FINISHED};$self->{+START_STAMP}=time unless defined$self->{+START_STAMP};$self->{+ACTIVE}++;push@STACK=>$self;my$hub=$self->{+HUB};my$stack=Test2::API::test2_stack();$stack->push($hub);return$hub->is_passing}sub stop {my$self=shift;croak "Subtest is not active" unless$self->{+ACTIVE}--;croak "AsyncSubtest stack mismatch" unless@STACK && $self==$STACK[-1];$self->{+STOP_STAMP}=time;pop@STACK;my$hub=$self->{+HUB};my$stack=Test2::API::test2_stack();$stack->pop($hub);return$hub->is_passing}sub finish {my$self=shift;my%params=@_;my$hub=$self->hub;croak "Subtest is already finished" if$self->{+FINISHED}++;croak "Subtest can only be finished in the process/thread that created it" unless$hub->is_local;croak "Subtest is still active" if$self->{+ACTIVE};$self->wait;$self->{+STOP_STAMP}=time unless defined$self->{+STOP_STAMP};my$stop_stamp=$self->{+STOP_STAMP};my$todo=$params{todo};my$skip=$params{skip};my$empty=!@{$self->{+EVENTS}};my$no_asserts=!$hub->count;my$collapse=$params{collapse};my$no_plan=$params{no_plan}|| ($collapse && $no_asserts)|| $skip;my$trace=Test2::Util::Trace->new(frame=>$self->{+TRACE}->{frame},buffered=>$hub->buffered,nested=>$hub->nested,cid=>$self->{+CID},uuid=>$self->{+UUID},hid=>$hub->hid,huuid=>$hub->uuid,);$hub->finalize($trace,!$no_plan)unless$hub->no_ending || $hub->ended;if ($hub->ipc){$hub->ipc->drop_hub($hub->hid);$hub->set_ipc(undef)}return$hub->is_passing if$params{silent};my$ctx=$self->context;my$pass=1;if ($skip){$ctx->skip($self->{+NAME},$skip)}else {if ($collapse && $empty){$ctx->ok($hub->is_passing,$self->{+NAME});return$hub->is_passing}if ($collapse && $no_asserts){push @{$self->{+EVENTS}}=>Test2::Event::Plan->new(trace=>$trace,max=>0,directive=>'SKIP',reason=>"No assertions")}my$e=$ctx->build_event('Subtest',pass=>$hub->is_passing,subtest_id=>$hub->id,subtest_uuid=>$hub->uuid,name=>$self->{+NAME},buffered=>1,subevents=>$self->{+EVENTS},start_stamp=>$self->{+START_STAMP},stop_stamp=>$self->{+STOP_STAMP},$todo ? (todo=>$todo,effective_pass=>1,): (),);$ctx->hub->send($e);unless ($e->effective_pass){$ctx->failure_diag($e);$ctx->diag("Bad subtest plan, expected " .$hub->plan ." but ran " .$hub->count)if$hub->plan &&!$hub->check_plan &&!grep {$_->causes_fail}@{$self->{+EVENTS}}}$pass=$e->pass}$_->{+_IN_USE}-- for reverse @{$self->{+STACK}};return$pass}sub wait {my$self=shift;my$hub=$self->{+HUB};my$children=$self->{+CHILDREN};while (@$children){$hub->cull;if (my$child=pop @$children){if (blessed($child)){$child->join}else {waitpid($child,0)}}else {Time::HiRes::sleep('0.01')}}$hub->cull;cluck "Subtest '$self->{+NAME}': All children have completed, but we still appear to be pending" if$hub->is_local && keys %{$self->{+HUB}->ast_ids}}sub fork {croak "Forking is not supported" unless CAN_FORK;my$self=shift;my$id=$self->cleave;my$pid=CORE::fork();unless (defined$pid){delete$self->{+HUB}->ast_ids->{$id};croak "Failed to fork"}if($pid){push @{$self->{+CHILDREN}}=>$pid;return$pid}$self->attach($id);return$self->_guard}sub run_fork {my$self=shift;my ($code,@args)=@_;my$f=$self->fork;return$f unless blessed($f);$self->run($code,@args);$self->detach();$f->dismiss();exit 0}sub run_thread {croak "Threading is not supported" unless CAN_REALLY_THREAD;my$self=shift;my ($code,@args)=@_;my$id=$self->cleave;my$thr=threads->create(sub {$self->attach($id);$self->run($code,@args);$self->detach(get_tid);return 0});push @{$self->{+CHILDREN}}=>$thr;return$thr}sub _guard {my$self=shift;my ($pid,$tid)=($$,get_tid);return Scope::Guard->new(sub {return unless $$==$pid && get_tid==$tid;my$error="Scope Leak";if (my$ex=$@){chomp($ex);$error .= " ($ex)"}cluck$error;my$e=$self->context->build_event('Exception',error=>"$error\n",);$self->{+HUB}->send($e);$self->detach();exit 255})}sub DESTROY {my$self=shift;return unless$self->{+NAME};if (my$att=$self->{+_ATTACHED}){return unless$self->{+HUB};eval {$self->detach()}}return if$self->{+FINISHED};return unless$self->{+PID}==$$;return unless$self->{+TID}==get_tid;local $@;eval {$_->{+_IN_USE}-- for reverse @{$self->{+STACK}}};warn "Subtest $self->{+NAME} did not finish!";exit 255}1;
TEST2_ASYNCSUBTEST

$fatpacked{"Test2/AsyncSubtest/Event/Attach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST_EVENT_ATTACH';
  package Test2::AsyncSubtest::Event::Attach;use strict;use warnings;our$VERSION='0.000144';use base 'Test2::Event';use Test2::Util::HashBase qw/id/;sub no_display {1}sub callback {my$self=shift;my ($hub)=@_;my$id=$self->{+ID};my$ids=$hub->ast_ids;unless (defined$ids->{$id}){require Test2::Event::Exception;my$trace=$self->trace;$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>"Invalid AsyncSubtest attach ID: $id at " .$trace->debug ."\n",));return}if ($ids->{$id}++){require Test2::Event::Exception;my$trace=$self->trace;$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>"AsyncSubtest ID $id already attached at " .$trace->debug ."\n",));return}}1;
TEST2_ASYNCSUBTEST_EVENT_ATTACH

$fatpacked{"Test2/AsyncSubtest/Event/Detach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST_EVENT_DETACH';
  package Test2::AsyncSubtest::Event::Detach;use strict;use warnings;our$VERSION='0.000144';use base 'Test2::Event';use Test2::Util::HashBase qw/id/;sub no_display {1}sub callback {my$self=shift;my ($hub)=@_;my$id=$self->{+ID};my$ids=$hub->ast_ids;unless (defined$ids->{$id}){require Test2::Event::Exception;my$trace=$self->trace;$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>"Invalid AsyncSubtest detach ID: $id at " .$trace->debug ."\n",));return}unless (delete$ids->{$id}){require Test2::Event::Exception;my$trace=$self->trace;$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>"AsyncSubtest ID $id is not attached at " .$trace->debug ."\n",));return}}1;
TEST2_ASYNCSUBTEST_EVENT_DETACH

$fatpacked{"Test2/AsyncSubtest/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST_FORMATTER';
  package Test2::AsyncSubtest::Formatter;use strict;use warnings;our$VERSION='0.000144';die "Should not load this anymore";1;
TEST2_ASYNCSUBTEST_FORMATTER

$fatpacked{"Test2/AsyncSubtest/Hub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_ASYNCSUBTEST_HUB';
  package Test2::AsyncSubtest::Hub;use strict;use warnings;our$VERSION='0.000144';use base 'Test2::Hub::Subtest';use Test2::Util::HashBase qw/ast_ids ast/;sub init {my$self=shift;$self->SUPER::init();if (my$format=$self->format){my$hide=$format->can('hide_buffered')? $format->hide_buffered : 1;$self->format(undef)if$hide}}sub inherit {my$self=shift;my ($from,%params)=@_;if (my$ls=$from->{+_LISTENERS}){push @{$self->{+_LISTENERS}}=>grep {$_->{inherit}}@$ls}if (my$pfs=$from->{+_PRE_FILTERS}){push @{$self->{+_PRE_FILTERS}}=>grep {$_->{inherit}}@$pfs}if (my$fs=$from->{+_FILTERS}){push @{$self->{+_FILTERS}}=>grep {$_->{inherit}}@$fs}}1;
TEST2_ASYNCSUBTEST_HUB

$fatpacked{"Test2/Bundle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_BUNDLE';
  package Test2::Bundle;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_BUNDLE

$fatpacked{"Test2/Bundle/Extended.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_BUNDLE_EXTENDED';
  package Test2::Bundle::Extended;use strict;use warnings;use Test2::V0;our$VERSION='0.000144';BEGIN {push@Test2::Bundle::Extended::ISA=>'Test2::V0';no warnings 'once';*EXPORT=\@Test2::V0::EXPORT}our%EXPORT_TAGS=('v1'=>\@Test2::Bundle::Extended::EXPORT,);1;
TEST2_BUNDLE_EXTENDED

$fatpacked{"Test2/Bundle/More.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_BUNDLE_MORE';
  package Test2::Bundle::More;use strict;use warnings;our$VERSION='0.000144';use Test2::Plugin::ExitSummary;use Test2::Tools::Basic qw{ok pass fail skip todo diag note plan skip_all done_testing bail_out};use Test2::Tools::ClassicCompare qw{is is_deeply isnt like unlike cmp_ok};use Test2::Tools::Class qw/can_ok isa_ok/;use Test2::Tools::Subtest qw/subtest_streamed/;BEGIN {*BAIL_OUT=\&bail_out;*subtest=\&subtest_streamed}our@EXPORT=qw{ok pass fail skip todo diag note plan skip_all done_testing BAIL_OUT is isnt like unlike is_deeply cmp_ok isa_ok can_ok subtest};use base 'Exporter';1;
TEST2_BUNDLE_MORE

$fatpacked{"Test2/Bundle/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_BUNDLE_SIMPLE';
  package Test2::Bundle::Simple;use strict;use warnings;our$VERSION='0.000144';use Test2::Plugin::ExitSummary;use Test2::Tools::Basic qw/ok plan done_testing skip_all/;our@EXPORT=qw/ok plan done_testing skip_all/;use base 'Exporter';1;
TEST2_BUNDLE_SIMPLE

$fatpacked{"Test2/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE';
  package Test2::Compare;use strict;use warnings;our$VERSION='0.000144';use Scalar::Util qw/blessed/;use Test2::Util qw/try/;use Test2::Util::Ref qw/rtype/;use Carp qw/croak/;our@EXPORT_OK=qw{compare get_build push_build pop_build build strict_convert relaxed_convert convert};use base 'Exporter';sub compare {my ($got,$check,$convert)=@_;$check=$convert->($check);return$check->run(id=>undef,got=>$got,exists=>1,convert=>$convert,seen=>{},)}my@BUILD;sub get_build {@BUILD ? $BUILD[-1]: undef}sub push_build {push@BUILD=>$_[0]}sub pop_build {return pop@BUILD if@BUILD && $_[0]&& $BUILD[-1]==$_[0];my$have=@BUILD ? "$BUILD[-1]" : 'undef';my$want=$_[0]? "$_[0]" : 'undef';croak "INTERNAL ERROR: Attempted to pop incorrect build, have $have, tried to pop $want"}sub build {my ($class,$code)=@_;my@caller=caller(1);die "'$caller[3]\()' should not be called in void context in $caller[1] line $caller[2]\n" unless defined(wantarray);my$build=$class->new(builder=>$code,called=>\@caller);push@BUILD=>$build;my ($ok,$err)=try {$code->($build);1};pop@BUILD;die$err unless$ok;return$build}sub strict_convert {convert($_[0],{implicit_end=>1,use_regex=>0,use_code=>0 })}sub relaxed_convert {convert($_[0],{implicit_end=>0,use_regex=>1,use_code=>1 })}my$CONVERT_LOADED=0;my%ALLOWED_KEYS=(implicit_end=>1,use_regex=>1,use_code=>1);sub convert {my ($thing,$config)=@_;unless($CONVERT_LOADED){require Test2::Compare::Array;require Test2::Compare::Base;require Test2::Compare::Custom;require Test2::Compare::DeepRef;require Test2::Compare::Hash;require Test2::Compare::Pattern;require Test2::Compare::Ref;require Test2::Compare::Regex;require Test2::Compare::Scalar;require Test2::Compare::String;require Test2::Compare::Undef;require Test2::Compare::Wildcard;$CONVERT_LOADED=1}if (ref($config)){my$bad=join ', '=>grep {!$ALLOWED_KEYS{$_}}keys %$config;croak "The following config options are not understood by convert(): $bad" if$bad;$config->{implicit_end}=1 unless defined$config->{implicit_end};$config->{use_regex}=1 unless defined$config->{use_regex};$config->{use_code}=0 unless defined$config->{use_code}}else {if ($config){$config={implicit_end=>1,use_regex=>0,use_code=>0,}}else {$config={implicit_end=>0,use_regex=>1,use_code=>1,}}}return _convert($thing,$config)}sub _convert {my ($thing,$config)=@_;return Test2::Compare::Undef->new()unless defined$thing;if (blessed($thing)&& $thing->isa('Test2::Compare::Base')){if ($config->{implicit_end}&& $thing->can('set_ending')&&!defined$thing->ending){my$clone=$thing->clone;$clone->set_ending('implicit');return$clone}return$thing unless$thing->isa('Test2::Compare::Wildcard');my$newthing=_convert($thing->expect,$config);$newthing->set_builder($thing->builder)unless$newthing->builder;$newthing->set_file($thing->_file)unless$newthing->_file;$newthing->set_lines($thing->_lines)unless$newthing->_lines;return$newthing}my$type=rtype($thing);return Test2::Compare::Array->new(inref=>$thing,$config->{implicit_end}? (ending=>1): ())if$type eq 'ARRAY';return Test2::Compare::Hash->new(inref=>$thing,$config->{implicit_end}? (ending=>1): ())if$type eq 'HASH';return Test2::Compare::Pattern->new(pattern=>$thing,stringify_got=>1,)if$config->{use_regex}&& $type eq 'REGEXP';return Test2::Compare::Custom->new(code=>$thing)if$config->{use_code}&& $type eq 'CODE';return Test2::Compare::Regex->new(input=>$thing)if$type eq 'REGEXP';if ($type eq 'SCALAR' || $type eq 'VSTRING'){my$nested=_convert($$thing,$config);return Test2::Compare::Scalar->new(item=>$nested)}return Test2::Compare::DeepRef->new(input=>$thing)if$type eq 'REF';return Test2::Compare::Ref->new(input=>$thing)if$type;return Test2::Compare::String->new(input=>$thing)}1;
TEST2_COMPARE

$fatpacked{"Test2/Compare/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_ARRAY';
  package Test2::Compare::Array;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/inref meta ending items order for_each/;use Carp qw/croak confess/;use Scalar::Util qw/reftype looks_like_number/;sub init {my$self=shift;if(defined(my$ref=$self->{+INREF})){croak "Cannot specify both 'inref' and 'items'" if$self->{+ITEMS};croak "Cannot specify both 'inref' and 'order'" if$self->{+ORDER};croak "'inref' must be an array reference, got '$ref'" unless reftype($ref)eq 'ARRAY';my$order=$self->{+ORDER}=[];my$items=$self->{+ITEMS}={};for (my$i=0;$i < @$ref;$i++){push @$order=>$i;$items->{$i}=$ref->[$i]}}else {$self->{+ITEMS}||= {};croak "All indexes listed in the 'items' hashref must be numeric" if grep {!looks_like_number($_)}keys %{$self->{+ITEMS}};$self->{+ORDER}||= [sort {$a <=> $b}keys %{$self->{+ITEMS}}];croak "All indexes listed in the 'order' arrayref must be numeric" if grep {!(looks_like_number($_)|| (ref($_)&& reftype($_)eq 'CODE'))}@{$self->{+ORDER}}}$self->{+FOR_EACH}||= [];$self->SUPER::init()}sub name {'<ARRAY>'}sub meta_class {'Test2::Compare::Meta'}sub verify {my$self=shift;my%params=@_;return 0 unless$params{exists};my$got=$params{got};return 0 unless defined$got;return 0 unless ref($got);return 0 unless reftype($got)eq 'ARRAY';return 1}sub add_prop {my$self=shift;$self->{+META}=$self->meta_class->new unless defined$self->{+META};$self->{+META}->add_prop(@_)}sub top_index {my$self=shift;my@order=@{$self->{+ORDER}};while(@order){my$idx=pop@order;next if ref$idx;return$idx}return undef}sub add_item {my$self=shift;my$check=pop;my ($idx)=@_;my$top=$self->top_index;croak "elements must be added in order!" if$top && $idx && $idx <= $top;$idx=defined($top)? $top + 1 : 0 unless defined($idx);push @{$self->{+ORDER}}=>$idx;$self->{+ITEMS}->{$idx}=$check}sub add_filter {my$self=shift;my ($code)=@_;croak "A single coderef is required" unless @_==1 && $code && ref$code && reftype($code)eq 'CODE';push @{$self->{+ORDER}}=>$code}sub add_for_each {my$self=shift;push @{$self->{+FOR_EACH}}=>@_}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$state=0;my@order=@{$self->{+ORDER}};my$items=$self->{+ITEMS};my$for_each=$self->{+FOR_EACH};my$meta=$self->{+META};push@deltas=>$meta->deltas(%params)if defined$meta;my@list=@$got;while (@order){my$idx=shift@order;my$overflow=0;my$val;if (ref($idx)){@list=$idx->(@list);next}confess "Internal Error: Stacks are out of sync (state > idx)" if$state > $idx + 1;while ($state <= $idx){$overflow=!@list;$val=shift@list;for my$check (@$for_each){$check=$convert->($check);push@deltas=>$check->run(id=>[ARRAY=>$state],convert=>$convert,seen=>$seen,exists=>!$overflow,$overflow ? (): (got=>$val),)}$state++}confess "Internal Error: Stacks are out of sync (state != idx + 1)" unless$state==$idx + 1;my$check=$convert->($items->{$idx});push@deltas=>$check->run(id=>[ARRAY=>$idx],convert=>$convert,seen=>$seen,exists=>!$overflow,$overflow ? (): (got=>$val),)}while (@list && (@$for_each || $self->{+ENDING})){my$item=shift@list;for my$check (@$for_each){$check=$convert->($check);push@deltas=>$check->run(id=>[ARRAY=>$state],convert=>$convert,seen=>$seen,got=>$item,exists=>1,)}if ($self->{+ENDING}){push@deltas=>$self->delta_class->new(dne=>'check',verified=>undef,id=>[ARRAY=>$state],got=>$item,check=>undef,$self->{+ENDING}eq 'implicit' ? (note=>'implicit end'): (),)}$state++}return@deltas}1;
TEST2_COMPARE_ARRAY

$fatpacked{"Test2/Compare/Bag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_BAG';
  package Test2::Compare::Bag;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/ending meta items for_each/;use Carp qw/croak confess/;use Scalar::Util qw/reftype looks_like_number/;sub init {my$self=shift;$self->{+ITEMS}||= [];$self->{+FOR_EACH}||= [];$self->SUPER::init()}sub name {'<BAG>'}sub meta_class {'Test2::Compare::Meta'}sub verify {my$self=shift;my%params=@_;return 0 unless$params{exists};my$got=$params{got}|| return 0;return 0 unless ref($got);return 0 unless reftype($got)eq 'ARRAY';return 1}sub add_prop {my$self=shift;$self->{+META}=$self->meta_class->new unless defined$self->{+META};$self->{+META}->add_prop(@_)}sub add_item {my$self=shift;my$check=pop;my ($idx)=@_;push @{$self->{+ITEMS}},$check}sub add_for_each {my$self=shift;push @{$self->{+FOR_EACH}}=>@_}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$state=0;my@items=@{$self->{+ITEMS}};my@for_each=@{$self->{+FOR_EACH}};my@list=@$got;my%unmatched=map {$_=>$list[$_]}0..$#list;my$meta=$self->{+META};push@deltas=>$meta->deltas(%params)if defined$meta;while (@items){my$item=shift@items;my$check=$convert->($item);my$match=0;for my$idx (0..$#list){next unless exists$unmatched{$idx};my$val=$list[$idx];my$deltas=$check->run(id=>[ARRAY=>$idx],convert=>$convert,seen=>$seen,exists=>1,got=>$val,);unless ($deltas){$match++;delete$unmatched{$idx};last}}unless ($match){push@deltas=>$self->delta_class->new(dne=>'got',verified=>undef,id=>[ARRAY=>'*'],got=>undef,check=>$check,)}}if (@for_each){my@checks=map {$convert->($_)}@for_each;for my$idx (0..$#list){delete$unmatched{$idx};my$val=$list[$idx];for my$check (@checks){push@deltas=>$check->run(id=>[ARRAY=>$idx],convert=>$convert,seen=>$seen,exists=>1,got=>$val,)}}}if($self->{+ENDING}&& keys%unmatched){for my$idx (sort keys%unmatched){my$elem=$list[$idx];push@deltas=>$self->delta_class->new(dne=>'check',verified=>undef,id=>[ARRAY=>$idx],got=>$elem,check=>undef,$self->{+ENDING}eq 'implicit' ? (note=>'implicit end'): (),)}}return@deltas}1;
TEST2_COMPARE_BAG

$fatpacked{"Test2/Compare/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_BASE';
  package Test2::Compare::Base;use strict;use warnings;our$VERSION='0.000144';use Carp qw/confess croak/;use Scalar::Util qw/blessed/;use Sub::Info qw/sub_info/;use Test2::Compare::Delta();sub MAX_CYCLES() {75}use Test2::Util::HashBase qw{builder _file _lines _info called};use Test2::Util::Ref qw/render_ref/;{no warnings 'once';*set_lines=\&set__lines;*set_file=\&set__file}sub clone {my$self=shift;my$class=blessed($self);return bless({%$self},$class)}sub init {my$self=shift;$self->{+_LINES}=delete$self->{lines}if exists$self->{lines};$self->{+_FILE}=delete$self->{file}if exists$self->{file}}sub file {my$self=shift;return$self->{+_FILE}if$self->{+_FILE};if ($self->{+BUILDER}){$self->{+_INFO}||= sub_info($self->{+BUILDER});return$self->{+_INFO}->{file}}elsif ($self->{+CALLED}){return$self->{+CALLED}->[1]}return undef}sub lines {my$self=shift;return$self->{+_LINES}if$self->{+_LINES};if ($self->{+BUILDER}){$self->{+_INFO}||= sub_info($self->{+BUILDER});return$self->{+_INFO}->{lines}if @{$self->{+_INFO}->{lines}}}if ($self->{+CALLED}){return [$self->{+CALLED}->[2]]}return []}sub delta_class {'Test2::Compare::Delta'}sub deltas {()}sub got_lines {()}sub stringify_got {0}sub operator {''}sub verify {confess "unimplemented"}sub name {confess "unimplemented"}sub render {my$self=shift;return$self->name}sub run {my$self=shift;my%params=@_;my$id=$params{id};my$convert=$params{convert}or confess "no convert sub provided";my$seen=$params{seen}||= {};$params{exists}=exists$params{got}? 1 : 0 unless exists$params{exists};my$exists=$params{exists};my$got=$exists ? $params{got}: undef;my$gotname=render_ref($got);if (defined($got)&& ref$got){die "Cycle detected in comparison, aborting" if$seen->{$gotname}&& $seen->{$gotname}>= MAX_CYCLES;$seen->{$gotname}++}my$ok=$self->verify(%params);my@deltas=$ok ? $self->deltas(%params): ();$seen->{$gotname}-- if defined$got && ref$got;return if$ok &&!@deltas;return$self->delta_class->new(verified=>$ok,id=>$id,got=>$got,check=>$self,children=>\@deltas,$exists ? (): (dne=>'got'),)}1;
TEST2_COMPARE_BASE

$fatpacked{"Test2/Compare/Bool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_BOOL';
  package Test2::Compare::Bool;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/input/;use Test2::Compare::Negatable;sub name {my$self=shift;my$in=$self->{+INPUT};return _render_bool($in)}sub operator {my$self=shift;return '!=' if$self->{+NEGATE};return '=='}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$want=$self->{+INPUT};my$match=($want xor $got)? 0 : 1;$match=$match ? 0 : 1 if$self->{+NEGATE};return$match}sub run {my$self=shift;my$delta=$self->SUPER::run(@_)or return;my$dne=$delta->dne || "";unless ($dne eq 'got'){my$got=$delta->got;$delta->set_got(_render_bool($got))}return$delta}sub _render_bool {my$bool=shift;my$name=$bool ? 'TRUE' : 'FALSE';my$val=defined$bool ? $bool : 'undef';$val="''" unless length($val);return "<$name ($val)>"}1;
TEST2_COMPARE_BOOL

$fatpacked{"Test2/Compare/Custom.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_CUSTOM';
  package Test2::Compare::Custom;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/code name operator stringify_got/;use Carp qw/croak/;sub init {my$self=shift;croak "'code' is required" unless$self->{+CODE};$self->{+OPERATOR}||= 'CODE(...)';$self->{+NAME}||= '<Custom Code>';$self->{+STRINGIFY_GOT}=$self->SUPER::stringify_got()unless defined$self->{+STRINGIFY_GOT};$self->SUPER::init()}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};my$code=$self->{+CODE};local $_=$got;my$ok=$code->(got=>$got,exists=>$exists,operator=>$self->{+OPERATOR},name=>$self->{+NAME},);return$ok}1;
TEST2_COMPARE_CUSTOM

$fatpacked{"Test2/Compare/DeepRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_DEEPREF';
  package Test2::Compare::DeepRef;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/input/;use Test2::Util::Ref qw/render_ref rtype/;use Scalar::Util qw/refaddr/;use Carp qw/croak/;sub init {my$self=shift;croak "'input' is a required attribute" unless$self->{+INPUT};croak "'input' must be a reference, got '" .$self->{+INPUT}."'" unless ref$self->{+INPUT};$self->SUPER::init()}sub name {'<REF>'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$in=$self->{+INPUT};return 0 unless ref$in;return 0 unless ref$got;my$in_type=rtype($in);my$got_type=rtype($got);return 0 unless$in_type eq $got_type;return 1}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my$in=$self->{+INPUT};my$in_type=rtype($in);my$got_type=rtype($got);my$check=$convert->($$in);return$check->run(id=>['DEREF'=>'$*'],convert=>$convert,seen=>$seen,got=>$$got,exists=>1,)}1;
TEST2_COMPARE_DEEPREF

$fatpacked{"Test2/Compare/Delta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_DELTA';
  package Test2::Compare::Delta;use strict;use warnings;our$VERSION='0.000144';use Test2::Util::HashBase qw{verified id got chk children dne exception note};use Test2::EventFacet::Info::Table;use Test2::Util::Table();use Test2::API qw/context/;use Test2::Util::Ref qw/render_ref rtype/;use Carp qw/croak/;BEGIN {no warnings 'once';*check=\&chk;*set_check=\&set_chk}my@COLUMN_ORDER=qw/PATH GLNs GOT OP CHECK CLNs/;my%COLUMNS=(GOT=>{name=>'GOT',value=>sub {$_[0]->render_got},no_collapse=>1},CHECK=>{name=>'CHECK',value=>sub {$_[0]->render_check},no_collapse=>1},OP=>{name=>'OP',value=>sub {$_[0]->table_op}},PATH=>{name=>'PATH',value=>sub {$_[1]}},'GLNs'=>{name=>'GLNs',alias=>'LNs',value=>sub {$_[0]->table_got_lines}},'CLNs'=>{name=>'CLNs',alias=>'LNs',value=>sub {$_[0]->table_check_lines}},);{my$i=0;$COLUMNS{$_}->{id}=$i++ for@COLUMN_ORDER}sub remove_column {my$class=shift;my$header=shift;@COLUMN_ORDER=grep {$_ ne $header}@COLUMN_ORDER;delete$COLUMNS{$header}? 1 : 0}sub add_column {my$class=shift;my$name=shift;croak "Column name is required" unless$name;croak "Column '$name' is already defined" if$COLUMNS{$name};my%params;if (@_==1){%params=(value=>@_,name=>$name)}else {%params=(@_,name=>$name)}my$value=$params{value};croak "You must specify a 'value' callback" unless$value;croak "'value' callback must be a CODE reference" unless rtype($value)eq 'CODE';if ($params{prefix}){unshift@COLUMN_ORDER=>$name}else {push@COLUMN_ORDER=>$name}$COLUMNS{$name}=\%params}sub set_column_alias {my ($class,$name,$alias)=@_;croak "Tried to alias a non-existent column" unless exists$COLUMNS{$name};croak "Missing alias" unless defined$alias;$COLUMNS{$name}->{alias}=$alias}sub init {my$self=shift;croak "Cannot specify both 'check' and 'chk' as arguments" if exists($self->{check})&& exists($self->{+CHK});$self->{+CHK}||= delete$self->{check}if exists$self->{check}}sub render_got {my$self=shift;my$exp=$self->{+EXCEPTION};if ($exp){chomp($exp="$exp");$exp =~ s/\n.*$//g;return "<EXCEPTION: $exp>"}my$dne=$self->{+DNE};return '<DOES NOT EXIST>' if$dne && $dne eq 'got';my$got=$self->{+GOT};return '<UNDEF>' unless defined$got;my$check=$self->{+CHK};my$stringify=defined($check)&& $check->stringify_got;return render_ref($got)if ref$got &&!$stringify;return "$got"}sub render_check {my$self=shift;my$dne=$self->{+DNE};return '<DOES NOT EXIST>' if$dne && $dne eq 'check';my$check=$self->{+CHK};return '<UNDEF>' unless defined$check;return$check->render}sub _full_id {my ($type,$id)=@_;return "<$id>" if!$type || $type eq 'META';return$id if$type eq 'SCALAR';return "{$id}" if$type eq 'HASH';return "{$id} <KEY>" if$type eq 'HASHKEY';return "[$id]" if$type eq 'ARRAY';return "$id()" if$type eq 'METHOD';return "$id" if$type eq 'DEREF';return "<$id>"}sub _arrow_id {my ($path,$type)=@_;return '' unless$path;return ' ' if!$type || $type eq 'META';return '->' if$type eq 'METHOD';return '->' if$type eq 'SCALAR';return '->' if$type eq 'DEREF';return '->' if$path =~ m/(>|\(\))$/;return '->' if$path eq '$VAR';return '->' if$type =~ m/^(HASH|ARRAY)$/ && $path !~ m/(\]|\})$/;return ''}sub _join_id {my ($path,$parts)=@_;my ($type,$key)=@$parts;my$id=_full_id($type,$key);my$join=_arrow_id($path,$type);return "${path}${join}${id}"}sub should_show {my$self=shift;return 1 unless$self->verified;defined(my$check=$self->check)|| return 0;return 0 unless$check->lines;my$file=$check->file || return 0;my$ctx=context();my$cfile=$ctx->trace->file;$ctx->release;return 0 unless$file eq $cfile;return 1}sub filter_visible {my$self=shift;my@deltas;my@queue=(['',$self]);while (my$set=shift@queue){my ($path,$delta)=@$set;push@deltas=>[$path,$delta]if$delta->should_show;my$children=$delta->children || next;next unless @$children;my@new;for my$child (@$children){my$cpath=_join_id($path,$child->id);push@new=>[$cpath,$child]}unshift@queue=>@new}return \@deltas}sub table_header {[map {$COLUMNS{$_}->{alias}|| $_}@COLUMN_ORDER]}sub table_op {my$self=shift;defined(my$check=$self->{+CHK})|| return '!exists';return$check->operator($self->{+GOT})unless$self->{+DNE}&& $self->{+DNE}eq 'got';return$check->operator()}sub table_check_lines {my$self=shift;defined(my$check=$self->{+CHK})|| return '';my$lines=$check->lines || return '';return '' unless @$lines;return join ', '=>@$lines}sub table_got_lines {my$self=shift;defined(my$check=$self->{+CHK})|| return '';return '' if$self->{+DNE}&& $self->{+DNE}eq 'got';my@lines=$check->got_lines($self->{+GOT});return '' unless@lines;return join ', '=>@lines}sub table_rows {my$self=shift;my$deltas=$self->filter_visible;my@rows;for my$set (@$deltas){my ($id,$d)=@$set;my@row;for my$col (@COLUMN_ORDER){my$spec=$COLUMNS{$col};my$val=$spec->{value}->($d,$id);$val='' unless defined$val;push@row=>$val}push@rows=>\@row}return \@rows}sub table {my$self=shift;my@diag;my$header=$self->table_header;my$rows=$self->table_rows;my$render_rows=[@$rows];my$max=exists$ENV{TS_MAX_DELTA}? $ENV{TS_MAX_DELTA}: 25;if ($max && @$render_rows > $max){@$render_rows=map {[@$_]}@{$render_rows}[0 .. ($max - 1)];@diag=("************************************************************",sprintf("* Stopped after %-42.42s *","$max differences."),"* Set the TS_MAX_DELTA environment var to raise the limit. *","* Set it to 0 for no limit.                                *","************************************************************",)}my@dne;for my$row (@$render_rows){my$got=$row->[$COLUMNS{GOT}->{id}]|| '';my$chk=$row->[$COLUMNS{CHECK}->{id}]|| '';if ($got eq '<DOES NOT EXIST>'){push@dne=>"$row->[$COLUMNS{PATH}->{id}]:   DOES NOT EXIST"}elsif ($chk eq '<DOES NOT EXIST>'){push@dne=>"$row->[$COLUMNS{PATH}->{id}]: SHOULD NOT EXIST"}}if (@dne){unshift@dne=>'==== Summary of missing/extra items ====';push@dne=>'== end summary of missing/extra items =='}my$table_args={header=>$header,collapse=>1,sanitize=>1,mark_tail=>1,no_collapse=>[grep {$COLUMNS{$COLUMN_ORDER[$_]}->{no_collapse}}0 .. $#COLUMN_ORDER],};my$render=join "\n"=>(Test2::Util::Table::table(%$table_args,rows=>$render_rows),@dne,@diag,);my$table=Test2::EventFacet::Info::Table->new(%$table_args,rows=>$rows,as_string=>$render,);return$table}sub diag {shift->table}1;
TEST2_COMPARE_DELTA

$fatpacked{"Test2/Compare/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_EVENT';
  package Test2::Compare::Event;use strict;use warnings;use Scalar::Util qw/blessed/;use Test2::Compare::EventMeta();use base 'Test2::Compare::Object';our$VERSION='0.000144';use Test2::Util::HashBase qw/etype/;sub name {my$self=shift;my$etype=$self->etype;return "<EVENT: $etype>"}sub meta_class {'Test2::Compare::EventMeta'}sub object_base {'Test2::Event'}sub got_lines {my$self=shift;my ($event)=@_;return unless$event;return unless blessed($event);return unless$event->isa('Test2::Event');return unless$event->trace;return ($event->trace->line)}1;
TEST2_COMPARE_EVENT

$fatpacked{"Test2/Compare/EventMeta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_EVENTMETA';
  package Test2::Compare::EventMeta;use strict;use warnings;use base 'Test2::Compare::Meta';our$VERSION='0.000144';use Test2::Util::HashBase;sub get_prop_file {$_[1]->trace->file}sub get_prop_line {$_[1]->trace->line}sub get_prop_package {$_[1]->trace->package}sub get_prop_subname {$_[1]->trace->subname}sub get_prop_debug {$_[1]->trace->debug}sub get_prop_tid {$_[1]->trace->tid}sub get_prop_pid {$_[1]->trace->pid}1;
TEST2_COMPARE_EVENTMETA

$fatpacked{"Test2/Compare/Float.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_FLOAT';
  package Test2::Compare::Float;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000144';our$DEFAULT_TOLERANCE=1e-08;use Test2::Util::HashBase qw/input tolerance precision/;use Test2::Compare::Negatable;sub init {my$self=shift;my$input=$self->{+INPUT};if (exists$self->{+TOLERANCE}and exists$self->{+PRECISION}){confess "can't set both tolerance and precision"}elsif (!exists$self->{+PRECISION}and!exists$self->{+TOLERANCE}){$self->{+TOLERANCE}=$DEFAULT_TOLERANCE}confess "input must be defined for 'Float' check" unless defined$input;confess "input must be a number for 'Float' check" unless length($input)&& $input =~ m/\S/;confess "precision must be an integer for 'Float' check" if exists$self->{+PRECISION}&& $self->{+PRECISION}!~ m/^\d+$/;$self->SUPER::init(@_)}sub name {my$self=shift;my$in=$self->{+INPUT};my$precision=$self->{+PRECISION};if (defined$precision){return sprintf "%.*f",$precision,$in}my$tolerance=$self->{+TOLERANCE};return "$in +/- $tolerance"}sub operator {my$self=shift;return '' unless @_;my ($got)=@_;return '' unless defined($got);return '' unless length($got)&& $got =~ m/\S/;if ($self->{+PRECISION}){return 'ne' if$self->{+NEGATE};return 'eq'}return '!=' if$self->{+NEGATE};return '=='}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 if ref$got;return 0 unless length($got)&& $got =~ m/\S/;my$input=$self->{+INPUT};my$negate=$self->{+NEGATE};my$tolerance=$self->{+TOLERANCE};my$precision=$self->{+PRECISION};my@warnings;my$out;{local$SIG{__WARN__}=sub {push@warnings=>@_};my$equal=($input==$got);if (!$equal){if (defined$tolerance){$equal=1 if $got > $input - $tolerance && $got < $input + $tolerance}else {$equal=sprintf("%.*f",$precision,$got)eq sprintf("%.*f",$precision,$input)}}$out=$negate ?!$equal : $equal}for my$warn (@warnings){if ($warn =~ m/numeric/){$out=0;next}warn$warn}return$out}1;
TEST2_COMPARE_FLOAT

$fatpacked{"Test2/Compare/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_HASH';
  package Test2::Compare::Hash;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/inref meta ending items order for_each_key for_each_val/;use Carp qw/croak confess/;use Scalar::Util qw/reftype/;sub init {my$self=shift;if(defined(my$ref=$self->{+INREF})){croak "Cannot specify both 'inref' and 'items'" if$self->{+ITEMS};croak "Cannot specify both 'inref' and 'order'" if$self->{+ORDER};$self->{+ITEMS}={%$ref};$self->{+ORDER}=[sort keys %$ref]}else {$self->{+ITEMS}=$self->{+ITEMS}? {%{$self->{+ITEMS}}}: {};if ($self->{+ORDER}){my@all=keys %{$self->{+ITEMS}};my%have=map {$_=>1}@{$self->{+ORDER}};my@missing=grep {!$have{$_}}@all;croak "Keys are missing from the 'order' array: " .join(', ',sort@missing)if@missing}else {$self->{+ORDER}=[sort keys %{$self->{+ITEMS}}]}}$self->{+FOR_EACH_KEY}||= [];$self->{+FOR_EACH_VAL}||= [];$self->SUPER::init()}sub name {'<HASH>'}sub meta_class {'Test2::Compare::Meta'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 unless ref($got);return 0 unless reftype($got)eq 'HASH';return 1}sub add_prop {my$self=shift;$self->{+META}=$self->meta_class->new unless defined$self->{+META};$self->{+META}->add_prop(@_)}sub add_field {my$self=shift;my ($name,$check)=@_;croak "field name is required" unless defined$name;croak "field '$name' has already been specified" if exists$self->{+ITEMS}->{$name};push @{$self->{+ORDER}}=>$name;$self->{+ITEMS}->{$name}=$check}sub add_for_each_key {my$self=shift;push @{$self->{+FOR_EACH_KEY}}=>@_}sub add_for_each_val {my$self=shift;push @{$self->{+FOR_EACH_VAL}}=>@_}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$items=$self->{+ITEMS};my$each_key=$self->{+FOR_EACH_KEY};my$each_val=$self->{+FOR_EACH_VAL};my%fields=%$got;my$meta=$self->{+META};push@deltas=>$meta->deltas(%params)if defined$meta;for my$key (@{$self->{+ORDER}}){my$check=$convert->($items->{$key});my$exists=exists$fields{$key};my$val=delete$fields{$key};if ($exists){for my$kcheck (@$each_key){$kcheck=$convert->($kcheck);push@deltas=>$kcheck->run(id=>[HASHKEY=>$key],convert=>$convert,seen=>$seen,exists=>$exists,got=>$key,)}for my$vcheck (@$each_val){$vcheck=$convert->($vcheck);push@deltas=>$vcheck->run(id=>[HASH=>$key],convert=>$convert,seen=>$seen,exists=>$exists,got=>$val,)}}push@deltas=>$check->run(id=>[HASH=>$key],convert=>$convert,seen=>$seen,exists=>$exists,$exists ? (got=>$val): (),)}if (keys%fields){for my$key (sort keys%fields){my$val=$fields{$key};for my$kcheck (@$each_key){$kcheck=$convert->($kcheck);push@deltas=>$kcheck->run(id=>[HASHKEY=>$key],convert=>$convert,seen=>$seen,got=>$key,exists=>1,)}for my$vcheck (@$each_val){$vcheck=$convert->($vcheck);push@deltas=>$vcheck->run(id=>[HASH=>$key],convert=>$convert,seen=>$seen,got=>$val,exists=>1,)}if ($self->{+ENDING}){push@deltas=>$self->delta_class->new(dne=>'check',verified=>undef,id=>[HASH=>$key],got=>$val,check=>undef,$self->{+ENDING}eq 'implicit' ? (note=>'implicit end'): (),)}}}return@deltas}1;
TEST2_COMPARE_HASH

$fatpacked{"Test2/Compare/Isa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_ISA';
  package Test2::Compare::Isa;use strict;use warnings;use Carp qw/confess/;use Scalar::Util qw/blessed/;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/input/;use Test2::Compare::Negatable;sub init {my$self=shift;confess "input must be defined for 'Isa' check" unless defined$self->{+INPUT};$self->SUPER::init(@_)}sub name {my$self=shift;my$in=$self->{+INPUT};return "$in"}sub operator {my$self=shift;return '!isa' if$self->{+NEGATE};return 'isa'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$input=$self->{+INPUT};my$negate=$self->{+NEGATE};my$isa=blessed($got)&& $got->isa($input);return!$isa if$negate;return$isa}1;
TEST2_COMPARE_ISA

$fatpacked{"Test2/Compare/Meta.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_META';
  package Test2::Compare::Meta;use strict;use warnings;use Test2::Compare::Delta();use Test2::Compare::Isa();use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/items/;use Carp qw/croak confess/;use Scalar::Util qw/reftype blessed/;sub init {my$self=shift;$self->{+ITEMS}||= [];$self->SUPER::init()}sub name {'<META CHECKS>'}sub verify {my$self=shift;my%params=@_;return$params{exists}? 1 : 0}sub add_prop {my$self=shift;my ($name,$check)=@_;croak "prop name is required" unless defined$name;croak "check is required" unless defined$check;my$meth="get_prop_$name";croak "'$name' is not a known property" unless$self->can($meth);if ($name eq 'isa'){if (blessed($check)&& $check->isa('Test2::Compare::Wildcard')){$check=Test2::Compare::Isa->new(input=>$check->expect,file=>$check->file,lines=>$check->lines,)}else {$check=Test2::Compare::Isa->new(input=>$check)}}push @{$self->{+ITEMS}}=>[$meth,$check,$name]}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$items=$self->{+ITEMS};for my$set (@$items){my ($meth,$check,$name)=@$set;$check=$convert->($check);my$val=$self->$meth($got);push@deltas=>$check->run(id=>[META=>$name],got=>$val,convert=>$convert,seen=>$seen,)}return@deltas}sub get_prop_blessed {blessed($_[1])}sub get_prop_reftype {reftype($_[1])}sub get_prop_isa {$_[1]}sub get_prop_this {$_[1]}sub get_prop_size {my$self=shift;my ($it)=@_;my$type=reftype($it)|| '';return scalar @$it if$type eq 'ARRAY';return scalar keys %$it if$type eq 'HASH';return undef}1;
TEST2_COMPARE_META

$fatpacked{"Test2/Compare/Negatable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_NEGATABLE';
  package Test2::Compare::Negatable;use strict;use warnings;our$VERSION='0.000144';require overload;require Test2::Util::HashBase;sub import {my ($pkg,$file,$line)=caller;my$sub=eval <<"    EOT" or die $@;$sub->();no strict 'refs';*{"$pkg\::clone_negate"}=\&clone_negate;*{"$pkg\::toggle_negate"}=\&toggle_negate}sub clone_negate {my$self=shift;my$clone=$self->clone;$clone->toggle_negate;return$clone}sub toggle_negate {my$self=shift;$self->set_negate($self->negate ? 0 : 1)}1;
  package $pkg;
  #line $line "$file"
  sub { overload->import('!' => 'clone_negate', fallback => 1); Test2::Util::HashBase->import('negate')}
      EOT
TEST2_COMPARE_NEGATABLE

$fatpacked{"Test2/Compare/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_NUMBER';
  package Test2::Compare::Number;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/input/;use Test2::Compare::Negatable;sub init {my$self=shift;my$input=$self->{+INPUT};confess "input must be defined for 'Number' check" unless defined$input;confess "input must be a number for 'Number' check" unless length($input)&& $input =~ m/\S/;$self->SUPER::init(@_)}sub name {my$self=shift;my$in=$self->{+INPUT};return$in}sub operator {my$self=shift;return '' unless @_;my ($got)=@_;return '' unless defined($got);return '' unless length($got)&& $got =~ m/\S/;return '!=' if$self->{+NEGATE};return '=='}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 if ref$got;return 0 unless length($got)&& $got =~ m/\S/;my$input=$self->{+INPUT};my$negate=$self->{+NEGATE};my@warnings;my$out;{local$SIG{__WARN__}=sub {push@warnings=>@_};$out=$negate ? ($input!=$got): ($input==$got)}for my$warn (@warnings){if ($warn =~ m/numeric/){$out=0;next}warn$warn}return$out}1;
TEST2_COMPARE_NUMBER

$fatpacked{"Test2/Compare/Object.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_OBJECT';
  package Test2::Compare::Object;use strict;use warnings;use Test2::Util qw/try/;use Test2::Compare::Meta();use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/calls meta refcheck ending/;use Carp qw/croak confess/;use Scalar::Util qw/reftype blessed/;sub init {my$self=shift;$self->{+CALLS}||= [];$self->SUPER::init()}sub name {'<OBJECT>'}sub meta_class {'Test2::Compare::Meta'}sub object_base {'UNIVERSAL'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 unless ref($got);return 0 unless blessed($got);return 0 unless$got->isa($self->object_base);return 1}sub add_prop {my$self=shift;$self->{+META}=$self->meta_class->new unless defined$self->{+META};$self->{+META}->add_prop(@_)}sub add_field {my$self=shift;$self->{+REFCHECK}=Test2::Compare::Hash->new unless defined$self->{+REFCHECK};croak "Underlying reference does not have fields" unless$self->{+REFCHECK}->can('add_field');$self->{+REFCHECK}->add_field(@_)}sub add_item {my$self=shift;$self->{+REFCHECK}=Test2::Compare::Array->new unless defined$self->{+REFCHECK};croak "Underlying reference does not have items" unless$self->{+REFCHECK}->can('add_item');$self->{+REFCHECK}->add_item(@_)}sub add_call {my$self=shift;my ($meth,$check,$name,$context)=@_;$name ||= ref$meth eq 'ARRAY' ? $meth->[0]: ref$meth eq 'CODE' ? '\&CODE' : $meth;push @{$self->{+CALLS}}=>[$meth,$check,$name,$context || 'scalar']}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$meta=$self->{+META};my$refcheck=$self->{+REFCHECK};push@deltas=>$meta->deltas(%params)if defined$meta;for my$call (@{$self->{+CALLS}}){my ($meth,$check,$name,$context)=@$call;$context ||= 'scalar';$check=$convert->($check);my@args;if (ref($meth)eq 'ARRAY'){($meth,@args)=@{$meth}}my$exists=ref($meth)|| $got->can($meth);my$val;my ($ok,$err)=try {$val=$exists ? ($context eq 'list' ? [$got->$meth(@args)]: $context eq 'hash' ? {$got->$meth(@args)}: $got->$meth(@args)): undef};if (!$ok){push@deltas=>$self->delta_class->new(verified=>undef,id=>[METHOD=>$name],got=>undef,check=>$check,exception=>$err,)}else {push@deltas=>$check->run(id=>[METHOD=>$name],convert=>$convert,seen=>$seen,exists=>$exists,$exists ? (got=>$val): (),)}}return@deltas unless defined$refcheck;$refcheck->set_ending($self->{+ENDING});if ($refcheck->verify(%params)){push@deltas=>$refcheck->deltas(%params)}else {push@deltas=>$self->delta_class->new(verified=>undef,id=>[META=>'Object Ref'],got=>$got,check=>$refcheck,)}return@deltas}1;
TEST2_COMPARE_OBJECT

$fatpacked{"Test2/Compare/OrderedSubset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_ORDEREDSUBSET';
  package Test2::Compare::OrderedSubset;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/inref items/;use Carp qw/croak/;use Scalar::Util qw/reftype/;sub init {my$self=shift;if(my$ref=$self->{+INREF}){croak "Cannot specify both 'inref' and 'items'" if$self->{+ITEMS};croak "'inref' must be an array reference, got '$ref'" unless reftype($ref)eq 'ARRAY';$self->{+ITEMS}=[@{$self->{+INREF}}]}$self->{+ITEMS}||= [];$self->SUPER::init()}sub name {'<ORDERED SUBSET>'}sub verify {my$self=shift;my%params=@_;return 0 unless$params{exists};defined(my$got=$params{got})|| return 0;return 0 unless ref($got);return 0 unless reftype($got)eq 'ARRAY';return 1}sub add_item {my$self=shift;my$check=pop;push @{$self->{+ITEMS}}=>$check}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my@deltas;my$state=0;my$items=$self->{+ITEMS};my$idx=0;for my$item (@$items){my$check=$convert->($item);my$i=$idx;my$found;while($i < @$got){my$val=$got->[$i++];next if$check->run(id=>[ARRAY=>$i],convert=>$convert,seen=>$seen,exists=>1,got=>$val,);$idx=$i;$found++;last}next if$found;push@deltas=>Test2::Compare::Delta->new(verified=>0,id=>['ARRAY','?'],check=>$check,dne=>'got',)}return@deltas}1;
TEST2_COMPARE_ORDEREDSUBSET

$fatpacked{"Test2/Compare/Pattern.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_PATTERN';
  package Test2::Compare::Pattern;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/pattern stringify_got/;use Test2::Compare::Negatable;use Carp qw/croak/;sub init {my$self=shift;croak "'pattern' is a required attribute" unless$self->{+PATTERN};$self->{+STRINGIFY_GOT}||= 0;$self->SUPER::init()}sub name {shift->{+PATTERN}.""}sub operator {shift->{+NEGATE}? '!~' : '=~'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined($got);return 0 if ref$got &&!$self->stringify_got;return$got !~ $self->{+PATTERN}if$self->{+NEGATE};return$got =~ $self->{+PATTERN}}1;
TEST2_COMPARE_PATTERN

$fatpacked{"Test2/Compare/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_REF';
  package Test2::Compare::Ref;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/input/;use Test2::Util::Ref qw/render_ref rtype/;use Scalar::Util qw/refaddr/;use Carp qw/croak/;sub init {my$self=shift;croak "'input' is a required attribute" unless$self->{+INPUT};croak "'input' must be a reference, got '" .$self->{+INPUT}."'" unless ref$self->{+INPUT};$self->SUPER::init()}sub operator {'=='}sub name {render_ref($_[0]->{+INPUT})}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$in=$self->{+INPUT};return 0 unless ref$in;return 0 unless ref$got;my$in_type=rtype($in);my$got_type=rtype($got);return 0 unless$in_type eq $got_type;return refaddr($in)==refaddr($got)}1;
TEST2_COMPARE_REF

$fatpacked{"Test2/Compare/Regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_REGEX';
  package Test2::Compare::Regex;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/input/;use Test2::Util::Ref qw/render_ref rtype/;use Carp qw/croak/;sub init {my$self=shift;croak "'input' is a required attribute" unless$self->{+INPUT};croak "'input' must be a regex , got '" .$self->{+INPUT}."'" unless rtype($self->{+INPUT})eq 'REGEXP';$self->SUPER::init()}sub stringify_got {1}sub operator {'eq'}sub name {"" .$_[0]->{+INPUT}}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;my$in=$self->{+INPUT};my$got_type=rtype($got)or return 0;return 0 unless$got_type eq 'REGEXP';return "$in" eq "$got"}1;
TEST2_COMPARE_REGEX

$fatpacked{"Test2/Compare/Scalar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_SCALAR';
  package Test2::Compare::Scalar;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/item/;use Carp qw/croak confess/;use Scalar::Util qw/reftype blessed/;sub init {my$self=shift;croak "'item' is a required attribute" unless defined$self->{+ITEM};$self->SUPER::init()}sub name {'<SCALAR>'}sub operator {'${...}'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;return 0 unless ref($got);return 0 unless reftype($got)eq 'SCALAR' || reftype($got)eq 'VSTRING';return 1}sub deltas {my$self=shift;my%params=@_;my ($got,$convert,$seen)=@params{qw/got convert seen/};my$item=$self->{+ITEM};my$check=$convert->($item);return ($check->run(id=>['SCALAR'=>'$*'],got=>$$got,convert=>$convert,seen=>$seen,exists=>1,),)}1;
TEST2_COMPARE_SCALAR

$fatpacked{"Test2/Compare/Set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_SET';
  package Test2::Compare::Set;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/checks _reduction/;use Test2::Compare::Delta();use Carp qw/croak confess/;use Scalar::Util qw/reftype/;sub init {my$self=shift;my$reduction=delete$self->{reduction}|| 'any';$self->{+CHECKS}||= [];$self->set_reduction($reduction);$self->SUPER::init()}sub name {'<CHECK-SET>'}sub operator {$_[0]->{+_REDUCTION}}sub reduction {$_[0]->{+_REDUCTION}}my%VALID=(any=>1,all=>1,none=>1);sub set_reduction {my$self=shift;my ($redu)=@_;croak "'$redu' is not a valid set reduction" unless$VALID{$redu};$self->{+_REDUCTION}=$redu}sub verify {my$self=shift;my%params=@_;return 1}sub add_check {my$self=shift;push @{$self->{+CHECKS}}=>@_}sub deltas {my$self=shift;my%params=@_;my$checks=$self->{+CHECKS};my$reduction=$self->{+_REDUCTION};my$convert=$params{convert};unless ($checks && @$checks){my$file=$self->file;my$lines=$self->lines;my$extra="";if ($file and $lines and @$lines){my$lns=(@$lines > 1 ? 'lines ' : 'line ').join ', ',@$lines;$extra=" (Set defined in $file $lns)"}die "No checks defined for set$extra\n"}my@deltas;my$i=0;for my$check (@$checks){my$c=$convert->($check);my$id=[META=>"Check " .$i++];my@d=$c->run(%params,id=>$id);if ($reduction eq 'any'){return ()unless@d;push@deltas=>@d}elsif ($reduction eq 'all'){push@deltas=>@d}elsif ($reduction eq 'none'){push@deltas=>Test2::Compare::Delta->new(verified=>0,id=>$id,got=>$params{got},check=>$c,)unless@d}else {die "Invalid reduction: $reduction\n"}}return@deltas}1;
TEST2_COMPARE_SET

$fatpacked{"Test2/Compare/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_STRING';
  package Test2::Compare::String;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/input/;use Test2::Compare::Negatable;sub stringify_got {1}sub init {my$self=shift;confess "input must be defined for 'String' check" unless defined$self->{+INPUT};$self->SUPER::init(@_)}sub name {my$self=shift;my$in=$self->{+INPUT};return "$in"}sub operator {my$self=shift;return '' unless @_;my ($got)=@_;return '' unless defined($got);return 'ne' if$self->{+NEGATE};return 'eq'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return 0 unless defined$got;my$input=$self->{+INPUT};my$negate=$self->{+NEGATE};return "$input" ne "$got" if$negate;return "$input" eq "$got"}1;
TEST2_COMPARE_STRING

$fatpacked{"Test2/Compare/Undef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_UNDEF';
  package Test2::Compare::Undef;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase;use Test2::Compare::Negatable;sub name {'<UNDEF>'}sub operator {my$self=shift;return 'IS NOT' if$self->{+NEGATE};return 'IS'}sub verify {my$self=shift;my%params=@_;my ($got,$exists)=@params{qw/got exists/};return 0 unless$exists;return!defined($got)unless$self->{+NEGATE};return defined($got)}1;
TEST2_COMPARE_UNDEF

$fatpacked{"Test2/Compare/Wildcard.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_COMPARE_WILDCARD';
  package Test2::Compare::Wildcard;use strict;use warnings;use base 'Test2::Compare::Base';our$VERSION='0.000144';use Test2::Util::HashBase qw/expect/;use Carp qw/croak/;sub init {my$self=shift;croak "'expect' is a require attribute" unless exists$self->{+EXPECT};$self->SUPER::init()}1;
TEST2_COMPARE_WILDCARD

$fatpacked{"Test2/Manual.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL';
  package Test2::Manual;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL

$fatpacked{"Test2/Manual/Anatomy.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY';
  package Test2::Manual::Anatomy;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_ANATOMY

$fatpacked{"Test2/Manual/Anatomy/API.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_API';
  package Test2::Manual::Anatomy::API;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_ANATOMY_API

$fatpacked{"Test2/Manual/Anatomy/Context.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_CONTEXT';
  package Test2::Manual::Anatomy::Context;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_ANATOMY_CONTEXT

$fatpacked{"Test2/Manual/Anatomy/EndToEnd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_ENDTOEND';
  package Test2::Manual::Anatomy::EndToEnd;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_ANATOMY_ENDTOEND

$fatpacked{"Test2/Manual/Anatomy/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_EVENT';
  package Test2::Manual::Anatomy::Event;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_ANATOMY_EVENT

$fatpacked{"Test2/Manual/Anatomy/Hubs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_HUBS';
  package Test2::Manual::Anatomy::Hubs;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_ANATOMY_HUBS

$fatpacked{"Test2/Manual/Anatomy/IPC.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_IPC';
  package Test2::Manual::Anatomy::IPC;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_ANATOMY_IPC

$fatpacked{"Test2/Manual/Anatomy/Utilities.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_ANATOMY_UTILITIES';
  package Test2::Manual::Anatomy::Utilities;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_ANATOMY_UTILITIES

$fatpacked{"Test2/Manual/Concurrency.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_CONCURRENCY';
  package Test2::Manual::Concurrency;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_CONCURRENCY

$fatpacked{"Test2/Manual/Contributing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_CONTRIBUTING';
  package Test2::Manual::Contributing;our$VERSION='0.000144';1;
TEST2_MANUAL_CONTRIBUTING

$fatpacked{"Test2/Manual/Testing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING';
  package Test2::Manual::Testing;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TESTING

$fatpacked{"Test2/Manual/Testing/Introduction.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING_INTRODUCTION';
  package Test2::Manual::Testing::Introduction;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TESTING_INTRODUCTION

$fatpacked{"Test2/Manual/Testing/Migrating.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING_MIGRATING';
  package Test2::Manual::Testing::Migrating;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TESTING_MIGRATING

$fatpacked{"Test2/Manual/Testing/Planning.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING_PLANNING';
  package Test2::Manual::Testing::Planning;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TESTING_PLANNING

$fatpacked{"Test2/Manual/Testing/Todo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TESTING_TODO';
  package Test2::Manual::Testing::Todo;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TESTING_TODO

$fatpacked{"Test2/Manual/Tooling.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING';
  package Test2::Manual::Tooling;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING

$fatpacked{"Test2/Manual/Tooling/FirstTool.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_FIRSTTOOL';
  package Test2::Manual::Tooling::FirstTool;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_FIRSTTOOL

$fatpacked{"Test2/Manual/Tooling/Formatter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_FORMATTER';
  package Test2::Manual::Tooling::Formatter;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_FORMATTER

$fatpacked{"Test2/Manual/Tooling/Nesting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_NESTING';
  package Test2::Manual::Tooling::Nesting;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_NESTING

$fatpacked{"Test2/Manual/Tooling/Plugin/TestExit.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_PLUGIN_TESTEXIT';
  package Test2::Manual::Tooling::Plugin::TestExit;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_PLUGIN_TESTEXIT

$fatpacked{"Test2/Manual/Tooling/Plugin/TestingDone.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_PLUGIN_TESTINGDONE';
  package Test2::Manual::Tooling::Plugin::TestingDone;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_PLUGIN_TESTINGDONE

$fatpacked{"Test2/Manual/Tooling/Plugin/ToolCompletes.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_PLUGIN_TOOLCOMPLETES';
  package Test2::Manual::Tooling::Plugin::ToolCompletes;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_PLUGIN_TOOLCOMPLETES

$fatpacked{"Test2/Manual/Tooling/Plugin/ToolStarts.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_PLUGIN_TOOLSTARTS';
  package Test2::Manual::Tooling::Plugin::ToolStarts;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_PLUGIN_TOOLSTARTS

$fatpacked{"Test2/Manual/Tooling/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_SUBTEST';
  package Test2::Manual::Tooling::Subtest;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_SUBTEST

$fatpacked{"Test2/Manual/Tooling/TestBuilder.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_TESTBUILDER';
  package Test2::Manual::Tooling::TestBuilder;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_TESTBUILDER

$fatpacked{"Test2/Manual/Tooling/Testing.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MANUAL_TOOLING_TESTING';
  package Test2::Manual::Tooling::Testing;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_MANUAL_TOOLING_TESTING

$fatpacked{"Test2/Mock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_MOCK';
  package Test2::Mock;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak confess/;our@CARP_NOT=(__PACKAGE__);use Scalar::Util qw/weaken reftype blessed/;use Test2::Util qw/pkg_to_file/;use Test2::Util::Stash qw/parse_symbol slot_to_sig get_symbol get_stash purge_symbol/;use Test2::Util::Sub qw/gen_accessor gen_reader gen_writer/;sub new;use Test2::Util::HashBase qw/class parent child _purge_on_destroy _blocked_load _symbols _track sub_tracking call_tracking/;sub new {my$class=shift;croak "Called new() on a blessed instance, did you mean to call \$control->class->new()?" if blessed($class);my$self=bless({},$class);$self->{+SUB_TRACKING}||= {};$self->{+CALL_TRACKING}||= [];my@sets;while (my$arg=shift @_){my$val=shift @_;if ($class->can(uc($arg))){$self->{$arg}=$val;next}push@sets=>[$arg,$val]}croak "The 'class' field is required" unless$self->{+CLASS};for my$set (@sets){my ($meth,$val)=@$set;my$type=reftype($val);confess "'$meth' is not a valid constructor argument for $class" unless$self->can($meth);if (!$type){$self->$meth($val)}elsif($type eq 'HASH'){$self->$meth(%$val)}elsif($type eq 'ARRAY'){$self->$meth(@$val)}else {croak "'$val' is not a valid argument for '$meth'"}}return$self}sub _check {return unless $_[0]->{+CHILD};croak "There is an active child controller, cannot proceed"}sub purge_on_destroy {my$self=shift;($self->{+_PURGE_ON_DESTROY})=@_ if @_;return$self->{+_PURGE_ON_DESTROY}}sub stash {my$self=shift;get_stash($self->{+CLASS})}sub file {my$self=shift;my$file=$self->class;return pkg_to_file($self->class)}sub block_load {my$self=shift;$self->_check();my$file=$self->file;croak "Cannot block the loading of module '" .$self->class ."', already loaded in file $INC{$file}" if$INC{$file};$INC{$file}=__FILE__;$self->{+_BLOCKED_LOAD}=1}my%NEW=(hash=>sub {my ($class,%params)=@_;return bless \%params,$class},array=>sub {my ($class,@params)=@_;return bless \@params,$class},ref=>sub {my ($class,$params)=@_;return bless$params,$class},ref_copy=>sub {my ($class,$params)=@_;my$type=reftype($params);return bless {%$params},$class if$type eq 'HASH';return bless [@$params],$class if$type eq 'ARRAY';croak "Not sure how to construct an '$class' from '$params'"},);sub override_constructor {my$self=shift;my ($name,$type)=@_;$self->_check();my$sub=$NEW{$type}|| croak "'$type' is not a known constructor type";$self->override($name=>$sub)}sub add_constructor {my$self=shift;my ($name,$type)=@_;$self->_check();my$sub=$NEW{$type}|| croak "'$type' is not a known constructor type";$self->add($name=>$sub)}sub autoload {my$self=shift;$self->_check();my$class=$self->class;my$stash=$self->stash;croak "Class '$class' already has an AUTOLOAD" if$stash->{AUTOLOAD}&& *{$stash->{AUTOLOAD}}{CODE};croak "Class '$class' already has an can" if$stash->{can}&& *{$stash->{can}}{CODE};weaken(my$c=$self);my ($file,$line)=(__FILE__,__LINE__ + 3);my$autoload=eval <<EOT || die "Failed generating AUTOLOAD sub: $@";$line=__LINE__ + 3;my$can=eval <<EOT || die "Failed generating can method: $@";{local$self->{+_TRACK}=0;$self->add(AUTOLOAD=>$autoload);$self->add(can=>$can)}}sub before {my$self=shift;my ($name,$sub)=@_;$self->_check();my$orig=$self->current($name);$self->_inject({},$name=>sub {$sub->(@_);$orig->(@_)})}sub after {my$self=shift;my ($name,$sub)=@_;$self->_check();my$orig=$self->current($name);$self->_inject({},$name=>sub {my@out;my$want=wantarray;if ($want){@out=$orig->(@_)}elsif(defined$want){$out[0]=$orig->(@_)}else {$orig->(@_)}$sub->(@_);return@out if$want;return$out[0]if defined$want;return})}sub around {my$self=shift;my ($name,$sub)=@_;$self->_check();my$orig=$self->current($name);$self->_inject({},$name=>sub {$sub->($orig,@_)})}sub add {my$self=shift;$self->_check();$self->_inject({add=>1},@_)}sub override {my$self=shift;$self->_check();$self->_inject({},@_)}sub set {my$self=shift;$self->_check();$self->_inject({set=>1},@_)}sub current {my$self=shift;my ($sym)=@_;return get_symbol($sym,$self->{+CLASS})}sub orig {my$self=shift;my ($sym)=@_;$sym="&$sym" unless$sym =~ m/^[&\$\%\@]/;my$syms=$self->{+_SYMBOLS}or croak "No symbols have been mocked yet";my$ref=$syms->{$sym};croak "Symbol '$sym' is not mocked" unless$ref && @$ref;my ($orig)=@$ref;return$orig}sub track {my$self=shift;($self->{+_TRACK})=@_ if @_;return$self->{+_TRACK}}sub clear_call_tracking {@{shift->{+CALL_TRACKING}}=()}sub clear_sub_tracking {my$self=shift;unless (@_){%{$self->{+SUB_TRACKING}}=();return}for my$item (@_){delete$self->{+SUB_TRACKING}->{$item}}return}sub _parse_inject {my$self=shift;my ($param,$arg)=@_;if ($param =~ m/^-(.*)$/){my$sym=$1;my$sig=slot_to_sig(reftype($arg));my$ref=$arg;return ($sig,$sym,$ref)}return ('&',$param,$arg)if ref($arg)&& reftype($arg)eq 'CODE';my ($is,$field,$val);if(defined($arg)&&!ref($arg)&& $arg =~ m/^(rw|ro|wo)$/){$is=$arg;$field=$param}elsif (!ref($arg)){$val=$arg;$is='val'}elsif (reftype($arg)eq 'HASH'){$field=delete$arg->{field}|| $param;$val=delete$arg->{val};$is=delete$arg->{is};croak "Cannot specify 'is' and 'val' together" if$val && $is;$is ||= $val ? 'val' : 'rw';croak "The following keys are not valid when defining a mocked sub with a hashref: " .join(", "=>keys %$arg)if keys %$arg}else {confess "'$arg' is not a valid argument when defining a mocked sub"}my$sub;if ($is eq 'rw'){$sub=gen_accessor($field)}elsif ($is eq 'ro'){$sub=gen_reader($field)}elsif ($is eq 'wo'){$sub=gen_writer($field)}else {$sub=sub {$val}}return ('&',$param,$sub)}sub _inject {my$self=shift;my ($params,@pairs)=@_;my$add=$params->{add};my$set=$params->{set};my$class=$self->{+CLASS};$self->{+_SYMBOLS}||= {};my$syms=$self->{+_SYMBOLS};while (my$param=shift@pairs){my$arg=shift@pairs;my ($sig,$sym,$ref)=$self->_parse_inject($param,$arg);my$orig=$self->current("$sig$sym");croak "Cannot override '$sig$class\::$sym', symbol is not already defined" unless$orig || $add || $set || ($sig eq '&' && $class->can($sym));croak "Cannot add '$sig$class\::$sym', symbol is already defined" if$add && $orig && (reftype($orig)ne 'SCALAR' || defined($$orig));$syms->{"$sig$sym"}||= [];push @{$syms->{"$sig$sym"}}=>$orig;if ($self->{+_TRACK}&& $sig eq '&'){my$sub_tracker=$self->{+SUB_TRACKING};my$call_tracker=$self->{+CALL_TRACKING};my$sub=$ref;$ref=sub {my$call={sub_name=>$sym,sub_ref=>$sub,args=>[@_]};push @{$sub_tracker->{$param}}=>$call;push @$call_tracker=>$call;goto &$sub}}no strict 'refs';no warnings 'redefine';*{"$class\::$sym"}=$ref}return}sub _set_or_unset {my$self=shift;my ($symbol,$set)=@_;my$class=$self->{+CLASS};return purge_symbol($symbol,$class)unless$set;my$sym=parse_symbol($symbol,$class);no strict 'refs';no warnings 'redefine';*{"$class\::$sym->{name}"}=$set}sub restore {my$self=shift;my ($sym)=@_;$self->_check();$sym="&$sym" unless$sym =~ m/^[&\$\%\@]/;my$syms=$self->{+_SYMBOLS}or croak "No symbols are mocked";my$ref=$syms->{$sym};croak "Symbol '$sym' is not mocked" unless$ref && @$ref;my$old=pop @$ref;delete$syms->{$sym}unless @$ref;return$self->_set_or_unset($sym,$old)}sub reset {my$self=shift;my ($sym)=@_;$self->_check();$sym="&$sym" unless$sym =~ m/^[&\$\%\@]/;my$syms=$self->{+_SYMBOLS}or croak "No symbols are mocked";my$ref=delete$syms->{$sym};croak "Symbol '$sym' is not mocked" unless$ref && @$ref;my ($old)=@$ref;return$self->_set_or_unset($sym,$old)}sub reset_all {my$self=shift;$self->_check();my$syms=$self->{+_SYMBOLS}|| return;$self->reset($_)for keys %$syms;delete$self->{+_SYMBOLS}}sub _purge {my$self=shift;my$stash=$self->stash;delete$stash->{$_}for keys %$stash}sub DESTROY {my$self=shift;delete$self->{+CHILD};$self->reset_all if$self->{+_SYMBOLS};delete$INC{$self->file}if$self->{+_BLOCKED_LOAD};$self->_purge if$self->{+_PURGE_ON_DESTROY}}1;
  package $class;
  #line $line "$file (Generated AUTOLOAD)"
  our \$AUTOLOAD;
      sub {
          my (\$self) = \@_;
          my (\$pkg, \$name) = (\$AUTOLOAD =~ m/^(.*)::([^:]+)\$/g);
          \$AUTOLOAD = undef;
  
          return if \$name eq 'DESTROY';
          my \$sub = sub {
              my \$self = shift;
              (\$self->{\$name}) = \@_ if \@_;
              return \$self->{\$name};
          };
  
          \$c->add(\$name => \$sub);
  
          if (\$c->{_track}) {
              my \$call = {sub_name => \$name, sub_ref => \$sub, args => [\@_]};
              push \@{\$c->{sub_tracking}->{\$name}} => \$call;
              push \@{\$c->{call_tracking}} => \$call;
          }
  
          goto &\$sub;
      }
  EOT
  package $class;
  #line $line "$file (Generated can)"
  use Scalar::Util 'reftype';
      sub {
          my (\$self, \$meth) = \@_;
          if (\$self->SUPER::can(\$meth)) {
              return \$self->SUPER::can(\$meth);
          }
          elsif (ref \$self && reftype \$self eq 'HASH' && exists \$self->{\$meth}) {
              return sub { shift->\$meth(\@_) };
          }
          return undef;
      }
  EOT
TEST2_MOCK

$fatpacked{"Test2/Plugin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN';
  package Test2::Plugin;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_PLUGIN

$fatpacked{"Test2/Plugin/BailOnFail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_BAILONFAIL';
  package Test2::Plugin::BailOnFail;use strict;use warnings;our$VERSION='0.000144';use Test2::API qw/test2_add_callback_context_release/;my$LOADED=0;sub import {return if$LOADED++;test2_add_callback_context_release(sub {my$ctx=shift;return if$ctx->hub->is_passing;$ctx->bail("(Bail On Fail)")})}1;
TEST2_PLUGIN_BAILONFAIL

$fatpacked{"Test2/Plugin/DieOnFail.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_DIEONFAIL';
  package Test2::Plugin::DieOnFail;use strict;use warnings;our$VERSION='0.000144';use Test2::API qw/test2_add_callback_context_release/;my$LOADED=0;sub import {return if$LOADED++;test2_add_callback_context_release(sub {my$ctx=shift;return if$ctx->hub->is_passing;$ctx->throw("(Die On Fail)")})}1;
TEST2_PLUGIN_DIEONFAIL

$fatpacked{"Test2/Plugin/ExitSummary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_EXITSUMMARY';
  package Test2::Plugin::ExitSummary;use strict;use warnings;our$VERSION='0.000144';use Test2::API qw/test2_add_callback_exit/;my$ADDED_HOOK=0;sub import {test2_add_callback_exit(\&summary)unless$ADDED_HOOK++}sub active {$ADDED_HOOK}sub summary {my ($ctx,$real,$new)=@_;return if$INC{'Test/Builder.pm'};my$hub=$ctx->hub;my$plan=$hub->plan;my$count=$hub->count;my$failed=$hub->failed;$ctx->diag('No tests run!')if!$count && (!$plan || $plan ne 'SKIP');$ctx->diag('Tests were run but no plan was declared and done_testing() was not seen.')if$count &&!$plan;$ctx->diag("Looks like your test exited with $real after test #$count.")if$real;$ctx->diag("Did not follow plan: expected $plan, ran $count.")if$plan && $plan =~ m/^[0-9]+$/ && defined$count && $count!=$plan}1;
TEST2_PLUGIN_EXITSUMMARY

$fatpacked{"Test2/Plugin/SRand.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_SRAND';
  package Test2::Plugin::SRand;use strict;use warnings;our$VERSION='0.000144';use Carp qw/carp/;use Test2::API qw{context test2_add_callback_post_load test2_add_callback_exit test2_stack};my$ADDED_HOOK=0;my$SEED;my$FROM;sub seed {$SEED}sub from {$FROM}sub import {my$class=shift;carp "SRand loaded multiple times, re-seeding rand" if defined$SEED;if (@_==1){($SEED)=@_;$FROM='import arg'}elsif (@_==2 and $_[0]eq 'seed'){$SEED=$_[1];$FROM='import arg'}elsif(exists$ENV{T2_RAND_SEED}){$SEED=$ENV{T2_RAND_SEED};$FROM='environment variable'}else {my@ltime=localtime;$SEED=sprintf('%04d%02d%02d',1900 + $ltime[5],1 + $ltime[4],$ltime[3]);$FROM='local date'}$SEED=0 unless$SEED;srand($SEED);if ($ENV{HARNESS_IS_VERBOSE}||!$ENV{HARNESS_ACTIVE}){test2_add_callback_post_load(sub {test2_stack()->top;my ($hub)=test2_stack()->all;$hub->send(Test2::Event::Note->new(trace=>Test2::Util::Trace->new(frame=>[__PACKAGE__,__FILE__,__LINE__,'SRAND']),message=>"Seeded srand with seed '$SEED' from $FROM.",))})}elsif (!$ADDED_HOOK++){test2_add_callback_exit(sub {my ($ctx,$real,$new)=@_;$ctx->diag("Seeded srand with seed '$SEED' from $FROM.")if$real || ($new && $$new)||!$ctx->hub->is_passing})}}1;
TEST2_PLUGIN_SRAND

$fatpacked{"Test2/Plugin/Times.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_TIMES';
  package Test2::Plugin::Times;use strict;use warnings;use Test2::Util::Times qw/render_bench render_duration/;use Test2::API qw{test2_add_callback_exit};use Time::HiRes qw/time/;our$VERSION='0.000144';my$ADDED_HOOK=0;my$START;sub import {return if$ADDED_HOOK++;$START=time;test2_add_callback_exit(\&send_time_event)}sub send_time_event {my ($ctx,$real,$new)=@_;my$stop=time;my@times=times();my$summary=render_bench($START,$stop,@times);my$duration=render_duration($START,$stop);my$e=$ctx->send_ev2(about=>{package=>__PACKAGE__,details=>$summary},info=>[{tag=>'TIME',details=>$summary}],times=>{details=>$summary,start=>$START,stop=>$stop,user=>$times[0],sys=>$times[1],cuser=>$times[2],csys=>$times[3],},harness_job_fields=>[{name=>"time_duration",details=>$duration},{name=>"time_user",details=>$times[0]},{name=>"time_sys",details=>$times[1]},{name=>"time_cuser",details=>$times[2]},{name=>"time_csys",details=>$times[3]},],)}1;
TEST2_PLUGIN_TIMES

$fatpacked{"Test2/Plugin/UTF8.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_PLUGIN_UTF8';
  package Test2::Plugin::UTF8;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use Test2::API qw{test2_add_callback_post_load test2_stack};my$LOADED=0;sub import {my$class=shift;my$import_utf8=1;while (my$arg=shift @_){croak "Unsupported import argument '$arg'" unless$arg eq 'encoding_only';$import_utf8=0}if ($import_utf8){require utf8;utf8->import}return if$LOADED++;test2_add_callback_post_load(sub {my$stack=test2_stack;$stack->top;my$warned=0;for my$hub ($stack->all){my$format=$hub->format || next;unless ($format->can('encoding')){warn "Could not apply UTF8 to unknown formatter ($format)\n" unless$warned++;next}$format->encoding('utf8')}})}1;
TEST2_PLUGIN_UTF8

$fatpacked{"Test2/Require.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE';
  package Test2::Require;use strict;use warnings;our$VERSION='0.000144';use Test2::API qw/context/;use Carp qw/croak/;sub skip {my$class=shift;croak "Class '$class' needs to implement 'skip()'"}sub import {my$class=shift;return if$class eq __PACKAGE__;my$skip=$class->skip(@_);return unless defined$skip;my$ctx=context();$ctx->plan(0,SKIP=>$skip || "No reason given.");$ctx->release}1;
TEST2_REQUIRE

$fatpacked{"Test2/Require/AuthorTesting.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_AUTHORTESTING';
  package Test2::Require::AuthorTesting;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000144';sub skip {my$class=shift;return undef if$ENV{'AUTHOR_TESTING'};return 'Author test, set the $AUTHOR_TESTING environment variable to run it'}1;
TEST2_REQUIRE_AUTHORTESTING

$fatpacked{"Test2/Require/EnvVar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_ENVVAR';
  package Test2::Require::EnvVar;use strict;use warnings;use Carp qw/confess/;use base 'Test2::Require';our$VERSION='0.000144';sub skip {my$class=shift;my ($var)=@_;confess "no environment variable specified" unless$var;return undef if$ENV{$var};return "This test only runs if the \$$var environment variable is set"}1;
TEST2_REQUIRE_ENVVAR

$fatpacked{"Test2/Require/Fork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_FORK';
  package Test2::Require::Fork;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000144';use Test2::Util qw/CAN_FORK/;sub skip {return undef if CAN_FORK;return "This test requires a perl capable of forking."}1;
TEST2_REQUIRE_FORK

$fatpacked{"Test2/Require/Module.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_MODULE';
  package Test2::Require::Module;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000144';use Test2::Util qw/pkg_to_file/;sub skip {my$class=shift;my ($module,$ver)=@_;return "Module '$module' is not installed" unless check_installed($module);return undef unless defined$ver;return check_version($module,$ver)}sub check_installed {my ($mod)=@_;my$file=pkg_to_file($mod);return 1 if eval {require$file;1};my$error=$@;return 0 if$error =~ m/Can't locate \Q$file\E in \@INC/;die$error}sub check_version {my ($mod,$ver)=@_;return undef if eval {$mod->VERSION($ver);1};my$have=$mod->VERSION;return "Need '$mod' version $ver, have $have."}1;
TEST2_REQUIRE_MODULE

$fatpacked{"Test2/Require/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_PERL';
  package Test2::Require::Perl;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000144';use Test2::Util qw/pkg_to_file/;use Scalar::Util qw/reftype/;sub skip {my$class=shift;my ($ver)=@_;return undef if eval "no warnings 'portable'; require $ver; 1";my$error=$@;return $1 if$error =~ m/^(Perl \S* required)/i;die$error}1;
TEST2_REQUIRE_PERL

$fatpacked{"Test2/Require/RealFork.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_REALFORK';
  package Test2::Require::RealFork;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000144';use Test2::Util qw/CAN_REALLY_FORK/;sub skip {return undef if CAN_REALLY_FORK;return "This test requires a perl capable of true forking."}1;
TEST2_REQUIRE_REALFORK

$fatpacked{"Test2/Require/Threads.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_REQUIRE_THREADS';
  package Test2::Require::Threads;use strict;use warnings;use base 'Test2::Require';our$VERSION='0.000144';use Test2::Util qw/CAN_THREAD/;sub skip {return undef if CAN_THREAD;return "This test requires a perl capable of threading."}1;
TEST2_REQUIRE_THREADS

$fatpacked{"Test2/Suite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_SUITE';
  package Test2::Suite;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_SUITE

$fatpacked{"Test2/Todo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TODO';
  package Test2::Todo;use strict;use warnings;use Carp qw/croak/;use Test2::Util::HashBase qw/hub _filter reason/;use Test2::API qw/test2_stack/;use overload '""'=>\&reason,fallback=>1;our$VERSION='0.000144';sub init {my$self=shift;my$reason=$self->{+REASON};croak "The 'reason' attribute is required" unless defined$reason;my$hub=$self->{+HUB}||= test2_stack->top;$self->{+_FILTER}=$hub->pre_filter(sub {my ($active_hub,$event)=@_;return Test2::Event::Note->new(%$event)if ref($event)eq 'Test2::Event::Diag';if ($active_hub==$hub){$event->set_todo($reason)if$event->can('set_todo');$event->add_amnesty({tag=>'TODO',details=>$reason});$event->set_effective_pass(1)if$event->isa('Test2::Event::Ok')}else {$event->add_amnesty({tag=>'TODO',details=>$reason,inherited=>1})}return$event},inherit=>1,todo=>$reason,)}sub end {my$self=shift;my$hub=$self->{+HUB}or return;$hub->pre_unfilter($self->{+_FILTER});delete$self->{+HUB};delete$self->{+_FILTER}}sub DESTROY {my$self=shift;$self->end}1;
TEST2_TODO

$fatpacked{"Test2/Tools.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS';
  package Test2::Tools;use strict;use warnings;our$VERSION='0.000144';1;
TEST2_TOOLS

$fatpacked{"Test2/Tools/AsyncSubtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_ASYNCSUBTEST';
  package Test2::Tools::AsyncSubtest;use strict;use warnings;our$VERSION='0.000144';use Test2::IPC;use Test2::AsyncSubtest;use Test2::API qw/context/;use Carp qw/croak/;our@EXPORT=qw/async_subtest fork_subtest thread_subtest/;use base 'Exporter';sub async_subtest {my$name=shift;my ($params,$code);$params=shift(@_)if @_ && ref($_[0])eq 'HASH';$code=shift(@_)if @_ && ref($_[0])eq 'CODE';my$ctx=context();my$subtest=Test2::AsyncSubtest->new(name=>$name,context=>1,hub_init_args=>$params);$subtest->run($code,$subtest)if$code;$ctx->release;return$subtest}sub fork_subtest {my$name=shift;my ($params,$code);$params=shift(@_)if @_ && ref($_[0])eq 'HASH';$code=shift(@_)if @_ && ref($_[0])eq 'CODE';my$ctx=context();croak "fork_subtest requires a CODE reference as the second argument" unless ref($code)eq 'CODE';my$subtest=Test2::AsyncSubtest->new(name=>$name,context=>1,hub_init_args=>$params);$subtest->run_fork($code,$subtest);$ctx->release;return$subtest}sub thread_subtest {my$name=shift;my ($params,$code);$params=shift(@_)if @_ && ref($_[0])eq 'HASH';$code=shift(@_)if @_ && ref($_[0])eq 'CODE';my$ctx=context();croak "thread_subtest requires a CODE reference as the second argument" unless ref($code)eq 'CODE';my$subtest=Test2::AsyncSubtest->new(name=>$name,context=>1,hub_init_args=>$params);$subtest->run_thread($code,$subtest);$ctx->release;return$subtest}1;
TEST2_TOOLS_ASYNCSUBTEST

$fatpacked{"Test2/Tools/Basic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_BASIC';
  package Test2::Tools::Basic;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use Test2::API qw/context/;our@EXPORT=qw{ok pass fail diag note todo skip plan skip_all done_testing bail_out};use base 'Exporter';sub ok($;$@) {my ($bool,$name,@diag)=@_;my$ctx=context();$ctx->ok($bool,$name,\@diag);$ctx->release;return$bool ? 1 : 0}sub pass {my ($name)=@_;my$ctx=context();$ctx->ok(1,$name);$ctx->release;return 1}sub fail {my ($name,@diag)=@_;my$ctx=context();$ctx->ok(0,$name,\@diag);$ctx->release;return 0}sub diag {my$ctx=context();$ctx->diag(join '',grep {defined $_}@_);$ctx->release}sub note {my$ctx=context();$ctx->note(join '',grep {defined $_}@_);$ctx->release}sub todo {my$reason=shift;my$code=shift;require Test2::Todo unless$INC{'Test2/Todo.pm'};my$todo=Test2::Todo->new(reason=>$reason);return$code->()if$code;croak "Cannot use todo() in a void context without a codeblock" unless defined wantarray;return$todo}sub skip {my ($why,$num)=@_;$num ||= 1;my$ctx=context();$ctx->skip("skipped test",$why)for 1 .. $num;$ctx->release;no warnings 'exiting';last SKIP}sub plan {my$plan=shift;my$ctx=context();if ($plan && $plan =~ m/[^0-9]/){if ($plan eq 'tests'){$plan=shift}elsif ($plan eq 'skip_all'){skip_all(@_);$ctx->release;return}}$ctx->plan($plan);$ctx->release}sub skip_all {my ($reason)=@_;my$ctx=context();$ctx->plan(0,SKIP=>$reason);$ctx->release if$ctx}sub done_testing {my$ctx=context();$ctx->hub->finalize($ctx->trace,1);$ctx->release}sub bail_out {my ($reason)=@_;my$ctx=context();$ctx->bail($reason);$ctx->release if$ctx}1;
TEST2_TOOLS_BASIC

$fatpacked{"Test2/Tools/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_CLASS';
  package Test2::Tools::Class;use strict;use warnings;our$VERSION='0.000144';use Test2::API qw/context/;use Test2::Util::Ref qw/render_ref/;use Scalar::Util qw/blessed/;our@EXPORT=qw/can_ok isa_ok DOES_ok/;use base 'Exporter';BEGIN {for my$op (qw/isa can DOES/){my$sub=sub($;@) {my ($thing,@args)=@_;my$ctx=context();my (@items,$name);if (ref($args[0])eq 'ARRAY'){$name=$args[1];@items=@{$args[0]}}else {@items=@args}my$thing_name=ref($thing)? render_ref($thing): defined($thing)? "$thing" : "<undef>";$thing_name =~ s/\n/\\n/g;$thing_name =~ s/#//g;$thing_name =~ s/\(0x[a-f0-9]+\)//gi;$name ||= @items==1 ? "$thing_name\->$op('$items[0]')" : "$thing_name\->$op(...)";unless (defined($thing)&& (blessed($thing)||!ref($thing)&& length($thing))){my$thing=defined($thing)? ref($thing)|| "'$thing'" : '<undef>';$ctx->ok(0,$name,["$thing is neither a blessed reference or a package name."]);$ctx->release;return 0}unless(UNIVERSAL->can($op)|| $thing->can($op)){$ctx->skip($name,"'$op' is not supported on this platform");$ctx->release;return 1}my$file=$ctx->trace->file;my$line=$ctx->trace->line;my@bad;for my$item (@items){my ($bool,$ok,$err);{local ($@,$!);$ok=eval qq/#line $line "$file"\n\$bool = \$thing->$op(\$item); 1/;$err=$@}die$err unless$ok;next if$bool;push@bad=>$item}$ctx->ok(!@bad,$name,[map {"Failed: $thing_name\->$op('$_')"}@bad]);$ctx->release;return!@bad};no strict 'refs';*{$op ."_ok"}=$sub}}1;
TEST2_TOOLS_CLASS

$fatpacked{"Test2/Tools/ClassicCompare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_CLASSICCOMPARE';
  package Test2::Tools::ClassicCompare;use strict;use warnings;our$VERSION='0.000144';our@EXPORT=qw/is is_deeply isnt like unlike cmp_ok/;use base 'Exporter';use Carp qw/carp/;use Scalar::Util qw/reftype/;use Test2::API qw/context/;use Test2::Compare qw/compare strict_convert/;use Test2::Util::Ref qw/rtype render_ref/;use Test2::Util::Table qw/table/;use Test2::Compare::Array();use Test2::Compare::Bag();use Test2::Compare::Custom();use Test2::Compare::Event();use Test2::Compare::Hash();use Test2::Compare::Meta();use Test2::Compare::Number();use Test2::Compare::Object();use Test2::Compare::OrderedSubset();use Test2::Compare::Pattern();use Test2::Compare::Ref();use Test2::Compare::Regex();use Test2::Compare::Scalar();use Test2::Compare::Set();use Test2::Compare::String();use Test2::Compare::Undef();use Test2::Compare::Wildcard();sub is($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my@caller=caller;my$delta=compare($got,$exp,\&is_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub isnt($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my@caller=caller;my$delta=compare($got,$exp,\&isnt_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub is_convert {my ($thing)=@_;return Test2::Compare::Undef->new()unless defined$thing;return Test2::Compare::String->new(input=>$thing)}sub isnt_convert {my ($thing)=@_;return Test2::Compare::Undef->new()unless defined$thing;my$str=Test2::Compare::String->new(input=>$thing,negate=>1)}sub like($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&like_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub unlike($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&unlike_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub like_convert {my ($thing)=@_;return Test2::Compare::Pattern->new(pattern=>$thing,stringify_got=>1,)}sub unlike_convert {my ($thing)=@_;return Test2::Compare::Pattern->new(negate=>1,stringify_got=>1,pattern=>$thing,)}sub is_deeply($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my@caller=caller;my$delta=compare($got,$exp,\&strict_convert);if ($delta){my$count=0;my$implicit=0;my@deltas=($delta);while (my$d=shift@deltas){my$add=$d->children;push@deltas=>@$add if$add && @$add;next if$d->verified;$count++;$implicit++ if$d->note && $d->note eq 'implicit end'}if ($implicit==$count){$ctx->ok(1,$name);my$meth=$ENV{AUTHOR_TESTING}? 'throw' : 'alert';my$type=$delta->render_check;$ctx->$meth(join "\n","!!! NOTICE OF BEHAVIOR CHANGE !!!","This test uses at least 1 $type check without using end() or etc().","The exising behavior is to default to etc() when inside is_deeply().","The new behavior is to default to end().","This test will soon start to fail with the following diagnostics:",$delta->diag->as_string,"",)}else {$ctx->fail($name,$delta->diag,@diag)}}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}our%OPS=('=='=>'num','!='=>'num','>='=>'num','<='=>'num','>'=>'num','<'=>'num','<=>'=>'num','eq'=>'str','ne'=>'str','gt'=>'str','lt'=>'str','ge'=>'str','le'=>'str','cmp'=>'str','!~'=>'str','=~'=>'str','&&'=>'logic','||'=>'logic','xor'=>'logic','or'=>'logic','and'=>'logic','//'=>'logic','&'=>'bitwise','|'=>'bitwise','~~'=>'match',);sub cmp_ok($$$;$@) {my ($got,$op,$exp,$name,@diag)=@_;my$ctx=context();my ($pkg,$file,$line)=caller;my$type=$OPS{$op};if (!$type){carp "operator '$op' is not supported (you can add it to %Test2::Tools::ClassicCompare::OPS)";$type='unsupported'}local ($@,$!,$SIG{__DIE__});my$test;my$lived=eval <<"    EOT";my$error=$@;$ctx->send_event('Exception',error=>$error)unless$lived;if ($test && $lived){$ctx->ok(1,$name);$ctx->release;return 1}my ($display_got,$display_exp);if($type eq 'str'){$display_got=defined($got)? "$got" : undef;$display_exp=defined($exp)? "$exp" : undef}elsif($type eq 'num'){$display_got=defined($got)? $got + 0 : undef;$display_exp=defined($exp)? $exp + 0 : undef}else {$display_got=$got;$display_exp=$exp}my$got_ref=ref($got)? render_ref($got): $got;my$exp_ref=ref($exp)? render_ref($exp): $exp;my@table;my$show_both=((defined($got)&& $got_ref ne "$display_got")|| (defined($exp)&& $exp_ref ne "$display_exp"));if ($show_both){@table=table(header=>['TYPE','GOT','OP','CHECK'],rows=>[[$type,$display_got,$op,$lived ? $display_exp : '<EXCEPTION>'],['orig',$got_ref,'',$exp_ref],],)}else {@table=table(header=>['GOT','OP','CHECK'],rows=>[[$display_got,$op,$lived ? $display_exp : '<EXCEPTION>']],)}$ctx->ok(0,$name,[join("\n",@table),@diag]);$ctx->release;return 0}1;
  #line $line "(eval in cmp_ok) $file"
  \$test = (\$got $op \$exp);
  1;
      EOT
TEST2_TOOLS_CLASSICCOMPARE

$fatpacked{"Test2/Tools/Compare.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_COMPARE';
  package Test2::Tools::Compare;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use Scalar::Util qw/reftype/;use Test2::API qw/context/;use Test2::Util::Ref qw/rtype/;use Test2::Compare qw{compare get_build push_build pop_build build strict_convert relaxed_convert};use Test2::Compare::Array();use Test2::Compare::Bag();use Test2::Compare::Bool();use Test2::Compare::Custom();use Test2::Compare::Event();use Test2::Compare::Float();use Test2::Compare::Hash();use Test2::Compare::Isa();use Test2::Compare::Meta();use Test2::Compare::Number();use Test2::Compare::Object();use Test2::Compare::OrderedSubset();use Test2::Compare::Pattern();use Test2::Compare::Ref();use Test2::Compare::DeepRef();use Test2::Compare::Regex();use Test2::Compare::Scalar();use Test2::Compare::Set();use Test2::Compare::String();use Test2::Compare::Undef();use Test2::Compare::Wildcard();%Carp::Internal=(%Carp::Internal,'Test2::Tools::Compare'=>1,'Test2::Compare::Array'=>1,'Test2::Compare::Bag'=>1,'Test2::Compare::Bool'=>1,'Test2::Compare::Custom'=>1,'Test2::Compare::Event'=>1,'Test2::Compare::Float'=>1,'Test2::Compare::Hash'=>1,'Test2::Compare::Isa'=>1,'Test2::Compare::Meta'=>1,'Test2::Compare::Number'=>1,'Test2::Compare::Object'=>1,'Test2::Compare::Pattern'=>1,'Test2::Compare::Ref'=>1,'Test2::Compare::Regex'=>1,'Test2::Compare::Scalar'=>1,'Test2::Compare::Set'=>1,'Test2::Compare::String'=>1,'Test2::Compare::Undef'=>1,'Test2::Compare::Wildcard'=>1,'Test2::Compare::OrderedSubset'=>1,);our@EXPORT=qw/is like/;our@EXPORT_OK=qw{is like isnt unlike match mismatch validator hash array bag object meta meta_check number float rounded within string subset bool check_isa in_set not_in_set check_set item field call call_list call_hash prop check all_items all_keys all_vals all_values etc end filter_items T F D DF E DNE FDNE U L event fail_events exact_ref};use base 'Exporter';sub is($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&strict_convert);if ($delta){my$count=0;my$implicit=0;my@deltas=($delta);while (my$d=shift@deltas){my$add=$d->children;push@deltas=>@$add if$add && @$add;next if$d->verified;$count++;$implicit++ if$d->note && $d->note eq 'implicit end'}if ($implicit==$count){$ctx->ok(1,$name);my$meth=$ENV{AUTHOR_TESTING}? 'throw' : 'alert';my$type=$delta->render_check;$ctx->$meth(join "\n","!!! NOTICE OF BEHAVIOR CHANGE !!!","This test uses at least 1 $type check without using end() or etc().","The old behavior was to default to etc() when inside is().","The old behavior was a bug.","The new behavior is to default to end().","This test will soon start to fail with the following diagnostics:",$delta->diag->as_string,"",)}else {$ctx->fail($name,$delta->diag,@diag)}}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub isnt($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&strict_convert);if ($delta){$ctx->ok(1,$name)}else {$ctx->ok(0,$name,["Comparison matched (it should not).",@diag])}$ctx->release;return$delta ? 1 : 0}sub like($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&relaxed_convert);if ($delta){$ctx->fail($name,$delta->diag,@diag)}else {$ctx->ok(1,$name)}$ctx->release;return!$delta}sub unlike($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();my$delta=compare($got,$exp,\&relaxed_convert);if ($delta){$ctx->ok(1,$name)}else {$ctx->ok(0,$name,["Comparison matched (it should not).",@diag])}$ctx->release;return$delta ? 1 : 0}sub meta(&) {build('Test2::Compare::Meta',@_)}sub meta_check(&) {build('Test2::Compare::Meta',@_)}sub hash(&) {build('Test2::Compare::Hash',@_)}sub array(&) {build('Test2::Compare::Array',@_)}sub bag(&) {build('Test2::Compare::Bag',@_)}sub object(&) {build('Test2::Compare::Object',@_)}sub subset(&) {build('Test2::Compare::OrderedSubset',@_)}sub U() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ ? 0 : 1},name=>'UNDEFINED',operator=>'!DEFINED()',file=>$caller[1],lines=>[$caller[2]],)}sub D() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ ? 1 : 0},name=>'DEFINED',operator=>'DEFINED()',file=>$caller[1],lines=>[$caller[2]],)}sub DF() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ && (!ref $_ &&!$_)? 1 : 0},name=>'DEFINED BUT FALSE',operator=>'DEFINED() && FALSE()',file=>$caller[1],lines=>[$caller[2]],)}sub DNE() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {my%p=@_;$p{exists}? 0 : 1},name=>'<DOES NOT EXIST>',operator=>'!exists',file=>$caller[1],lines=>[$caller[2]],)}sub E() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {my%p=@_;$p{exists}? 1 : 0},name=>'<DOES EXIST>',operator=>'!exists',file=>$caller[1],lines=>[$caller[2]],)}sub F() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {my%p=@_;$p{got}? 0 : $p{exists}},name=>'FALSE',operator=>'FALSE()',file=>$caller[1],lines=>[$caller[2]],)}sub FDNE() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ && (ref $_ || $_)? 0 : 1},name=>'FALSE',operator=>'FALSE() || !exists',file=>$caller[1],lines=>[$caller[2]],)}sub T() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ && (ref $_ || $_)? 1 : 0},name=>'TRUE',operator=>'TRUE()',file=>$caller[1],lines=>[$caller[2]],)}sub L() {my@caller=caller;Test2::Compare::Custom->new(code=>sub {defined $_ && length $_ ? 1 : 0},name=>'LENGTH',operator=>'DEFINED() && LENGTH()',file=>$caller[1],lines=>[$caller[2]],)}sub exact_ref($) {my@caller=caller;return Test2::Compare::Ref->new(file=>$caller[1],lines=>[$caller[2]],input=>$_[0],)}sub match($) {my@caller=caller;return Test2::Compare::Pattern->new(file=>$caller[1],lines=>[$caller[2]],pattern=>$_[0],)}sub mismatch($) {my@caller=caller;return Test2::Compare::Pattern->new(file=>$caller[1],lines=>[$caller[2]],negate=>1,pattern=>$_[0],)}sub validator {my$code=pop;my$cname=pop;my$op=pop;my@caller=caller;return Test2::Compare::Custom->new(file=>$caller[1],lines=>[$caller[2]],code=>$code,name=>$cname,operator=>$op,)}sub number($;@) {my ($num,@args)=@_;my@caller=caller;return Test2::Compare::Number->new(file=>$caller[1],lines=>[$caller[2]],input=>$num,@args,)}sub float($;@) {my ($num,@args)=@_;my@caller=caller;return Test2::Compare::Float->new(file=>$caller[1],lines=>[$caller[2]],input=>$num,@args,)}sub rounded($$) {my ($num,$precision)=@_;my@caller=caller;return Test2::Compare::Float->new(file=>$caller[1],lines=>[$caller[2]],input=>$num,precision=>$precision,)}sub within($;$) {my ($num,$tolerance)=@_;my@caller=caller;return Test2::Compare::Float->new(file=>$caller[1],lines=>[$caller[2]],input=>$num,defined$tolerance ? (tolerance=>$tolerance): (),)}sub bool($;@) {my ($bool,@args)=@_;my@caller=caller;return Test2::Compare::Bool->new(file=>$caller[1],lines=>[$caller[2]],input=>$bool,@args,)}sub string($;@) {my ($str,@args)=@_;my@caller=caller;return Test2::Compare::String->new(file=>$caller[1],lines=>[$caller[2]],input=>$str,@args,)}sub check_isa($;@) {my ($class_name,@args)=@_;my@caller=caller;return Test2::Compare::Isa->new(file=>$caller[1],lines=>[$caller[2]],input=>$class_name,@args,)}sub filter_items(&) {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support filters" unless$build->can('add_filter');croak "'filter_items' should only ever be called in void context" if defined wantarray;$build->add_filter(@_)}sub all_items {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support all-items" unless$build->can('add_for_each');croak "'all_items' should only ever be called in void context" if defined wantarray;$build->add_for_each(@_)}sub all_keys {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support all-keys" unless$build->can('add_for_each_key');croak "'all_keys' should only ever be called in void context" if defined wantarray;$build->add_for_each_key(@_)}*all_vals=*all_values;sub all_values {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support all-values" unless$build->can('add_for_each_val');croak "'all_values' should only ever be called in void context" if defined wantarray;$build->add_for_each_val(@_)}sub end() {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support 'ending'" unless$build->can('ending');croak "'end' should only ever be called in void context" if defined wantarray;$build->set_ending(1)}sub etc() {defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support 'ending'" unless$build->can('ending');croak "'etc' should only ever be called in void context" if defined wantarray;$build->set_ending(0)}my$_call=sub {my ($name,$expect,$context,$func_name)=@_;defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support method calls" unless$build->can('add_call');croak "'$func_name' should only ever be called in void context" if defined wantarray;my@caller=caller;$build->add_call($name,Test2::Compare::Wildcard->new(expect=>$expect,file=>$caller[1],lines=>[$caller[2]],),undef,$context,)};sub call($$) {$_call->(@_,'scalar','call')}sub call_list($$) {$_call->(@_,'list','call_list')}sub call_hash($$) {$_call->(@_,'hash','call_hash')}sub prop($$) {my ($name,$expect)=@_;defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support meta-checks" unless$build->can('add_prop');croak "'prop' should only ever be called in void context" if defined wantarray;my@caller=caller;$build->add_prop($name,Test2::Compare::Wildcard->new(expect=>$expect,file=>$caller[1],lines=>[$caller[2]],),)}sub item($;$) {my@args=@_;my$expect=pop@args;defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support array item checks" unless$build->can('add_item');croak "'item' should only ever be called in void context" if defined wantarray;my@caller=caller;push@args=>Test2::Compare::Wildcard->new(expect=>$expect,file=>$caller[1],lines=>[$caller[2]],);$build->add_item(@args)}sub field($$) {my ($name,$expect)=@_;defined(my$build=get_build())or croak "No current build!";croak "'$build' does not support hash field checks" unless$build->can('add_field');croak "'field' should only ever be called in void context" if defined wantarray;my@caller=caller;$build->add_field($name,Test2::Compare::Wildcard->new(expect=>$expect,file=>$caller[1],lines=>[$caller[2]],),)}sub check($) {my ($check)=@_;defined(my$build=get_build())or croak "No current build!";croak "'$build' is not a check-set" unless$build->can('add_check');croak "'check' should only ever be called in void context" if defined wantarray;my@caller=caller;my$wc=Test2::Compare::Wildcard->new(expect=>$check,file=>$caller[1],lines=>[$caller[2]],);$build->add_check($wc)}sub check_set {return _build_set('all'=>@_)}sub in_set {return _build_set('any'=>@_)}sub not_in_set {return _build_set('none'=>@_)}sub _build_set {my$redux=shift;my ($builder)=@_;my$btype=reftype($builder)|| '';my$set;if ($btype eq 'CODE'){$set=build('Test2::Compare::Set',$builder);$set->set_builder($builder)}else {$set=Test2::Compare::Set->new(checks=>[@_])}$set->set_reduction($redux);return$set}sub fail_events($;$) {my$event=&event(@_);my$diag=event('Diag');return ($event,$diag)if defined wantarray;defined(my$build=get_build())or croak "No current build!";$build->add_item($event);$build->add_item($diag)}sub event($;$) {my ($intype,$spec)=@_;my@caller=caller;croak "type is required" unless$intype;my$type;if ($intype =~ m/^\+(.*)$/){$type=$1}else {$type="Test2::Event::$intype"}my$event;if (!$spec){$event=Test2::Compare::Event->new(etype=>$intype,file=>$caller[1],lines=>[$caller[2]],ending=>0,)}elsif (!ref$spec){croak "'$spec' is not a valid event specification"}elsif (reftype($spec)eq 'CODE'){$event=build('Test2::Compare::Event',$spec);$event->set_etype($intype);$event->set_builder($spec);$event->set_ending(0)unless defined$event->ending}else {my$refcheck=Test2::Compare::Hash->new(inref=>$spec,file=>$caller[1],lines=>[$caller[2]],);$event=Test2::Compare::Event->new(refcheck=>$refcheck,file=>$caller[1],lines=>[$caller[2]],etype=>$intype,ending=>0,)}$event->add_prop('blessed'=>$type);return$event if defined wantarray;defined(my$build=get_build())or croak "No current build!";$build->add_item($event)}1;
TEST2_TOOLS_COMPARE

$fatpacked{"Test2/Tools/Defer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_DEFER';
  package Test2::Tools::Defer;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use Test2::Util qw/get_tid/;use Test2::API qw{test2_add_callback_exit test2_pid test2_tid};our@EXPORT=qw/def do_def/;use base 'Exporter';my%TODO;sub def {my ($func,@args)=@_;my@caller=caller(0);$TODO{$caller[0]}||= [];push @{$TODO{$caller[0]}}=>[$func,\@args,\@caller]}sub do_def {my$for=caller;my$tests=delete$TODO{$for}or croak "No tests to run!";for my$test (@$tests){my ($func,$args,$caller)=@$test;my ($pkg,$file,$line)=@$caller;chomp(my$eval=<<"        EOT");eval$eval and next;chomp(my$error=$@);require Data::Dumper;chomp(my$td=Data::Dumper::Dumper($args));$td =~ s/^\$VAR1 =/\$args: /;die <<"        EOT"}return}sub _verify {my ($context,$exit,$new_exit)=@_;my$not_ok=0;for my$pkg (keys%TODO){my$tests=delete$TODO{$pkg};my$caller=$tests->[0]->[-1];print STDOUT "not ok - deferred tests were not run!\n" unless$not_ok++;print STDERR "# '$pkg' has deferred tests that were never run!\n";print STDERR "#   $caller->[1] at line $caller->[2]\n";$$new_exit ||= 255}}test2_add_callback_exit(\&_verify);1;
  package $pkg;
  # line $line "(eval in Test2::Tools::Defer) $file"
  \&$func(\@\$args);
  1;
          EOT
  Exception: $error
  --eval--
  $eval
  --------
  Tool:   $func
  Caller: $caller->[0], $caller->[1], $caller->[2]
  $td
          EOT
TEST2_TOOLS_DEFER

$fatpacked{"Test2/Tools/Encoding.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_ENCODING';
  package Test2::Tools::Encoding;use strict;use warnings;use Carp qw/croak/;use Test2::API qw/test2_stack/;use base 'Exporter';our$VERSION='0.000144';our@EXPORT=qw/set_encoding/;sub set_encoding {my$enc=shift;my$format=test2_stack->top->format;unless ($format && eval {$format->can('encoding')}){$format='<undef>' unless defined$format;croak "Unable to set encoding on formatter '$format'"}$format->encoding($enc)}1;
TEST2_TOOLS_ENCODING

$fatpacked{"Test2/Tools/Event.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_EVENT';
  package Test2::Tools::Event;use strict;use warnings;our$VERSION='0.000144';use Test2::Util qw/pkg_to_file/;our@EXPORT=qw/gen_event/;use base 'Exporter';sub gen_event {my ($type,%fields)=@_;$type="Test2::Event::$type" unless$type =~ s/^\+//;require(pkg_to_file($type));$fields{trace}||= Test2::Util::Trace->new(frame=>[caller(0)]);return$type->new(%fields)}1;
TEST2_TOOLS_EVENT

$fatpacked{"Test2/Tools/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_EXCEPTION';
  package Test2::Tools::Exception;use strict;use warnings;our$VERSION='0.000144';use Carp qw/carp/;use Test2::API qw/context/;our@EXPORT=qw/dies lives try_ok/;use base 'Exporter';sub dies(&) {my$code=shift;defined wantarray or carp "Useless use of dies() in void context";local ($@,$!,$?);my$ok=eval {$code->();1};my$err=$@;return undef if$ok;unless ($err){my$ctx=context();$ctx->alert("Got exception as expected, but exception is falsy (undef, '', or 0)...");$ctx->release}return$err}sub lives(&) {my$code=shift;defined wantarray or carp "Useless use of lives() in void context";my$err;{local ($@,$!,$?);eval {$code->();1}and return 1;$err=$@}$@=$err;return 0}sub try_ok(&;$) {my ($code,$name)=@_;my$ok=&lives($code);my$err=$@;my$ctx=context();chomp(my$diag="Exception: $err");$ctx->ok($ok,$name,[$diag]);$ctx->release;$@=$err unless$ok;return$ok}1;
TEST2_TOOLS_EXCEPTION

$fatpacked{"Test2/Tools/Exports.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_EXPORTS';
  package Test2::Tools::Exports;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak carp/;use Test2::API qw/context/;use Test2::Util::Stash qw/get_symbol/;our@EXPORT=qw/imported_ok not_imported_ok/;use base 'Exporter';sub imported_ok {my$ctx=context();my$caller=caller;my@missing=grep {!get_symbol($_,$caller)}@_;my$name="Imported symbol";$name .= "s" if @_ > 1;$name .= ": ";my$list=join(", ",@_);substr($list,37,length($list)- 37,'...')if length($list)> 40;$name .= $list;$ctx->ok(!@missing,$name,[map {"'$_' was not imported."}@missing]);$ctx->release;return!@missing}sub not_imported_ok {my$ctx=context();my$caller=caller;my@found=grep {get_symbol($_,$caller)}@_;my$name="Did not imported symbol";$name .= "s" if @_ > 1;$name .= ": ";my$list=join(", ",@_);substr($list,37,length($list)- 37,'...')if length($list)> 40;$name .= $list;$ctx->ok(!@found,$name,[map {"'$_' was imported."}@found]);$ctx->release;return!@found}1;
TEST2_TOOLS_EXPORTS

$fatpacked{"Test2/Tools/GenTemp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_GENTEMP';
  package Test2::Tools::GenTemp;use strict;use warnings;our$VERSION='0.000144';use File::Temp qw/tempdir/;use File::Spec;our@EXPORT=qw{gen_temp};use base 'Exporter';sub gen_temp {my%args=@_;my$tempdir_args=delete$args{'-tempdir'}|| [CLEANUP=>1,TMPDIR=>1];my$tmp=tempdir(@$tempdir_args);gen_dir($tmp,\%args);return$tmp}sub gen_dir {my ($dir,$content)=@_;for my$path (keys %$content){my$fq=File::Spec->catfile($dir,$path);my$inside=$content->{$path};if (ref$inside){mkdir($fq)or die "Could not make dir '$fq': $!";gen_dir($fq,$inside)}else {open(my$fh,'>',$fq)or die "Could not open file '$fq' for writing: $!";print$fh $inside;close($fh)}}}1;
TEST2_TOOLS_GENTEMP

$fatpacked{"Test2/Tools/Grab.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_GRAB';
  package Test2::Tools::Grab;use strict;use warnings;our$VERSION='0.000144';use Test2::Util::Grabber;use Test2::EventFacet::Trace();our@EXPORT=qw/grab/;use base 'Exporter';sub grab {Test2::Util::Grabber->new(trace=>Test2::EventFacet::Trace->new(frame=>[caller(0)]))}1;
TEST2_TOOLS_GRAB

$fatpacked{"Test2/Tools/Mock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_MOCK';
  package Test2::Tools::Mock;use strict;use warnings;use Carp qw/croak/;use Scalar::Util qw/blessed reftype weaken/;use Test2::Util qw/try/;use Test2::Util::Sub qw/gen_accessor gen_reader gen_writer/;use Test2::Mock();use base 'Exporter';our$VERSION='0.000144';our@CARP_NOT=(__PACKAGE__,'Test2::Mock');our@EXPORT=qw/mock mocked/;our@EXPORT_OK=qw{mock_obj mock_class mock_do mock_build mock_accessor mock_accessors mock_getter mock_getters mock_setter mock_setters mock_building};my%HANDLERS;my%MOCKS;my@BUILD;sub add_handler {my$class=shift;my ($for,$code)=@_;croak "Must specify a package for the mock handler" unless$for;croak "Handlers must be code referneces (got: $code)" unless$code && ref($code)eq 'CODE';push @{$HANDLERS{$for}}=>$code}sub mock_building {return unless@BUILD;return$BUILD[-1]}sub mocked {my$proto=shift;my$class=blessed($proto)|| $proto;my$set=$MOCKS{$class}|| return;pop @$set while @$set &&!defined($set->[-1]);delete$MOCKS{$class}unless @$set;return @$set}sub _delegate {my ($args)=@_;my$do=__PACKAGE__->can('mock_do');my$obj=__PACKAGE__->can('mock_obj');my$class=__PACKAGE__->can('mock_class');my$build=__PACKAGE__->can('mock_build');return$obj unless @$args;my ($proto,$arg1)=@$args;return$obj if ref($proto)&&!blessed($proto);if (blessed($proto)){return$class unless$proto->isa('Test2::Mock');return$build if$arg1 && ref($arg1)&& reftype($arg1)eq 'CODE'}return$class if$proto =~ m/(?:::|')/;return$class if$proto =~ m/^_*[A-Z]/;return$do if Test2::Mock->can($proto);if (my$sub=__PACKAGE__->can("mock_$proto")){shift @$args;return$sub}return undef}sub mock {croak "undef is not a valid first argument to mock()" if @_ &&!defined($_[0]);my$sub=_delegate(\@_);croak "'$_[0]' does not look like a package name, and is not a valid control method" unless$sub;$sub->(@_)}sub mock_build {my ($control,$sub)=@_;croak "mock_build requires a Test2::Mock object as its first argument" unless$control && blessed($control)&& $control->isa('Test2::Mock');croak "mock_build requires a coderef as its second argument" unless$sub && ref($sub)&& reftype($sub)eq 'CODE';push@BUILD=>$control;my ($ok,$err)=&try($sub);pop@BUILD;die$err unless$ok}sub mock_do {my ($meth,@args)=@_;croak "Not currently building a mock" unless@BUILD;my$build=$BUILD[-1];croak "'$meth' is not a valid action for mock_do()" if$meth =~ m/^_/ ||!$build->can($meth);$build->$meth(@args)}sub mock_obj {my ($proto)=@_;if ($proto && ref($proto)&& reftype($proto)ne 'CODE'){shift @_}else {$proto={}}my$class=_generate_class();my$control;if (@_==1 && reftype($_[0])eq 'CODE'){my$orig=shift @_;$control=mock_class($class,sub {my$c=mock_building;$c->block_load(1);$c->purge_on_destroy(1);$c->autoload(1);$orig->(@_)},)}else {$control=mock_class($class,block_load=>1,purge_on_destroy=>1,autoload=>1,@_,)}my$new=bless($proto,$control->class);$new->{'~~MOCK~CONTROL~~'}=$control;return$new}sub _generate_class {my$prefix=__PACKAGE__;for (1 .. 100){my$postfix=join '',map {chr(rand(26)+ 65)}1 .. 32;my$class=$prefix .'::__TEMP__::' .$postfix;my$file=$class;$file =~ s{::}{/}g;$file .= '.pm';next if$INC{$file};my$stash=do {no strict 'refs';\%{"${class}\::"}};next if keys %$stash;return$class}croak "Could not generate a unique class name after 100 attempts"}sub mock_class {my$proto=shift;my$class=blessed($proto)|| $proto;my@args=@_;my$void=!defined(wantarray);my$callback=sub {my ($parent)=reverse mocked($class);my$control;if (@args==1 && ref($args[0])&& reftype($args[0])eq 'CODE'){$control=Test2::Mock->new(class=>$class);mock_build($control,@args)}else {$control=Test2::Mock->new(class=>$class,@args)}if ($parent){$control->{parent}=$parent;weaken($parent->{child}=$control)}$MOCKS{$class}||= [];push @{$MOCKS{$class}}=>$control;weaken($MOCKS{$class}->[-1]);return$control};return$callback->()unless$void;my$level=0;my$caller;while (my@call=caller($level++)){next if$call[0]eq __PACKAGE__;$caller=\@call;last}my$handled;for my$handler (@{$HANDLERS{$caller->[0]}}){$handled++ if$handler->(class=>$class,caller=>$caller,builder=>$callback,args=>\@args,)}croak "mock_class should not be called in a void context without a registered handler" unless$handled}sub mock_accessors {return map {($_=>gen_accessor($_))}@_}sub mock_accessor {my ($field)=@_;return gen_accessor($field)}sub mock_getters {my ($prefix,@list)=@_;return map {("$prefix$_"=>gen_reader($_))}@list}sub mock_getter {my ($field)=@_;return gen_reader($field)}sub mock_setters {my ($prefix,@list)=@_;return map {("$prefix$_"=>gen_writer($_))}@list}sub mock_setter {my ($field)=@_;return gen_writer($field)}1;
TEST2_TOOLS_MOCK

$fatpacked{"Test2/Tools/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_REF';
  package Test2::Tools::Ref;use strict;use warnings;our$VERSION='0.000144';use Scalar::Util qw/reftype refaddr/;use Test2::API qw/context/;use Test2::Util::Ref qw/render_ref/;our@EXPORT=qw/ref_ok ref_is ref_is_not/;use base 'Exporter';sub ref_ok($;$$) {my ($thing,$wanttype,$name)=@_;my$ctx=context();my$gotname=render_ref($thing);my$gottype=reftype($thing);if (!$gottype){$ctx->ok(0,$name,["'$gotname' is not a reference"]);$ctx->release;return 0}if ($wanttype && $gottype ne $wanttype){$ctx->ok(0,$name,["'$gotname' is not a '$wanttype' reference"]);$ctx->release;return 0}$ctx->ok(1,$name);$ctx->release;return 1}sub ref_is($$;$@) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();$got='<undef>' unless defined$got;$exp='<undef>' unless defined$exp;my$bool=0;if (!ref($got)){$ctx->ok(0,$name,["First argument '$got' is not a reference",@diag])}elsif(!ref($exp)){$ctx->ok(0,$name,["Second argument '$exp' is not a reference",@diag])}else {$bool=refaddr($got)==refaddr($exp);$ctx->ok($bool,$name,["'$got' is not the same reference as '$exp'",@diag])}$ctx->release;return$bool ? 1 : 0}sub ref_is_not($$;$) {my ($got,$exp,$name,@diag)=@_;my$ctx=context();$got='<undef>' unless defined$got;$exp='<undef>' unless defined$exp;my$bool=0;if (!ref($got)){$ctx->ok(0,$name,["First argument '$got' is not a reference",@diag])}elsif(!ref($exp)){$ctx->ok(0,$name,["Second argument '$exp' is not a reference",@diag])}else {$bool=refaddr($got)!=refaddr($exp);$ctx->ok($bool,$name,["'$got' is the same reference as '$exp'",@diag])}$ctx->release;return$bool ? 1 : 0}1;
TEST2_TOOLS_REF

$fatpacked{"Test2/Tools/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_SPEC';
  package Test2::Tools::Spec;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use Test2::Workflow qw/parse_args build current_build root_build init_root build_stack/;use Test2::API qw/test2_add_callback_testing_done/;use Test2::Workflow::Runner();use Test2::Workflow::Task::Action();use Test2::Workflow::Task::Group();use Test2::Tools::Mock();use Importer();use vars qw/@EXPORT @EXPORT_OK/;push@EXPORT=>qw{describe cases};push@EXPORT_OK=>qw{include_workflow include_workflows spec_defaults};my%HANDLED;sub import {my$class=shift;my@caller=caller(0);my%root_args;my%runner_args;my@import;while (my$arg=shift @_){if ($arg =~ s/^-//){my$val=shift @_;if (Test2::Workflow::Runner->can($arg)){$runner_args{$arg}=$val}elsif (Test2::Workflow::Task::Group->can($arg)){$root_args{$arg}=$val}elsif ($arg eq 'root_args'){%root_args=(%root_args,%$val)}elsif ($arg eq 'runner_args'){%runner_args=(%runner_args,%$val)}else {croak "Unrecognized arg: $arg"}}else {push@import=>$arg}}if ($HANDLED{$caller[0]}++){croak "Package $caller[0] has already been initialized" if keys(%root_args)|| keys(%runner_args)}else {my$root=init_root($caller[0],frame=>\@caller,code=>sub {1},%root_args,);my$runner=Test2::Workflow::Runner->new(%runner_args);Test2::Tools::Mock->add_handler($caller[0],sub {my%params=@_;my ($class,$caller,$builder,$args)=@params{qw/class caller builder args/};my$do_it=eval "package $caller->[0];\n#line $caller->[2] \"$caller->[1]\"\nsub { \$runner\->add_mock(\$builder->()) }";if (@{$runner->stack}){$do_it->()}else {my$action=Test2::Workflow::Task::Action->new(code=>$do_it,name=>"mock $class",frame=>$caller,scaffold=>1,);my$build=current_build()|| $root;$build->add_primary_setup($action);$build->add_stash($builder->())unless$build->is_root}return 1});test2_add_callback_testing_done(sub {return unless$root->populated;my$g=$root->compile;$runner->push_task($g);$runner->run})}Importer->import_into($class,$caller[0],@import)}{no warnings 'once';*cases=\&describe;*include_workflows=\&include_workflow}sub describe {my@caller=caller(0);my$want=wantarray;my$build=build(args=>\@_,caller=>\@caller,stack_stop=>defined$want ? 1 : 0);return$build if defined$want;my$current=current_build()|| root_build($caller[0])or croak "No current workflow build!";$current->add_primary($build)}sub include_workflow {my@caller=caller(0);my$build=current_build()|| root_build(\$caller[0])or croak "No current workflow build!";for my$task (@_){croak "include_workflow only accepts Test2::Workflow::Task objects, got: $task" unless$task->isa('Test2::Workflow::Task');$build->add_primary($task)}}sub defaults {my%params=@_;my ($package,$tool)=@params{qw/package tool/};my@stack=(root_build($package),build_stack());return unless@stack;my%out;for my$build (@stack){%out=()if$build->stack_stop;my$new=$build->defaults->{$tool}or next;%out=(%out,%$new)}return \%out}BEGIN {@EXPORT=qw{tests it case before_all around_all after_all before_case around_case after_case before_each around_each after_each};@EXPORT_OK=qw{mini iso miso async masync};my%stages=(case=>['add_variant'],tests=>['add_primary'],it=>['add_primary'],iso=>['add_primary'],miso=>['add_primary'],async=>['add_primary'],masync=>['add_primary'],mini=>['add_primary'],before_all=>['add_setup'],after_all=>['add_teardown'],around_all=>['add_setup','add_teardown'],before_case=>['add_variant_setup'],after_case=>['add_variant_teardown'],around_case=>['add_variant_setup','add_variant_teardown'],before_each=>['add_primary_setup'],after_each=>['add_primary_teardown'],around_each=>['add_primary_setup','add_primary_teardown'],);my%props=(case=>[],tests=>[],it=>[],iso=>[iso=>1],miso=>[iso=>1,flat=>1],async=>[async=>1],masync=>[async=>1,flat=>1],mini=>[flat=>1],before_all=>[scaffold=>1],after_all=>[scaffold=>1],around_all=>[scaffold=>1,around=>1],before_case=>[scaffold=>1],after_case=>[scaffold=>1],around_case=>[scaffold=>1,around=>1],before_each=>[scaffold=>1],after_each=>[scaffold=>1],around_each=>[scaffold=>1,around=>1],);sub spec_defaults {my ($tool,%params)=@_;my@caller=caller(0);croak "'$tool' is not a spec tool" unless exists$props{$tool}|| exists$stages{$tool};my$build=current_build()|| root_build($caller[0])or croak "No current workflow build!";my$old=$build->defaults->{$tool}||= {};$build->defaults->{$tool}={%$old,%params }}my$run="";for my$func (@EXPORT,@EXPORT_OK){$run .= <<"        EOT"}my ($ok,$err);{local $@;$ok=eval "$run\n1";$err=$@}die $@ unless$ok}1;
  #line ${ \(__LINE__ + 1) } "${ \__FILE__ }"
  sub $func {
      my \@caller = caller(0);
      my \$args = parse_args(args => \\\@_, caller => \\\@caller);
      my \$action = Test2::Workflow::Task::Action->new(\@{\$props{$func}}, %\$args);
  
      return \$action if defined wantarray;
  
      my \$build = current_build() || root_build(\$caller[0])
          or croak "No current workflow build!";
  
      if (my \$defaults = defaults(package => \$caller[0], tool => '$func')) {
          for my \$attr (keys \%\$defaults) {
              next if defined \$action->\$attr;
              my \$sub = "set_\$attr";
              \$action->\$sub(\$defaults->{\$attr});
          }
      }
  
      \$build->\$_(\$action) for \@{\$stages{$func}};
  }
          EOT
TEST2_TOOLS_SPEC

$fatpacked{"Test2/Tools/Subtest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_SUBTEST';
  package Test2::Tools::Subtest;use strict;use warnings;our$VERSION='0.000144';use Test2::API qw/context run_subtest/;use Test2::Util qw/try/;our@EXPORT=qw/subtest_streamed subtest_buffered/;use base 'Exporter';sub subtest_streamed {my$name=shift;my$params=ref($_[0])eq 'HASH' ? shift(@_): {};my$code=shift;$params->{buffered}=0 unless defined$params->{buffered};my$ctx=context();my$pass=run_subtest("Subtest: $name",$code,$params,@_);$ctx->release;return$pass}sub subtest_buffered {my$name=shift;my$params=ref($_[0])eq 'HASH' ? shift(@_): {};my$code=shift;$params->{buffered}=1 unless defined$params->{buffered};my$ctx=context();my$pass=run_subtest($name,$code,$params,@_);$ctx->release;return$pass}1;
TEST2_TOOLS_SUBTEST

$fatpacked{"Test2/Tools/Target.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_TARGET';
  package Test2::Tools::Target;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use Test2::Util qw/pkg_to_file/;sub import {my$class=shift;my$caller=caller;$class->import_into($caller,@_)}sub import_into {my$class=shift;my$into=shift or croak "no destination package provided";croak "No targets specified" unless @_;my%targets;if (@_==1){if (ref $_[0]eq 'HASH'){%targets=%{$_[0]}}else {($targets{CLASS})=@_}}else {%targets=@_}for my$name (keys%targets){my$target=$targets{$name};my$file=pkg_to_file($target);require$file;$name ||= 'CLASS';my$const;{my$const_target="$target";$const=sub() {$const_target}}no strict 'refs';*{"$into\::$name"}=\$target;*{"$into\::$name"}=$const}}1;
TEST2_TOOLS_TARGET

$fatpacked{"Test2/Tools/Tester.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_TESTER';
  package Test2::Tools::Tester;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use Module::Pluggable search_path=>['Test2::EventFacet'],require=>1;use Test2::Util::Ref qw/rtype/;use Importer Importer=>'import';our@EXPORT_OK=qw{facets filter_events event_groups};my%TYPES;for my$class (__PACKAGE__->plugins){my$type=$class;$type =~ s/^Test2::EventFacet:://g;next unless$class->isa('Test2::EventFacet');my$key;$key=$class->facet_key if$class->can('facet_key');$key=lc($type)unless defined$key;$TYPES{$type}=$class;$TYPES{lc($type)}=$class;$TYPES{$key}=$class}sub filter_events {my$events=shift;my@match=map {rtype($_)eq 'REGEXP' ? $_ : qr/^\Q$_\E::/}@_;my@out;for my$e (@$events){my$trace=$e->facet_data->{trace}or next;next unless grep {$trace->{frame}->[3]=~ $_}@match;push@out=>$e}return \@out}sub event_groups {my$events=shift;my$out={};for my$e (@$events){my$trace=$e->facet_data->{trace};my$tool=($trace && $trace->{frame}&& $trace->{frame}->[3])? $trace->{frame}->[3]: undef;unless ($tool){push @{$out->{__NA__}}=>$e;next}my ($pkg,$sub)=($tool =~ m/^(.*)(?:::|')([^:']+)$/);push @{$out->{$pkg}->{$sub}}=>$e;push @{$out->{$pkg}->{__ALL__}}=>$e}return$out}sub facets {my ($type,$events)=@_;my ($key,$is_list);my$class=$TYPES{$type};if ($class){$key=$class->facet_key || lc($type);$is_list=$class->is_list}else {$key=lc($type)}my@out;for my$e (@$events){my$fd=$e->facet_data;my$f=$fd->{$key}or next;my$list=defined($is_list)? $is_list : rtype($f)eq 'ARRAY';if ($list){push@out=>map {$class ? $class->new($_): $_}@$f}else {push@out=>$class ? $class->new($f): $f}}return \@out}1;
TEST2_TOOLS_TESTER

$fatpacked{"Test2/Tools/Warnings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_TOOLS_WARNINGS';
  package Test2::Tools::Warnings;use strict;use warnings;our$VERSION='0.000144';use Test2::API qw/context/;our@EXPORT=qw/warns warning warnings no_warnings/;use base 'Exporter';sub warns(&) {my$code=shift;my$warnings=0;local$SIG{__WARN__}=sub {$warnings++};$code->();return$warnings}sub no_warnings(&) {return!&warns(@_)}sub warning(&) {my$code=shift;my@warnings;{local$SIG{__WARN__}=sub {push@warnings=>@_};$code->();return unless@warnings}if (@warnings > 1){my$ctx=context();$ctx->alert("Extra warnings in warning { ... }");$ctx->note($_)for@warnings;$ctx->release}return$warnings[0]}sub warnings(&) {my$code=shift;my@warnings;local$SIG{__WARN__}=sub {push@warnings=>@_};$code->();return \@warnings}1;
TEST2_TOOLS_WARNINGS

$fatpacked{"Test2/Util/Grabber.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_GRABBER';
  package Test2::Util::Grabber;use strict;use warnings;our$VERSION='0.000144';use Test2::Hub::Interceptor();use Test2::EventFacet::Trace();use Test2::API qw/test2_stack test2_ipc/;use Test2::Util::HashBase qw/hub finished _events term_size <state <trace/;sub init {my$self=shift;test2_stack->top();my$hub=test2_stack->new_hub(class=>'Test2::Hub::Interceptor',formatter=>undef,no_ending=>1,);$self->{+HUB}=$hub;my@events;$hub->listen(sub {push@events=>$_[1]});$self->{+_EVENTS}=\@events;$self->{+TERM_SIZE}=$ENV{TS_TERM_SIZE};$ENV{TS_TERM_SIZE}=80;my$trace=$self->{+TRACE}||= Test2::EventFacet::Trace->new(frame=>[caller(1)]);my$state=$self->{+STATE}||= {};$hub->clean_inherited(trace=>$trace,state=>$state);return}sub flush {my$self=shift;my$out=[@{$self->{+_EVENTS}}];@{$self->{+_EVENTS}}=();return$out}sub events {my$self=shift;return [@{$self->{+_EVENTS}}]}sub finish {my ($self)=@_;$_[0]=undef;if (defined$self->{+TERM_SIZE}){$ENV{TS_TERM_SIZE}=$self->{+TERM_SIZE}}else {delete$ENV{TS_TERM_SIZE}}my$hub=$self->{+HUB};$self->{+FINISHED}=1;test2_stack()->pop($hub);my$trace=$self->{+TRACE}||= Test2::EventFacet::Trace->new(frame=>[caller(1)]);my$state=$self->{+STATE}||= {};$hub->clean_inherited(trace=>$trace,state=>$state);my$dbg=Test2::EventFacet::Trace->new(frame=>[caller(0)],);$hub->finalize($dbg,1)if!$hub->no_ending &&!$hub->state->ended;return$self->flush}sub DESTROY {my$self=shift;return if$self->{+FINISHED};test2_stack->pop($self->{+HUB})}1;
TEST2_UTIL_GRABBER

$fatpacked{"Test2/Util/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_REF';
  package Test2::Util::Ref;use strict;use warnings;our$VERSION='0.000144';use Scalar::Util qw/reftype blessed refaddr/;our@EXPORT_OK=qw/rtype render_ref/;use base 'Exporter';sub rtype {my ($thing)=@_;return '' unless defined$thing;my$rf=ref$thing;my$rt=reftype$thing;return '' unless$rf || $rt;return 'REGEXP' if$rf =~ m/Regex/i;return 'REGEXP' if$rt =~ m/Regex/i;return$rt || ''}sub render_ref {my ($in)=@_;return 'undef' unless defined($in);my$type=rtype($in);return "$in" unless$type;my$class=blessed($in)|| '';my$it=sprintf('0x%x',refaddr($in));my$ref="$type($it)";return$ref unless$class;return "$class=$ref"}1;
TEST2_UTIL_REF

$fatpacked{"Test2/Util/Stash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_STASH';
  package Test2::Util::Stash;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use B;our@EXPORT_OK=qw{get_stash get_glob get_symbol parse_symbol purge_symbol slot_to_sig sig_to_slot};use base 'Exporter';my%SIGMAP=('&'=>'CODE','$'=>'SCALAR','%'=>'HASH','@'=>'ARRAY',);my%SLOTMAP=reverse%SIGMAP;sub slot_to_sig {$SLOTMAP{$_[0]}|| croak "unsupported slot: '$_[0]'"}sub sig_to_slot {$SIGMAP{$_[0]}|| croak "unsupported sigil: $_[0]"}sub get_stash {my$package=shift || caller;no strict 'refs';return \%{"${package}\::"}}sub get_glob {my$sym=_parse_symbol(scalar(caller),@_);no strict 'refs';no warnings 'once';return \*{"$sym->{package}\::$sym->{name}"}}sub parse_symbol {_parse_symbol(scalar(caller),@_)}sub _parse_symbol {my ($caller,$symbol,$package)=@_;if (ref($symbol)){my$pkg=$symbol->{package};croak "Symbol package ($pkg) and package argument ($package) do not match" if$pkg && $package && $pkg ne $package;$symbol->{package}||= $caller;return$symbol}utf8::downgrade($symbol)if $]==5.010000;my ($sig,$pkg,$name)=($symbol =~ m/^(\W?)(.*::)?([^:]+)$/)or croak "Invalid symbol: '$symbol'";$pkg=$pkg ? $pkg eq '::' ? 'main' : substr($pkg,0,-2): undef;croak "Symbol package ($pkg) and package argument ($package) do not match" if$pkg && $package && $pkg ne $package;$sig ||= '&';my$type=$SIGMAP{$sig}|| croak "unsupported sigil: '$sig'";my$real_package=$package || $pkg || $caller;return {name=>$name,sigil=>$sig,type=>$type,symbol=>"${sig}${real_package}::${name}",package=>$real_package,}}sub get_symbol {my$sym=_parse_symbol(scalar(caller),@_);my$name=$sym->{name};my$type=$sym->{type};my$package=$sym->{package};my$symbol=$sym->{symbol};my$stash=get_stash($package);return undef unless exists$stash->{$name};my$glob=get_glob($sym);return *{$glob}{$type}if$type ne 'SCALAR' && defined(*{$glob}{$type});if ($] < 5.010){return undef unless defined(*{$glob}{$type});{local ($@,$!);local$SIG{__WARN__}=sub {1};return *{$glob}{$type}if eval "package $package; my \$y = $symbol; 1"}return undef unless defined *{$glob}{$type};return *{$glob}{$type}if defined ${*{$glob}{$type}};return undef}my$sv=B::svref_2object($glob)->SV;return *{$glob}{$type}if$sv->isa('B::SV');return undef unless$sv->isa('B::SPECIAL');return *{$glob}{$type}if$B::specialsv_name[$$sv]ne 'Nullsv';return undef}sub purge_symbol {my$sym=_parse_symbol(scalar(caller),@_);local*GLOBCLONE=*{get_glob($sym)};delete get_stash($sym->{package})->{$sym->{name}};my$new_glob=get_glob($sym);for my$type (qw/CODE SCALAR HASH ARRAY FORMAT IO/){next if$type eq $sym->{type};my$ref=get_symbol({type=>$type,name=>'GLOBCLONE',sigil=>$SLOTMAP{$type}},__PACKAGE__);next unless$ref;*$new_glob=$ref}return*GLOBCLONE{$sym->{type}}}1;
TEST2_UTIL_STASH

$fatpacked{"Test2/Util/Sub.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_SUB';
  package Test2::Util::Sub;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak carp/;use B();use Sub::Info;our@EXPORT_OK=qw{sub_info sub_name gen_reader gen_writer gen_accessor};use base 'Exporter';sub gen_reader {my$field=shift;return sub {$_[0]->{$field}}}sub gen_writer {my$field=shift;return sub {$_[0]->{$field}=$_[1]}}sub gen_accessor {my$field=shift;return sub {my$self=shift;($self->{$field})=@_ if @_;return$self->{$field}}}sub sub_name {my ($sub)=@_;croak "sub_name requires a coderef as its only argument" unless ref($sub)eq 'CODE';my$cobj=B::svref_2object($sub);my$name=$cobj->GV->NAME;return$name}sub sub_info {carp "Test2::Util::Sub::sub_info() is deprecated, use Sub::Info::sub_info() instead";Sub::Info::sub_info(@_)}1;
TEST2_UTIL_SUB

$fatpacked{"Test2/Util/Table.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TABLE';
  package Test2::Util::Table;use strict;use warnings;our$VERSION='0.000144';use base 'Term::Table';use Importer Importer=>'import';our@EXPORT_OK=qw/table/;our%EXPORT_GEN=('&term_size'=>sub {require Carp;Carp::cluck "term_size should be imported from Test2::Util::Term, not " .__PACKAGE__;Test2::Util::Term->can('term_size')},);sub table {my%params=@_;$params{collapse}||= 0;$params{sanitize}||= 0;$params{mark_tail}||= 0;$params{show_header}||= 0 unless$params{header}&& @{$params{header}};__PACKAGE__->new(%params)->render}1;
TEST2_UTIL_TABLE

$fatpacked{"Test2/Util/Table/Cell.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TABLE_CELL';
  package Test2::Util::Table::Cell;use strict;use warnings;our$VERSION='0.000144';use base 'Term::Table::Cell';1;
TEST2_UTIL_TABLE_CELL

$fatpacked{"Test2/Util/Table/LineBreak.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TABLE_LINEBREAK';
  package Test2::Util::Table::LineBreak;use strict;use warnings;our$VERSION='0.000144';use base 'Term::Table::LineBreak';1;
TEST2_UTIL_TABLE_LINEBREAK

$fatpacked{"Test2/Util/Term.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TERM';
  package Test2::Util::Term;use strict;use warnings;use Term::Table::Util qw/term_size USE_GCS USE_TERM_READKEY uni_length/;our$VERSION='0.000144';use Importer Importer=>'import';our@EXPORT_OK=qw/term_size USE_GCS USE_TERM_READKEY uni_length/;1;
TEST2_UTIL_TERM

$fatpacked{"Test2/Util/Times.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_UTIL_TIMES';
  package Test2::Util::Times;use strict;use warnings;use List::Util qw/sum/;our$VERSION='0.000144';our@EXPORT_OK=qw/render_bench render_duration/;use base 'Exporter';sub render_duration {my$time;if (@_==1){($time)=@_}else {my ($start,$end)=@_;$time=$end - $start}return sprintf('%1.5fs',$time)if$time < 10;return sprintf('%2.4fs',$time)if$time < 60;my$msec=substr(sprintf('%0.2f',$time - int($time)),-2,2);my$secs=$time % 60;my$mins=int($time / 60)% 60;my$hours=int($time / 60 / 60)% 24;my$days=int($time / 60 / 60 / 24);my@units=(qw/d h m/,'');my$duration='';for my$t ($days,$hours,$mins,$secs){my$u=shift@units;next unless$t || $duration;$duration=join ':'=>grep {length($_)}$duration,sprintf('%02u%s',$t,$u)}$duration ||= '0';$duration .= ".$msec" if int($msec);$duration .= 's';return$duration}sub render_bench {my ($start,$end,$user,$system,$cuser,$csystem)=@_;my$duration=render_duration($start,$end);my$bench=sprintf("%s on wallclock (%5.2f usr %5.2f sys + %5.2f cusr %5.2f csys = %5.2f CPU)",$duration,$user,$system,$cuser,$csystem,sum($user,$system,$cuser,$csystem),);$bench =~ s/\s+/ /g;$bench =~ s/(\(|\))\s+/$1/g;return$bench}1;
TEST2_UTIL_TIMES

$fatpacked{"Test2/V0.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_V0';
  package Test2::V0;use strict;use warnings;use Importer;our$VERSION='0.000144';use Carp qw/croak/;use Test2::Plugin::SRand();use Test2::Plugin::UTF8();use Test2::Tools::Target();use Test2::Plugin::ExitSummary;use Test2::API qw/intercept context/;use Test2::Tools::Event qw/gen_event/;use Test2::Tools::Defer qw/def do_def/;use Test2::Tools::Basic qw{ok pass fail diag note todo skip plan skip_all done_testing bail_out};use Test2::Tools::Compare qw{is like isnt unlike match mismatch validator hash array bag object meta meta_check number float rounded within string subset bool check_isa in_set not_in_set check_set item field call call_list call_hash prop check all_items all_keys all_vals all_values etc end filter_items T F D DF E DNE FDNE U L event fail_events exact_ref};use Test2::Tools::Warnings qw{warns warning warnings no_warnings};use Test2::Tools::ClassicCompare qw/cmp_ok/;use Importer 'Test2::Tools::Subtest'=>(subtest_buffered=>{-as=>'subtest' },);use Test2::Tools::Class qw/can_ok isa_ok DOES_ok/;use Test2::Tools::Encoding qw/set_encoding/;use Test2::Tools::Exports qw/imported_ok not_imported_ok/;use Test2::Tools::Ref qw/ref_ok ref_is ref_is_not/;use Test2::Tools::Mock qw/mock mocked/;use Test2::Tools::Exception qw/try_ok dies lives/;our@EXPORT=qw{ok pass fail diag note todo skip plan skip_all done_testing bail_out intercept context gen_event def do_def cmp_ok warns warning warnings no_warnings subtest can_ok isa_ok DOES_ok set_encoding imported_ok not_imported_ok ref_ok ref_is ref_is_not mock mocked dies lives try_ok is like isnt unlike match mismatch validator hash array bag object meta meta_check number float rounded within string subset bool check_isa in_set not_in_set check_set item field call call_list call_hash prop check all_items all_keys all_vals all_values etc end filter_items T F D DF E DNE FDNE U L event fail_events exact_ref};my$SRAND;sub import {my$class=shift;my$caller=caller;my (@exports,%options);while (my$arg=shift @_){push@exports=>$arg and next unless substr($arg,0,1)eq '-';$options{$arg}=shift @_}my$srand=delete$options{'-srand'};my$no_srand=exists$options{'-no_srand'};delete$options{'-no_srand'}if$no_srand;croak "Cannot combine '-srand' and '-no_srand' options" if$no_srand && defined($srand);if (!$no_srand){Test2::Plugin::SRand->import($srand ? $srand : ())if defined($srand)||!$SRAND++}my$no_pragmas=delete$options{'-no_pragmas'};my$no_strict=delete$options{'-no_strict'}|| $no_pragmas;my$no_warnings=delete$options{'-no_warnings'}|| $no_pragmas;my$no_utf8=delete$options{'-no_utf8'}|| $no_pragmas;strict->import()unless$no_strict;'warnings'->import()unless$no_warnings;Test2::Plugin::UTF8->import()unless$no_utf8;my$target=delete$options{'-target'};Test2::Tools::Target->import_into($caller,$target)if$target;croak "Unknown option(s): " .join(', ',sort keys%options)if keys%options;Importer->import_into($class,$caller,@exports)}1;
TEST2_V0

$fatpacked{"Test2/Workflow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW';
  package Test2::Workflow;use strict;use warnings;our$VERSION='0.000144';our@EXPORT_OK=qw/parse_args current_build build root_build init_root build_stack/;use base 'Exporter';use Test2::Workflow::Build;use Test2::Workflow::Task::Group;use Test2::API qw/intercept/;use Scalar::Util qw/blessed/;sub parse_args {my%input=@_;my$args=delete$input{args};my%out;my%props;my$caller=$out{frame}=$input{caller}|| caller(defined$input{level}? $input{level}: 1);delete@input{qw/caller level/};for my$arg (@$args){if (my$r=ref($arg)){if ($r eq 'HASH'){%props=(%props,%$arg)}elsif ($r eq 'CODE'){die "Code is already set, did you provide multiple code blocks at $caller->[1] line $caller->[2].\n" if$out{code};$out{code}=$arg}else {die "Not sure what to do with $arg at $caller->[1] line $caller->[2].\n"}next}if ($arg =~ m/^\d+$/){push @{$out{lines}}=>$arg;next}die "Name is already set to '$out{name}', cannot set to '$arg', did you specify multiple names at $caller->[1] line $caller->[2].\n" if$out{name};$out{name}=$arg}die "a name must be provided, and must be truthy at $caller->[1] line $caller->[2].\n" unless$out{name};die "a codeblock must be provided at $caller->[1] line $caller->[2].\n" unless$out{code};return {%props,%out,%input }}{my%ROOT_BUILDS;my@BUILD_STACK;sub root_build {$ROOT_BUILDS{$_[0]}}sub current_build {@BUILD_STACK ? $BUILD_STACK[-1]: undef}sub build_stack {@BUILD_STACK}sub init_root {my ($pkg,%args)=@_;$ROOT_BUILDS{$pkg}||= Test2::Workflow::Build->new(name=>$pkg,flat=>1,iso=>0,async=>0,is_root=>1,%args,);return$ROOT_BUILDS{$pkg}}sub build {my%params=@_;my$args=parse_args(%params);my$build=Test2::Workflow::Build->new(%$args);return$build if$args->{skip};push@BUILD_STACK=>$build;my ($ok,$err);my$events=intercept {my$todo=$args->{todo}? Test2::Todo->new(reason=>$args->{todo}): undef;$ok=eval {$args->{code}->();1};$err=$@;$todo->end if$todo};$build->{stash}=[];$build->set_events($events);pop@BUILD_STACK;unless($ok){my$hub=Test2::API::test2_stack->top;my$count=@$events;my$list=$count ? "Overview of unseen events:\n" .join ""=>map "    " .blessed($_)." " .$_->trace($hub)->debug ."\n",@$events : "";die <<"            EOT"}return$build}}1;
  Exception in build '$args->{name}' with $count unseen event(s).
  $err
  $list
              EOT
TEST2_WORKFLOW

$fatpacked{"Test2/Workflow/BlockBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_BLOCKBASE';
  package Test2::Workflow::BlockBase;use strict;use warnings;our$VERSION='0.000144';use Test2::Util::HashBase qw/code frame _info _lines/;use Sub::Info qw/sub_info/;use List::Util qw/min max/;use Carp qw/croak/;use Test2::Util::Trace();BEGIN {local ($@,$!,$SIG{__DIE__});my$set_name=eval {require Sub::Util;Sub::Util->can('set_subname')}|| eval {require Sub::Name;Sub::Name->can('subname')};*set_subname=$set_name ? sub {my$self=shift;my ($name)=@_;$set_name->($name,$self->{+CODE});delete$self->{+_INFO};return 1}: sub {return 0}}sub init {my$self=shift;croak "The 'code' attribute is required" unless$self->{+CODE};croak "The 'frame' attribute is required" unless$self->{+FRAME};$self->{+_LINES}=delete$self->{lines}if$self->{lines}}sub file {shift->info->{file}}sub lines {shift->info->{lines}}sub package {shift->info->{package}}sub subname {shift->info->{name}}sub info {my$self=shift;unless ($self->{+_INFO}){my$info=sub_info($self->code);my$frame=$self->frame;my$file=$info->{file};my$all_lines=$info->{all_lines};my$pre_lines=$self->{+_LINES};my$lines=$info->{lines}||= [];if ($pre_lines && @$pre_lines){@$lines=@$pre_lines}else {@$lines=(min(@$all_lines,$frame->[2]),max(@$all_lines,$frame->[2]),)if$frame->[1]eq $file}$lines->[0]-- if$lines->[0]!=$lines->[1];$self->{+_INFO}=$info}return$self->{+_INFO}}sub trace {my$self=shift;my ($hub,%params)=@_;croak "'hub' is required" unless$hub;return Test2::Util::Trace->new(frame=>$self->frame,detail=>$self->debug,buffered=>$hub->buffered,nested=>$hub->nested,hid=>$hub->hid,huuid=>$hub->uuid,%params,)}sub debug {my$self=shift;my$file=$self->file;my$lines=$self->lines;my$line_str=@$lines==1 ? "around line $lines->[0]" : "around lines $lines->[0] -> $lines->[1]";return "at $file $line_str."}sub throw {my$self=shift;my ($msg)=@_;die "$msg " .$self->debug ."\n"}1;
TEST2_WORKFLOW_BLOCKBASE

$fatpacked{"Test2/Workflow/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_BUILD';
  package Test2::Workflow::Build;use strict;use warnings;our$VERSION='0.000144';use Test2::Workflow::Task::Group;our@BUILD_FIELDS;BEGIN {@BUILD_FIELDS=qw{primary variant setup teardown variant_setup variant_teardown primary_setup primary_teardown stash}}use base 'Test2::Workflow::Task';use Test2::Util::HashBase@BUILD_FIELDS,qw/events defaults stack_stop/;sub init {my$self=shift;{local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->SUPER::init()}$self->{$_}||= []for@BUILD_FIELDS;$self->{+DEFAULTS}||= {}}for my$field (@BUILD_FIELDS){my$code=sub {my$self=shift;push @{$self->{$field}}=>@_};no strict 'refs';*{"add_$field"}=$code}sub populated {my$self=shift;for my$field (@BUILD_FIELDS){return 1 if @{$self->{$field}}}return 0}sub compile {my$self=shift;warn "Workflow build '$self->{+NAME}' is empty " .$self->debug ."\n" unless$self->populated || $self->{+SKIP};my ($primary_setup,$primary_teardown)=@_;$primary_setup ||= [];$primary_teardown ||= [];my$variant=$self->{+VARIANT};my$setup=$self->{+SETUP};my$teardown=$self->{+TEARDOWN};my$variant_setup=$self->{+VARIANT_SETUP};my$variant_teardown=$self->{+VARIANT_TEARDOWN};$primary_setup=[@$primary_setup,@{$self->{+PRIMARY_SETUP}}];$primary_teardown=[@{$self->{+PRIMARY_TEARDOWN}},@$primary_teardown];my$primary=[map {$_->isa(__PACKAGE__)? $_->compile($primary_setup,$primary_teardown): $_}@{$self->{+PRIMARY}},];if (@$primary_setup || @$primary_teardown){$primary=[map {my$p=$_->clone;$_->isa('Test2::Workflow::Task::Action')? Test2::Workflow::Task::Group->new(before=>$primary_setup,primary=>[$p ],take=>$p,after=>$primary_teardown,): $_}@$primary ]}if (@$variant){$primary=[map {my$v=$_->clone;Test2::Workflow::Task::Group->new(before=>$variant_setup,primary=>$primary,after=>$variant_teardown,variant=>$v,take=>$v,)}@$variant ]}my%params=map {Test2::Workflow::Task::Group->can($_)? ($_=>$self->{$_}): ()}keys %$self;delete$params{$_}for@BUILD_FIELDS;return Test2::Workflow::Task::Group->new(%params,before=>$setup,after=>$teardown,primary=>$primary,)}1;
TEST2_WORKFLOW_BUILD

$fatpacked{"Test2/Workflow/Runner.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_RUNNER';
  package Test2::Workflow::Runner;use strict;use warnings;our$VERSION='0.000144';use Test2::API();use Test2::Todo();use Test2::AsyncSubtest();use Test2::Util qw/get_tid CAN_REALLY_FORK/;use Scalar::Util qw/blessed/;use Time::HiRes qw/sleep/;use List::Util qw/shuffle min/;use Carp qw/confess/;use Test2::Util::HashBase qw{stack no_fork no_threads max slots pid tid rand subtests filter};use overload('fallback'=>1,'&{}'=>sub {my$self=shift;sub {@_=($self);goto&run}},);sub init {my$self=shift;$self->{+STACK}=[];$self->{+SUBTESTS}=[];$self->{+PID}=$$;$self->{+TID}=get_tid();$self->{+NO_FORK}||= $ENV{T2_WORKFLOW_NO_FORK}||!CAN_REALLY_FORK();my$can_thread=Test2::AsyncSubtest->CAN_REALLY_THREAD();my$should_thread=($ENV{T2_WORKFLOW_USE_THREADS}|| $ENV{T2_DO_THREAD_TESTS})&&!$ENV{T2_WORKFLOW_NO_THREADS};$self->{+NO_THREADS}||=!($can_thread && $should_thread);$self->{+RAND}=1 unless defined$self->{+RAND};my@max=grep {defined $_}$self->{+MAX},$ENV{T2_WORKFLOW_ASYNC};my$max=@max ? min(@max): 3;$self->{+MAX}=$max;$self->{+SLOTS}=[]if$max;unless(defined($self->{+FILTER})){if (my$raw=$ENV{T2_WORKFLOW}){my ($file,$line,$name);if ($raw =~ m/^(.*)\s+(\d+)$/){($file,$line)=($1,$2)}elsif($raw =~ m/^(\d+)$/){$line=$1}else {$name=$raw}$self->{+FILTER}={file=>$file,line=>$line,name=>$name,}}}if (my$task=delete$self->{task}){$self->push_task($task)}}sub is_local {my$self=shift;return 0 unless$self->{+PID}==$$;return 0 unless$self->{+TID}==get_tid();return 1}sub send_event {my$self=shift;my ($type,%params)=@_;my$class;if ($type =~ m/\+(.*)$/){$class=$1}else {$class="Test2::Event::$type"}my$hub=Test2::API::test2_stack()->top();my$e=$class->new(trace=>Test2::Util::Trace->new(frame=>[caller(0)],buffered=>$hub->buffered,nested=>$hub->nested,hid=>$hub->hid,huuid=>$hub->uuid,),%params,);$hub->send($e)}sub current_subtest {my$self=shift;my$stack=$self->{+STACK}or return undef;for my$state (reverse @$stack){next unless$state->{subtest};return$state->{subtest}}return undef}sub run {my$self=shift;my$stack=$self->stack;my$c=0;while (@$stack){$self->cull;my$state=$stack->[-1];my$task=$state->{task};unless($state->{started}++){my$skip=$task->skip;my$filter;if (my$f=$self->{+FILTER}){my$in_var=grep {$_->{filter_satisfied}}@$stack;$filter=$task->filter($f)unless$in_var;$state->{filter_satisfied}=1 if$filter->{satisfied}}$skip ||= $filter->{skip}if$filter;if ($skip){$state->{ended}++;$self->send_event('Skip',reason=>$skip || $filter,name=>$task->name,pass=>1,effective_pass=>1,);pop @$stack;next}if ($task->flat){my$st=$self->current_subtest;my$hub=$st ? $st->hub : Test2::API::test2_stack->top;$state->{todo}=Test2::Todo->new(reason=>$task->todo,hub=>$hub)if$task->todo;$hub->send($_)for @{$task->events}}else {my$st=Test2::AsyncSubtest->new(name=>$task->name,frame=>$task->frame,);$state->{subtest}=$st;$state->{todo}=Test2::Todo->new(reason=>$task->todo,hub=>$st->hub)if$task->todo;for my$e (@{$task->events}){my$hub=$st->hub;$e->trace->{buffered}=$hub->buffered;$e->trace->{nested}=$hub->nested;$e->trace->{hid}=$hub->hid;$e->trace->{huuid}=$hub->uuid;$hub->send($e)}my$slot=$self->isolate($state);if (defined($slot)){push @{$self->{+SUBTESTS}}=>[$st,$task]unless$st->finished;$state->{subtest}=undef;$state->{ended}=1}}}if ($state->{ended}){$state->{todo}->end()if$state->{todo};$state->{subtest}->stop()if$state->{subtest};return if$state->{in_thread};if(my$guard=delete$state->{in_fork}){$state->{subtest}->detach;$guard->dismiss;exit 0}pop @$stack;next}if($state->{subtest}&&!$state->{subtest_started}++){push @{$self->{+SUBTESTS}}=>[$state->{subtest},$task];$state->{subtest}->start()}if ($task->isa('Test2::Workflow::Task::Action')){$state->{PID}=$$;my$ok=eval {$task->code->($self);1};unless ($state->{PID}==$$){print STDERR "Task '" .$task->name ."' started in pid $state->{PID}, but ended in pid $$, did you forget to exit after forking?\n";exit 255}$task->exception($@)unless$ok;$state->{ended}=1;next}if (!$state->{stage}|| $state->{stage}eq 'BEFORE'){$state->{before}=(defined$state->{before})? $state->{before}: 0;if (my$add=$task->before->[$state->{before}++]){if ($add->around){$state->{PID}=$$;my$ok=eval {$add->code->($self);1};my$err=$@;my$complete=$state->{stage}&& $state->{stage}eq 'AFTER';unless ($state->{PID}==$$){print STDERR "Task '" .$task->name ."' started in pid $state->{PID}, but ended in pid $$, did you forget to exit after forking?\n";exit 255}unless($ok && $complete){$state->{ended}=1;$state->{stage}='AFTER';$task->exception($ok ? "'around' task failed to continue into the workflow chain.\n" : $err)}}else {$self->push_task($add)}}else {$state->{stage}='VARIANT'}}elsif ($state->{stage}eq 'VARIANT'){if (my$v=$task->variant){$self->push_task($v)}$state->{stage}='PRIMARY'}elsif ($state->{stage}eq 'PRIMARY'){unless (defined$state->{order}){my$rand=defined($task->rand)? $task->rand : $self->rand;$state->{order}=[0 .. scalar(@{$task->primary})- 1];@{$state->{order}}=shuffle(@{$state->{order}})if$rand}my$num=shift @{$state->{order}};if (defined$num){$self->push_task($task->primary->[$num])}else {$state->{stage}='AFTER'}}elsif ($state->{stage}eq 'AFTER'){$state->{after}=(defined$state->{after})? $state->{after}: 0;if (my$add=$task->after->[$state->{after}++]){return if$add->around;$self->push_task($add)}else {$state->{ended}=1}}}$self->finish}sub push_task {my$self=shift;my ($task)=@_;confess "No Task!" unless$task;confess "Bad Task ($task)!" unless blessed($task)&& $task->isa('Test2::Workflow::Task');if ($task->isa('Test2::Workflow::Build')){confess "Can only push a Build instance when initializing the stack" if @{$self->{+STACK}};$task=$task->compile()}push @{$self->{+STACK}}=>{task=>$task,name=>$task->name,}}sub add_mock {my$self=shift;my ($mock)=@_;my$stack=$self->{+STACK};confess "Nothing on the stack!" unless$stack && @$stack;my ($state)=grep {!$_->{task}->scaffold}reverse @$stack;push @{$state->{mocks}}=>$mock}sub isolate {my$self=shift;my ($state)=@_;return if$state->{task}->skip;my$iso=$state->{task}->iso;my$async=$state->{task}->async;return undef unless$iso || $async;unless($self->{+MAX}&& $self->is_local){return undef unless$iso}my$slot=0;while($self->{+MAX}&& $self->is_local){$self->cull;for my$s (1 .. $self->{+MAX}){my$st=$self->{+SLOTS}->[$s];next if$st &&!$st->finished;$self->{+SLOTS}->[$s]=undef;$slot=$s;last}last if$slot;sleep(0.02)}my$st=$state->{subtest}or confess "Cannot isolate a task without a subtest";if (!$self->no_fork){my$out=$st->fork;if (blessed($out)){$state->{in_fork}=$out;return undef}else {$self->send_event('Note',message=>"Forked PID $out to run: " .$state->{task}->name,);$state->{pid}=$out}}elsif (!$self->no_threads){$state->{in_thread}=1;my$thr=$st->run_thread(\&run,$self);$state->{thread}=$thr;delete$state->{in_thread};$self->send_event('Note',message=>"Started Thread-ID " .$thr->tid ." to run: " .$state->{task}->name,)}else {$st->finish(skip=>"No isolation method available");return 0}if($slot){$self->{+SLOTS}->[$slot]=$st}else {$st->finish}return$slot}sub cull {my$self=shift;my$subtests=delete$self->{+SUBTESTS}|| return;my@new;for my$set (reverse @$subtests){my ($st,$task)=@$set;next if$st->finished;if (!$st->active && $st->ready){$st->finish();next}unshift@new=>$set}$self->{+SUBTESTS}=\@new;return}sub finish {my$self=shift;while(@{$self->{+SUBTESTS}}){$self->cull;sleep(0.02)if @{$self->{+SUBTESTS}}}}1;
TEST2_WORKFLOW_RUNNER

$fatpacked{"Test2/Workflow/Task.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_TASK';
  package Test2::Workflow::Task;use strict;use warnings;our$VERSION='0.000144';use Test2::API();use Test2::Event::Exception();use List::Util qw/min max/;use Scalar::Util qw/blessed/;use Carp qw/croak/;our@CARP_NOT=qw/Test2::Util::HashBase/;use base 'Test2::Workflow::BlockBase';use Test2::Util::HashBase qw/name flat async iso todo skip scaffold events is_root/;for my$attr (FLAT,ISO,ASYNC,TODO,SKIP,SCAFFOLD){my$old=__PACKAGE__->can("set_$attr");my$new=sub {my$self=shift;my$out=$self->$old(@_);$self->verify_scaffold;return$out};no strict 'refs';no warnings 'redefine';*{"set_$attr"}=$new}sub init {my$self=shift;$self->{+EVENTS}||= [];{local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->SUPER::init()}$self->throw("the 'name' attribute is required")unless$self->{+NAME};$self->throw("the 'flat' attribute cannot be combined with 'iso' or 'async'")if$self->{+FLAT}&& ($self->{+ISO}|| $self->{+ASYNC});$self->set_subname($self->package ."::<$self->{+NAME}>");$self->verify_scaffold}sub clone {my$self=shift;return bless {%$self},blessed($self)}sub verify_scaffold {my$self=shift;return unless$self->{+SCAFFOLD};croak "The 'flat' attribute must be true for scaffolding" if defined($self->{+FLAT})&&!$self->{+FLAT};$self->{+FLAT}=1;for my$attr (ISO,ASYNC,TODO,SKIP){croak "The '$attr' attribute cannot be used on scaffolding" if$self->{$attr}}}sub exception {my$self=shift;my ($err)=@_;my$hub=Test2::API::test2_stack->top;my$trace=$self->trace($hub);$hub->send(Test2::Event::Exception->new(trace=>$trace,error=>$err,),)}sub filter {my$self=shift;my ($filter)=@_;return unless$filter;return if$self->{+IS_ROOT};return if$self->{+SCAFFOLD};if (my$name=$filter->{name}){my$ok=0;unless(ref($name)){$ok ||= $self->{+NAME}eq $name;$ok ||= $self->subname eq $name}if (ref($name)eq 'Regexp'){$ok ||= $self->{+NAME}=~ $name;$ok ||= $self->subname =~ $name}elsif ($name =~ m{^/}){my$pattern=eval "qr$name" or die "'$name' does not appear to be a valid pattern";$ok ||= $self->{+NAME}=~ $pattern;$ok ||= $self->subname =~ $pattern}return {skip=>"Does not match name filter '$name'"}unless$ok}if (my$file=$filter->{file}){return {skip=>"Does not match file filter '$file'"}unless$self->file eq $file}if (my$line=$filter->{line}){my$lines=$self->lines;return {skip=>"Does not match line filter '$line' (no lines)"}unless$lines && @$lines;my$min=min(@$lines);my$max=max(@$lines);return {skip=>"Does not match line filter '$min <= $line <= $max'"}unless$min <= $line && $max >= $line}return}1;
TEST2_WORKFLOW_TASK

$fatpacked{"Test2/Workflow/Task/Action.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_TASK_ACTION';
  package Test2::Workflow::Task::Action;use strict;use warnings;our$VERSION='0.000144';use base 'Test2::Workflow::Task';use Test2::Util::HashBase qw/around/;1;
TEST2_WORKFLOW_TASK_ACTION

$fatpacked{"Test2/Workflow/Task/Group.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST2_WORKFLOW_TASK_GROUP';
  package Test2::Workflow::Task::Group;use strict;use warnings;our$VERSION='0.000144';use Carp qw/croak/;use Test2::Workflow::Task::Action;use base 'Test2::Workflow::Task';use Test2::Util::HashBase qw/before after primary rand variant/;sub init {my$self=shift;if (my$take=delete$self->{take}){$self->{$_}=delete$take->{$_}for ISO,ASYNC,TODO,SKIP;$self->{$_}=$take->{$_}for FLAT,SCAFFOLD,NAME,CODE,FRAME;$take->{+FLAT}=1;$take->{+SCAFFOLD}=1}{local$Carp::CarpLevel=$Carp::CarpLevel + 1;$self->SUPER::init()}$self->{+BEFORE}||= [];$self->{+AFTER}||= [];$self->{+PRIMARY}||= []}sub filter {my$self=shift;my ($filter)=@_;return if$self->{+IS_ROOT};my$result=$self->SUPER::filter($filter);my$child_ok=0;for my$c (@{$self->{+PRIMARY}}){next if$c->{+SCAFFOLD};my$res=$c->filter($filter);$child_ok++ if!$res || $res->{satisfied};last if$child_ok}unless($result){return {satisfied=>1}if$self->{+VARIANT}||!$child_ok;return}return if$child_ok;return$result}1;
TEST2_WORKFLOW_TASK_GROUP

$fatpacked{"Tie/Handle/Offset.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_OFFSET';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::Offset;our$VERSION='0.004';use Tie::Handle;our@ISA=qw/Tie::Handle/;sub offset {my$self=shift;if (@_){return ${*$self}{offset}=shift}else {return ${*$self}{offset}}}sub TIEHANDLE {my$class=shift;my$params;$params=pop if ref $_[-1]eq 'HASH';my$self=\do {no warnings 'once';local*HANDLE};bless$self,$class;$self->OPEN(@_)if (@_);if ($params->{offset}){seek($self,$self->offset($params->{offset}),0)}return$self}sub TELL {my$cur=tell($_[0])- $_[0]->offset;return$cur > 0 ? $cur : 0}sub SEEK {my ($self,$pos,$whence)=@_;my$rc;if ($whence==0 || $whence==1){$rc=seek($self,$pos + $self->offset,$whence)}elsif (_size($self)+ $pos < $self->offset){$rc=''}else {$rc=seek($self,$pos,$whence)}return$rc}sub OPEN {$_[0]->offset(0);$_[0]->CLOSE if defined($_[0]->FILENO);@_==2 ? open($_[0],$_[1]): open($_[0],$_[1],$_[2])}sub _size {my ($self)=@_;my$cur=tell($self);seek($self,0,2);my$size=tell($self);seek($self,$cur,0);return$size}sub EOF {eof($_[0])}sub FILENO {fileno($_[0])}sub CLOSE {close($_[0])}sub BINMODE {binmode($_[0])}sub READ {read($_[0],$_[1],$_[2])}sub READLINE {my$fh=$_[0];<$fh>}sub GETC {getc($_[0])}sub WRITE {my$fh=$_[0];print$fh substr($_[1],0,$_[2])}1;
TIE_HANDLE_OFFSET

$fatpacked{"Tie/Handle/SkipHeader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TIE_HANDLE_SKIPHEADER';
  use strict;BEGIN{if (not $] < 5.006){require warnings;warnings->import}}package Tie::Handle::SkipHeader;our$VERSION='0.004';use Tie::Handle::Offset;our@ISA=qw/Tie::Handle::Offset/;sub TIEHANDLE {my$class=shift;pop if ref $_[-1]eq 'HASH';return$class->SUPER::TIEHANDLE(@_)}sub OPEN {my$self=shift;my$rc=$self->SUPER::OPEN(@_);while (my$line=<$self>){last if$line =~ /\A\s*\Z/}$self->offset(tell($self));return$rc}1;
TIE_HANDLE_SKIPHEADER

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.31';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map Try::Tiny::ScopeGuard->_new($_),@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"URI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI';
  package URI;use strict;use warnings;our$VERSION='5.10';our ($ABS_REMOTE_LEADING_DOTS,$ABS_ALLOW_RELATIVE_SCHEME,$DEFAULT_QUERY_FORM_DELIMITER);my%implements;our$reserved=q(;/?:@&=+$,[]);our$mark=q(-_.!~*'());our$unreserved="A-Za-z0-9\Q$mark\E";our$uric=quotemeta($reserved).$unreserved ."%";our$scheme_re='[a-zA-Z][a-zA-Z0-9.+\-]*';use Carp ();use URI::Escape ();use overload ('""'=>sub {${$_[0]}},'=='=>sub {_obj_eq(@_)},'!='=>sub {!_obj_eq(@_)},fallback=>1,);sub _obj_eq {return overload::StrVal($_[0])eq overload::StrVal($_[1])}sub new {my($class,$uri,$scheme)=@_;$uri=defined ($uri)? "$uri" : "";$uri =~ s/^<(?:URL:)?(.*)>$/$1/;$uri =~ s/^"(.*)"$/$1/;$uri =~ s/^\s+//;$uri =~ s/\s+$//;my$impclass;if ($uri =~ m/^($scheme_re):/so){$scheme=$1}else {if (($impclass=ref($scheme))){$scheme=$scheme->scheme}elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o){$scheme=$1}}$impclass ||= implementor($scheme)|| do {require URI::_foreign;$impclass='URI::_foreign'};return$impclass->_init($uri,$scheme)}sub new_abs {my($class,$uri,$base)=@_;$uri=$class->new($uri,$base);$uri->abs($base)}sub _init {my$class=shift;my($str,$scheme)=@_;$str=$class->_uric_escape($str);$str="$scheme:$str" unless$str =~ /^$scheme_re:/o || $class->_no_scheme_ok;my$self=bless \$str,$class;$self}sub _uric_escape {my($class,$str)=@_;$str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;utf8::downgrade($str);return$str}my%require_attempted;sub implementor {my($scheme,$impclass)=@_;if (!$scheme || $scheme !~ /\A$scheme_re\z/o){require URI::_generic;return "URI::_generic"}$scheme=lc($scheme);if ($impclass){my$old=$implements{$scheme};$impclass->_init_implementor($scheme);$implements{$scheme}=$impclass;return$old}my$ic=$implements{$scheme};return$ic if$ic;$ic="URI::$scheme";$ic =~ s/\+/_P/g;$ic =~ s/\./_O/g;$ic =~ s/\-/_/g;no strict 'refs';unless (@{"${ic}::ISA"}){if (not exists$require_attempted{$ic}){my$_old_error=$@;eval "require $ic";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}return undef unless @{"${ic}::ISA"}}$ic->_init_implementor($scheme);$implements{$scheme}=$ic;$ic}sub _init_implementor {my($class,$scheme)=@_}sub clone {my$self=shift;my$other=$$self;bless \$other,ref$self}sub TO_JSON {${$_[0]}}sub _no_scheme_ok {0}sub _scheme {my$self=shift;unless (@_){return undef unless $$self =~ /^($scheme_re):/o;return $1}my$old;my$new=shift;if (defined($new)&& length($new)){Carp::croak("Bad scheme '$new'")unless$new =~ /^$scheme_re$/o;$old=$1 if $$self =~ s/^($scheme_re)://o;my$newself=URI->new("$new:$$self");$$self=$$newself;bless$self,ref($newself)}else {if ($self->_no_scheme_ok){$old=$1 if $$self =~ s/^($scheme_re)://o;Carp::carp("Oops, opaque part now look like scheme")if $^W && $$self =~ m/^$scheme_re:/o}else {$old=$1 if $$self =~ m/^($scheme_re):/o}}return$old}sub scheme {my$scheme=shift->_scheme(@_);return undef unless defined$scheme;lc($scheme)}sub has_recognized_scheme {my$self=shift;return ref($self)!~ /^URI::_(?:foreign|generic)\z/}sub opaque {my$self=shift;unless (@_){$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;return $1}$$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;my$old_scheme=$1;my$old_opaque=$2;my$old_frag=$3;my$new_opaque=shift;$new_opaque="" unless defined$new_opaque;$new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_opaque);$$self=defined($old_scheme)? $old_scheme : "";$$self .= $new_opaque;$$self .= $old_frag if defined$old_frag;$old_opaque}sub path {goto&opaque}sub fragment {my$self=shift;unless (@_){return undef unless $$self =~ /\#(.*)/s;return $1}my$old;$old=$1 if $$self =~ s/\#(.*)//s;my$new_frag=shift;if (defined$new_frag){$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;utf8::downgrade($new_frag);$$self .= "#$new_frag"}$old}sub as_string {my$self=shift;$$self}sub as_iri {my$self=shift;my$str=$$self;if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg){require Encode;my$enc=Encode::find_encoding("UTF-8");my$u="";while (length$str){$u .= $enc->decode($str,Encode::FB_QUIET());if (length$str){$u .= URI::Escape::escape_char(substr($str,0,1,""))}}$str=$u}return$str}sub canonical {my$self=shift;my$scheme=$self->_scheme || "";my$uc_scheme=$scheme =~ /[A-Z]/;my$esc=$$self =~ /%[a-fA-F0-9]{2}/;return$self unless$uc_scheme || $esc;my$other=$self->clone;if ($uc_scheme){$other->_scheme(lc$scheme)}if ($esc){$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge}return$other}sub eq {my($self,$other)=@_;$self=URI->new($self,$other)unless ref$self;$other=URI->new($other,$self)unless ref$other;ref($self)eq ref($other)&& $self->canonical->as_string eq $other->canonical->as_string}sub abs {$_[0]}sub rel {$_[0]}sub secure {0}sub STORABLE_freeze {my($self,$cloning)=@_;return $$self}sub STORABLE_thaw {my($self,$cloning,$str)=@_;$$self=$str}1;
URI

$fatpacked{"URI/Escape.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_ESCAPE';
  package URI::Escape;use strict;use warnings;use Exporter 5.57 'import';our%escapes;our@EXPORT=qw(uri_escape uri_unescape uri_escape_utf8);our@EXPORT_OK=qw(%escapes);our$VERSION='5.10';use Carp ();for (0..255){$escapes{chr($_)}=sprintf("%%%02X",$_)}my%subst;my%Unsafe=(RFC2732=>qr/[^A-Za-z0-9\-_.!~*'()]/,RFC3986=>qr/[^A-Za-z0-9\-\._~]/,);sub uri_escape {my($text,$patn)=@_;return undef unless defined$text;if (defined$patn){unless (exists$subst{$patn}){(my$tmp=$patn)=~ s,/,\\/,g;eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";Carp::croak("uri_escape: $@")if $@}&{$subst{$patn}}($text)}else {$text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge}$text}sub _fail_hi {my$chr=shift;Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead",ord($chr))}sub uri_escape_utf8 {my$text=shift;return undef unless defined$text;utf8::encode($text);return uri_escape($text,@_)}sub uri_unescape {my$str=shift;if (@_ && wantarray){my@str=($str,@_);for (@str){s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg}return@str}$str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined$str;$str}sub escape_char {my$dummy=substr($_[0],0,0);if (utf8::is_utf8($_[0])){my$s=shift;utf8::encode($s);unshift(@_,$s)}return join '',@URI::Escape::escapes{split //,$_[0]}}1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HEURISTIC';
  package URI::Heuristic;use strict;use warnings;use Exporter 5.57 'import';our@EXPORT_OK=qw(uf_uri uf_uristr uf_url uf_urlstr);our$VERSION='5.10';our ($MY_COUNTRY,$DEBUG);sub MY_COUNTRY() {for ($MY_COUNTRY){return $_ if defined;$_=$ENV{COUNTRY};return $_ if defined;my@srcs=($ENV{LC_ALL},$ENV{LANG});if (my$httplang=$ENV{HTTP_ACCEPT_LANGUAGE}){for$httplang (split(/\s*,\s*/,$httplang)){if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/){unshift(@srcs,"${1}_${2}");last}}}for (@srcs){next unless defined;return lc($1)if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/}require Net::Domain;my$fqdn=Net::Domain::hostfqdn();$_=lc($1)if$fqdn =~ /\.([a-zA-Z]{2})$/;return $_ if defined;return ($_=0)}}our%LOCAL_GUESSING=('us'=>[qw(www.ACME.gov www.ACME.mil)],'gb'=>[qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],'au'=>[qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],'il'=>[qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],);$LOCAL_GUESSING{uk}=$LOCAL_GUESSING{gb};sub uf_uristr ($) {local($_)=@_;print STDERR "uf_uristr: resolving $_\n" if$DEBUG;return unless defined;s/^\s+//;s/\s+$//;if (/^(www|web|home)[a-z0-9-]*(?:\.|$)/i){$_="http://$_"}elsif (/^(ftp|gopher|news|wais|https|http)[a-z0-9-]*(?:\.|$)/i){$_=lc($1)."://$_"}elsif ($^O ne "MacOS" && (m,^/, || m,^\.\.?/, || m,^[a-zA-Z]:[/\\],)){$_="file:$_"}elsif ($^O eq "MacOS" && m/:/){unless (m/^(ftp|gopher|news|wais|http|https|mailto):/){require URI::file;my$a=URI::file->new($_)->as_string;$_=($a =~ m/^file:/)? $a : "file:$a"}}elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/){$_="mailto:$_"}elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/){if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/){my$host=$1;my$scheme="http";if (/^:(\d+)\b/){if ($1 =~ /^[56789]?443$/){$scheme="https"}elsif ($1 eq "21"){$scheme="ftp"}}if ($host !~ /\./ && $host ne "localhost"){my@guess;if (exists$ENV{URL_GUESS_PATTERN}){@guess=map {s/\bACME\b/$host/;$_}split(' ',$ENV{URL_GUESS_PATTERN})}else {if (MY_COUNTRY()){my$special=$LOCAL_GUESSING{MY_COUNTRY()};if ($special){my@special=@$special;push(@guess,map {s/\bACME\b/$host/;$_}@special)}else {push(@guess,"www.$host." .MY_COUNTRY())}}push(@guess,map "www.$host.$_","com","org","net","edu","int")}my$guess;for$guess (@guess){print STDERR "uf_uristr: gethostbyname('$guess.')..." if$DEBUG;if (gethostbyname("$guess.")){print STDERR "yes\n" if$DEBUG;$host=$guess;last}print STDERR "no\n" if$DEBUG}}$_="$scheme://$host$_"}else {}}print STDERR "uf_uristr: ==> $_\n" if$DEBUG;$_}sub uf_uri ($) {require URI;URI->new(uf_uristr($_[0]))}*uf_urlstr=\*uf_uristr;sub uf_url ($) {require URI::URL;URI::URL->new(uf_uristr($_[0]))}1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_IRI';
  package URI::IRI;use strict;use warnings;use URI ();use overload '""'=>sub {shift->as_string};our$VERSION='5.10';sub new {my($class,$uri,$scheme)=@_;utf8::upgrade($uri);return bless {uri=>URI->new($uri,$scheme),},$class}sub clone {my$self=shift;return bless {uri=>$self->{uri}->clone,},ref($self)}sub as_string {my$self=shift;return$self->{uri}->as_iri}our$AUTOLOAD;sub AUTOLOAD {my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);no strict 'refs';*$method=sub {shift->{uri}->$method(@_)};goto &$method}sub DESTROY {}1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_QUERYPARAM';
  package URI::QueryParam;use strict;use warnings;our$VERSION='5.10';sub URI::_query::query_param {my$self=shift;my@old=$self->query_form;if (@_==0){my (%seen,$i);return grep!($i++ % 2 || $seen{$_}++),@old}my$key=shift;my@i=grep $_ % 2==0 && $old[$_]eq $key,0 .. $#old;if (@_){my@new=@old;my@new_i=@i;my@vals=map {ref($_)eq 'ARRAY' ? @$_ : $_}@_;while (@new_i > @vals){splice@new,pop@new_i,2}if (@vals > @new_i){my$i=@new_i ? $new_i[-1]+ 2 : @new;my@splice=splice@vals,@new_i,@vals - @new_i;splice@new,$i,0,map {$key=>$_}@splice}if (@vals){@new[map $_ + 1,@new_i ]=@vals}$self->query_form(\@new)}return wantarray ? @old[map $_+1,@i]: @i ? $old[$i[0]+1]: undef}sub URI::_query::query_param_append {my$self=shift;my$key=shift;my@vals=map {ref $_ eq 'ARRAY' ? @$_ : $_}@_;$self->query_form($self->query_form,$key=>\@vals);return}sub URI::_query::query_param_delete {my$self=shift;my$key=shift;my@old=$self->query_form;my@vals;for (my$i=@old - 2;$i >= 0;$i -= 2){next if$old[$i]ne $key;push(@vals,(splice(@old,$i,2))[1])}$self->query_form(\@old)if@vals;return wantarray ? reverse@vals : $vals[-1]}sub URI::_query::query_form_hash {my$self=shift;my@old=$self->query_form;if (@_){$self->query_form(@_==1 ? %{shift(@_)}: @_)}my%hash;while (my($k,$v)=splice(@old,0,2)){if (exists$hash{$k}){for ($hash{$k}){$_=[$_]unless ref($_)eq "ARRAY";push(@$_,$v)}}else {$hash{$k}=$v}}return \%hash}1;
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SPLIT';
  package URI::Split;use strict;use warnings;our$VERSION='5.10';use Exporter 5.57 'import';our@EXPORT_OK=qw(uri_split uri_join);use URI::Escape ();sub uri_split {return $_[0]=~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,}sub uri_join {my($scheme,$auth,$path,$query,$frag)=@_;my$uri=defined($scheme)? "$scheme:" : "";$path="" unless defined$path;if (defined$auth){$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$uri .= "//$auth";$path="/$path" if length($path)&& $path !~ m,^/,}elsif ($path =~ m,^//,){$uri .= "//"}unless (length$uri){$path =~ s,(:), URI::Escape::escape_char($1),e while$path =~ m,^[^:/?\#]+:,}$path =~ s,([?\#]), URI::Escape::escape_char($1),eg;$uri .= $path;if (defined$query){$query =~ s,(\#), URI::Escape::escape_char($1),eg;$uri .= "?$query"}$uri .= "#$frag" if defined$frag;$uri}1;
URI_SPLIT

$fatpacked{"URI/URL.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URL';
  package URI::URL;use strict;use warnings;use parent 'URI::WithBase';our$VERSION='5.10';use Exporter 5.57 'import';our@EXPORT=qw(url);sub url ($;$) {URI::URL->new(@_)}use URI::Escape qw(uri_unescape);sub new {my$class=shift;my$self=$class->SUPER::new(@_);$self->[0]=$self->[0]->canonical;$self}sub newlocal {my$class=shift;require URI::file;bless [URI::file->new_abs(shift)],$class}{package URI::_foreign;sub _init {my$class=shift;die "Unknown URI::URL scheme $_[1]:" if$URI::URL::STRICT;$class->SUPER::_init(@_)}}sub strict {my$old=$URI::URL::STRICT;$URI::URL::STRICT=shift if @_;$old}sub print_on {my$self=shift;require Data::Dumper;print STDERR Data::Dumper::Dumper($self)}sub _try {my$self=shift;my$method=shift;scalar(eval {$self->$method(@_)})}sub crack {my$self=shift;(scalar($self->scheme),$self->_try("user"),$self->_try("password"),$self->_try("host"),$self->_try("port"),$self->_try("path"),$self->_try("params"),$self->_try("query"),scalar($self->fragment),)}sub full_path {my$self=shift;my$path=$self->path_query;$path="/" unless length$path;$path}sub netloc {shift->authority(@_)}sub epath {my$path=shift->SUPER::path(@_);$path =~ s/;.*//;$path}sub eparams {my$self=shift;my@p=$self->path_segments;return undef unless ref($p[-1]);@p=@{$p[-1]};shift@p;join(";",@p)}sub params {shift->eparams(@_)}sub path {my$self=shift;my$old=$self->epath(@_);return unless defined wantarray;return '/' if!defined($old)||!length($old);Carp::croak("Path components contain '/' (you must call epath)")if$old =~ /%2[fF]/ and!@_;$old="/$old" if$old !~ m|^/| && defined$self->netloc;return uri_unescape($old)}sub path_components {shift->path_segments(@_)}sub query {my$self=shift;my$old=$self->equery(@_);if (defined(wantarray)&& defined($old)){if ($old =~ /%(?:26|2[bB]|3[dD])/){my$mess;for ($old){$mess="Query contains both '+' and '%2B'" if /\+/ && /%2[bB]/;$mess="Form query contains escaped '=' or '&'" if /=/ && /%(?:3[dD]|26)/}if ($mess){Carp::croak("$mess (you must call equery)")}}return uri_unescape($old)}undef}sub abs {my$self=shift;my$base=shift;my$allow_scheme=shift;$allow_scheme=$URI::URL::ABS_ALLOW_RELATIVE_SCHEME unless defined$allow_scheme;local$URI::ABS_ALLOW_RELATIVE_SCHEME=$allow_scheme;local$URI::ABS_REMOTE_LEADING_DOTS=$URI::URL::ABS_REMOTE_LEADING_DOTS;$self->SUPER::abs($base)}sub frag {shift->fragment(@_)}sub keywords {shift->query_keywords(@_)}sub local_path {shift->file}sub unix_path {shift->file("unix")}sub dos_path {shift->file("dos")}sub mac_path {shift->file("mac")}sub vms_path {shift->file("vms")}sub address {shift->to(@_)}sub encoded822addr {shift->to(@_)}sub URI::mailto::authority {shift->to(@_)}sub groupart {shift->_group(@_)}sub article {shift->message(@_)}1;
URI_URL

$fatpacked{"URI/WithBase.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_WITHBASE';
  package URI::WithBase;use strict;use warnings;use URI ();use Scalar::Util qw(blessed);our$VERSION='5.10';use overload '""'=>"as_string",fallback=>1;sub as_string;sub new {my($class,$uri,$base)=@_;my$ibase=$base;if ($base && blessed($base)&& $base->isa(__PACKAGE__)){$base=$base->abs;$ibase=$base->[0]}bless [URI->new($uri,$ibase),$base],$class}sub new_abs {my$class=shift;my$self=$class->new(@_);$self->abs}sub _init {my$class=shift;my($str,$scheme)=@_;bless [URI->new($str,$scheme),undef],$class}sub eq {my($self,$other)=@_;$other=$other->[0]if blessed($other)and $other->isa(__PACKAGE__);$self->[0]->eq($other)}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my$method=substr($AUTOLOAD,rindex($AUTOLOAD,'::')+2);return if$method eq "DESTROY";$self->[0]->$method(@_)}sub can {my$self=shift;$self->SUPER::can(@_)|| (ref($self)? $self->[0]->can(@_): undef)}sub base {my$self=shift;my$base=$self->[1];if (@_){my$new_base=shift;$new_base=$new_base->abs if ref($new_base)&& $new_base->isa(__PACKAGE__);$self->[1]=$new_base}return unless defined wantarray;if (defined($base)&&!ref($base)){$base=ref($self)->new($base);$self->[1]=$base unless @_}$base}sub clone {my$self=shift;my$base=$self->[1];$base=$base->clone if ref($base);bless [$self->[0]->clone,$base],ref($self)}sub abs {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->abs($base,@_),$base],ref($self)}sub rel {my$self=shift;my$base=shift || $self->base || return$self->clone;$base=$base->as_string if ref($base);bless [$self->[0]->rel($base,@_),$base],ref($self)}1;
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__FOREIGN';
  package URI::_foreign;use strict;use warnings;use parent 'URI::_generic';our$VERSION='5.10';1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__GENERIC';
  package URI::_generic;use strict;use warnings;use parent qw(URI URI::_query);use URI::Escape qw(uri_unescape);use Carp ();our$VERSION='5.10';my$ACHAR=$URI::uric;$ACHAR =~ s,\\[/?],,g;my$PCHAR=$URI::uric;$PCHAR =~ s,\\[?],,g;sub _no_scheme_ok {1}sub authority {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;if (@_){my$auth=shift;$$self=$1;my$rest=$3;if (defined$auth){$auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($auth);$$self .= "//$auth"}_check_path($rest,$$self);$$self .= $rest}$2}sub path {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub path_query {my$self=shift;$$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;if (@_){$$self=$1;my$rest=$3;my$new_path=shift;$new_path="" unless defined$new_path;$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($new_path);_check_path($new_path,$$self);$$self .= $new_path .$rest}$2}sub _check_path {my($path,$pre)=@_;my$prefix;if ($pre =~ m,/,){$prefix="/" if length($path)&& $path !~ m,^[/?\#],}else {if ($path =~ m,^//,){Carp::carp("Path starting with double slash is confusing")if $^W}elsif (!length($pre)&& $path =~ m,^[^:/?\#]+:,){Carp::carp("Path might look like scheme, './' prepended")if $^W;$prefix="./"}}substr($_[0],0,0)=$prefix if defined$prefix}sub path_segments {my$self=shift;my$path=$self->path;if (@_){my@arg=@_;for (@arg){if (ref($_)){my@seg=@$_;$seg[0]=~ s/%/%25/g;for (@seg){s/;/%3B/g}$_=join(";",@seg)}else {s/%/%25/g;s/;/%3B/g}s,/,%2F,g}$self->path(join("/",@arg))}return$path unless wantarray;map {/;/ ? $self->_split_segment($_): uri_unescape($_)}split('/',$path,-1)}sub _split_segment {my$self=shift;require URI::_segment;URI::_segment->new(@_)}sub abs {my$self=shift;my$base=shift || Carp::croak("Missing base argument");if (my$scheme=$self->scheme){return$self unless$URI::ABS_ALLOW_RELATIVE_SCHEME;$base=URI->new($base)unless ref$base;return$self unless$scheme eq $base->scheme}$base=URI->new($base)unless ref$base;my$abs=$self->clone;$abs->scheme($base->scheme);return$abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;$abs->authority($base->authority);my$path=$self->path;return$abs if$path =~ m,^/,;if (!length($path)){my$abs=$base->clone;my$query=$self->query;$abs->query($query)if defined$query;my$fragment=$self->fragment;$abs->fragment($fragment)if defined$fragment;return$abs}my$p=$base->path;$p =~ s,[^/]+$,,;$p .= $path;my@p=split('/',$p,-1);shift(@p)if@p &&!length($p[0]);my$i=1;while ($i < @p){if ($p[$i-1]eq "."){splice(@p,$i-1,1);$i-- if$i > 1}elsif ($p[$i]eq ".." && $p[$i-1]ne ".."){splice(@p,$i-1,2);if ($i > 1){$i--;push(@p,"")if$i==@p}}else {$i++}}$p[-1]="" if@p && $p[-1]eq ".";if ($URI::ABS_REMOTE_LEADING_DOTS){shift@p while@p && $p[0]=~ /^\.\.?$/}$abs->path("/" .join("/",@p));$abs}sub rel {my$self=shift;my$base=shift || Carp::croak("Missing base argument");my$rel=$self->clone;$base=URI->new($base)unless ref$base;my$scheme=$rel->scheme;my$auth=$rel->canonical->authority;my$path=$rel->path;if (!defined($scheme)&&!defined($auth)){return$rel}my$bscheme=$base->scheme;my$bauth=$base->canonical->authority;my$bpath=$base->path;for ($bscheme,$bauth,$auth){$_='' unless defined}unless ($scheme eq $bscheme && $auth eq $bauth){return$rel}for ($path,$bpath){$_="/$_" unless m,^/,}$rel->scheme(undef);$rel->authority(undef);my$li=1;while (1){my$i=index($path,'/',$li);last if$i < 0 || $i!=index($bpath,'/',$li)|| substr($path,$li,$i-$li)ne substr($bpath,$li,$i-$li);$li=$i+1}substr($path,0,$li)='';substr($bpath,0,$li)='';if ($path eq $bpath && defined($rel->fragment)&& !defined($rel->query)){$rel->path("")}else {$path=('../' x $bpath =~ tr|/|/|).$path;$path="./" if$path eq "";$rel->path($path)}$rel}1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__IDNA';
  package URI::_idna;use strict;use warnings;use URI::_punycode qw(decode_punycode encode_punycode);use Carp qw(croak);our$VERSION='5.10';BEGIN {*URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS="$]" < 5.008_003 ? sub () {1}: sub () {0}}my$ASCII=qr/^[\x00-\x7F]*\z/;sub encode {my$idomain=shift;my@labels=split(/\./,$idomain,-1);my@last_empty;push(@last_empty,pop@labels)if@labels > 1 && $labels[-1]eq "";for (@labels){$_=ToASCII($_)}return eval 'join(".", @labels, @last_empty)' if URI::_idna::_ENV_::JOIN_LEAKS_UTF8_FLAGS;return join(".",@labels,@last_empty)}sub decode {my$domain=shift;return join(".",map ToUnicode($_),split(/\./,$domain,-1))}sub nameprep {my$label=shift;$label=lc($label);return$label}sub check_size {my$label=shift;croak "Label empty" if$label eq "";croak "Label too long" if length($label)> 63;return$label}sub ToASCII {my$label=shift;return check_size($label)if$label =~ $ASCII;$label=nameprep($label);return check_size($label)if$label =~ $ASCII;if ($label =~ /^xn--/){croak "Label starts with ACE prefix"}$label=encode_punycode($label);$label="xn--$label";return check_size($label)}sub ToUnicode {my$label=shift;$label=nameprep($label)unless$label =~ $ASCII;return$label unless$label =~ /^xn--/;my$result=decode_punycode(substr($label,4));my$label2=ToASCII($result);if (lc($label)ne $label2){croak "IDNA does not round-trip: '\L$label\E' vs '$label2'"}return$result}1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LDAP';
  package URI::_ldap;use strict;use warnings;our$VERSION='5.10';use URI::Escape qw(uri_unescape);sub _ldap_elem {my$self=shift;my$elem=shift;my$query=$self->query;my@bits=(split(/\?/,defined($query)? $query : ""),("")x4);my$old=$bits[$elem];if (@_){my$new=shift;$new =~ s/\?/%3F/g;$bits[$elem]=$new;$query=join("?",@bits);$query =~ s/\?+$//;$query=undef unless length($query);$self->query($query)}$old}sub dn {my$old=shift->path(@_);$old =~ s:^/::;uri_unescape($old)}sub attributes {my$self=shift;my$old=_ldap_elem($self,0,@_ ? join(",",map {my$tmp=$_;$tmp =~ s/,/%2C/g;$tmp}@_): ());return$old unless wantarray;map {uri_unescape($_)}split(/,/,$old)}sub _scope {my$self=shift;my$old=_ldap_elem($self,1,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub scope {my$old=&_scope;$old="base" unless length$old;$old}sub _filter {my$self=shift;my$old=_ldap_elem($self,2,@_);return undef unless defined wantarray && defined$old;uri_unescape($old)}sub filter {my$old=&_filter;$old="(objectClass=*)" unless length$old;$old}sub extensions {my$self=shift;my@ext;while (@_){my$key=shift;my$value=shift;push(@ext,join("=",map {$_="" unless defined;s/,/%2C/g;$_}$key,$value))}@ext=join(",",@ext)if@ext;my$old=_ldap_elem($self,3,@ext);return$old unless wantarray;map {uri_unescape($_)}map {/^([^=]+)=(.*)$/}split(/,/,$old)}sub canonical {my$self=shift;my$other=$self->_nonldap_canonical;$other=$other->clone if$other==$self;$other->dn(_normalize_dn($other->dn));$other->attributes(map lc,$other->attributes);my$old_scope=$other->scope;my$new_scope=lc($old_scope);$new_scope="" if$new_scope eq "base";$other->scope($new_scope)if$new_scope ne $old_scope;my$old_filter=$other->filter;$other->filter("")if lc($old_filter)eq "(objectclass=*)" || lc($old_filter)eq "objectclass=*";my@ext=$other->extensions;for (my$i=0;$i < @ext;$i += 2){my$etype=$ext[$i]=lc($ext[$i]);if ($etype =~ /^!?bindname$/){$ext[$i+1]=_normalize_dn($ext[$i+1])}}$other->extensions(@ext)if@ext;$other}sub _normalize_dn {my$dn=shift;return$dn;my@dn=split(/([+,])/,$dn);for (@dn){s/^([a-zA-Z]+=)/lc($1)/e}join("",@dn)}1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__LOGIN';
  package URI::_login;use strict;use warnings;use parent qw(URI::_server URI::_userpass);our$VERSION='5.10';1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__PUNYCODE';
  package URI::_punycode;use strict;use warnings;our$VERSION='5.10';use Exporter 'import';our@EXPORT=qw(encode_punycode decode_punycode);use integer;our$DEBUG=0;use constant BASE=>36;use constant TMIN=>1;use constant TMAX=>26;use constant SKEW=>38;use constant DAMP=>700;use constant INITIAL_BIAS=>72;use constant INITIAL_N=>128;my$Delimiter=chr 0x2D;my$BasicRE=qr/[\x00-\x7f]/;sub _croak {require Carp;Carp::croak(@_)}sub digit_value {my$code=shift;return ord($code)- ord("A")if$code =~ /[A-Z]/;return ord($code)- ord("a")if$code =~ /[a-z]/;return ord($code)- ord("0")+ 26 if$code =~ /[0-9]/;return}sub code_point {my$digit=shift;return$digit + ord('a')if 0 <= $digit && $digit <= 25;return$digit + ord('0')- 26 if 26 <= $digit && $digit <= 36;die 'NOT COME HERE'}sub adapt {my($delta,$numpoints,$firsttime)=@_;$delta=$firsttime ? $delta / DAMP : $delta / 2;$delta += $delta / $numpoints;my$k=0;while ($delta > ((BASE - TMIN)* TMAX)/ 2){$delta /= BASE - TMIN;$k += BASE}return$k + (((BASE - TMIN + 1)* $delta)/ ($delta + SKEW))}sub decode_punycode {my$code=shift;my$n=INITIAL_N;my$i=0;my$bias=INITIAL_BIAS;my@output;if ($code =~ s/(.*)$Delimiter//o){push@output,map ord,split //,$1;return _croak('non-basic code point')unless $1 =~ /^$BasicRE*$/o}while ($code){my$oldi=$i;my$w=1;LOOP: for (my$k=BASE;1;$k += BASE){my$cp=substr($code,0,1,'');my$digit=digit_value($cp);defined$digit or return _croak("invalid punycode input");$i += $digit * $w;my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$digit < $t;$w *= (BASE - $t)}$bias=adapt($i - $oldi,@output + 1,$oldi==0);warn "bias becomes $bias" if$DEBUG;$n += $i / (@output + 1);$i=$i % (@output + 1);splice(@output,$i,0,$n);warn join " ",map sprintf('%04x',$_),@output if$DEBUG;$i++}return join '',map chr,@output}sub encode_punycode {my$input=shift;my@input=split //,$input;my$n=INITIAL_N;my$delta=0;my$bias=INITIAL_BIAS;my@output;my@basic=grep /$BasicRE/,@input;my$h=my$b=@basic;push@output,@basic;push@output,$Delimiter if$b && $h < @input;warn "basic codepoints: (@output)" if$DEBUG;while ($h < @input){my$m=min(grep {$_ >= $n}map ord,@input);warn sprintf "next code point to insert is %04x",$m if$DEBUG;$delta += ($m - $n)* ($h + 1);$n=$m;for my$i (@input){my$c=ord($i);$delta++ if$c < $n;if ($c==$n){my$q=$delta;LOOP: for (my$k=BASE;1;$k += BASE){my$t=($k <= $bias)? TMIN : ($k >= $bias + TMAX)? TMAX : $k - $bias;last LOOP if$q < $t;my$cp=code_point($t + (($q - $t)% (BASE - $t)));push@output,chr($cp);$q=($q - $t)/ (BASE - $t)}push@output,chr(code_point($q));$bias=adapt($delta,$h + 1,$h==$b);warn "bias becomes $bias" if$DEBUG;$delta=0;$h++}}$delta++;$n++}return join '',@output}sub min {my$min=shift;for (@_){$min=$_ if $_ <= $min}return$min}1;
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__QUERY';
  package URI::_query;use strict;use warnings;use URI ();use URI::Escape qw(uri_unescape);our$VERSION='5.10';sub query {my$self=shift;$$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;if (@_){my$q=shift;$$self=$1;if (defined$q){$q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;utf8::downgrade($q);$$self .= "?$q"}$$self .= $3}$2}sub query_form {my$self=shift;my$old=$self->query;if (@_){my$delim;my$r=$_[0];if (ref($r)eq "ARRAY"){$delim=$_[1];@_=@$r}elsif (ref($r)eq "HASH"){$delim=$_[1];@_=map {$_=>$r->{$_}}sort keys %$r}$delim=pop if @_ % 2;my@query;while (my($key,$vals)=splice(@_,0,2)){$key='' unless defined$key;$key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$key =~ s/ /+/g;$vals=[ref($vals)eq "ARRAY" ? @$vals : $vals];for my$val (@$vals){$val='' unless defined$val;$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;$val =~ s/ /+/g;push(@query,"$key=$val")}}if (@query){unless ($delim){$delim=$1 if$old && $old =~ /([&;])/;$delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&"}$self->query(join($delim,@query))}else {$self->query(undef)}}return if!defined($old)||!length($old)||!defined(wantarray);return unless$old =~ /=/;map {s/\+/ /g;uri_unescape($_)}map {/=/ ? split(/=/,$_,2): ($_=>'')}split(/[&;]/,$old)}sub query_keywords {my$self=shift;my$old=$self->query;if (@_){my@copy=@_;@copy=@{$copy[0]}if@copy==1 && ref($copy[0])eq "ARRAY";for (@copy){s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg}$self->query(@copy ? join('+',@copy): undef)}return if!defined($old)||!defined(wantarray);return if$old =~ /=/;map {uri_unescape($_)}split(/\+/,$old,-1)}sub equery {goto&query}1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SEGMENT';
  package URI::_segment;use strict;use warnings;use URI::Escape qw(uri_unescape);use overload '""'=>sub {$_[0]->[0]},fallback=>1;our$VERSION='5.10';sub new {my$class=shift;my@segment=split(';',shift,-1);$segment[0]=uri_unescape($segment[0]);bless \@segment,$class}1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__SERVER';
  package URI::_server;use strict;use warnings;use parent 'URI::_generic';use URI::Escape qw(uri_unescape);our$VERSION='5.10';sub _uric_escape {my($class,$str)=@_;if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";if (_host_escape($host)){$str="$scheme//$ui$host$port$rest"}}return$class->SUPER::_uric_escape($str)}sub _host_escape {return unless $_[0]=~ /[^$URI::uric]/;eval {require URI::_idna;$_[0]=URI::_idna::encode($_[0])};return 0 if $@;return 1}sub as_iri {my$self=shift;my$str=$self->SUPER::as_iri;if ($str =~ /\bxn--/){if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os){my($scheme,$host,$rest)=($1,$2,$3);my$ui=$host =~ s/(.*@)// ? $1 : "";my$port=$host =~ s/(:\d+)\z// ? $1 : "";require URI::_idna;$host=URI::_idna::decode($host);$str="$scheme//$ui$host$port$rest"}}return$str}sub userinfo {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/.*@//;my$ui=shift;if (defined$ui){$ui =~ s/@/%40/g;$new="$ui\@$new"}$self->authority($new)}return undef if!defined($old)|| $old !~ /(.*)@/;return $1}sub host {my$self=shift;my$old=$self->authority;if (@_){my$tmp=$old;$tmp="" unless defined$tmp;my$ui=($tmp =~ /(.*@)/)? $1 : "";my$port=($tmp =~ /(:\d+)$/)? $1 : "";my$new=shift;$new="" unless defined$new;if (length$new){$new =~ s/[@]/%40/g;if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/){$new =~ s/(:\d*)\z// || die "Assert";$port=$1}$new="[$new]" if$new =~ /:/ && $new !~ /^\[/;_host_escape($new)}$self->authority("$ui$new$port")}return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:\d+$//;$old =~ s{^\[(.*)\]$}{$1};return uri_unescape($old)}sub ihost {my$self=shift;my$old=$self->host(@_);if ($old =~ /(^|\.)xn--/){require URI::_idna;$old=URI::_idna::decode($old)}return$old}sub _port {my$self=shift;my$old=$self->authority;if (@_){my$new=$old;$new =~ s/:\d*$//;my$port=shift;$new .= ":$port" if defined$port;$self->authority($new)}return $1 if defined($old)&& $old =~ /:(\d*)$/;return}sub port {my$self=shift;my$port=$self->_port(@_);$port=$self->default_port if!defined($port)|| $port eq "";$port}sub host_port {my$self=shift;my$old=$self->authority;$self->host(shift)if @_;return undef unless defined$old;$old =~ s/.*@//;$old =~ s/:$//;$old .= ":" .$self->port unless$old =~ /:\d+$/;$old}sub default_port {undef}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$host=$other->host || "";my$port=$other->_port;my$uc_host=$host =~ /[A-Z]/;my$def_port=defined($port)&& ($port eq "" || $port==$self->default_port);if ($uc_host || $def_port){$other=$other->clone if$other==$self;$other->host(lc$host)if$uc_host;$other->port(undef)if$def_port}$other}1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI__USERPASS';
  package URI::_userpass;use strict;use warnings;use URI::Escape qw(uri_unescape);our$VERSION='5.10';sub user {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$pass=defined($info)? $info : "";$pass =~ s/^[^:]*//;if (!defined($new)&&!length($pass)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$new =~ s/:/%3A/g;$self->userinfo("$new$pass")}}return undef unless defined$info;$info =~ s/:.*//;uri_unescape($info)}sub password {my$self=shift;my$info=$self->userinfo;if (@_){my$new=shift;my$user=defined($info)? $info : "";$user =~ s/:.*//;if (!defined($new)&&!length($user)){$self->userinfo(undef)}else {$new="" unless defined($new);$new =~ s/%/%25/g;$self->userinfo("$user:$new")}}return undef unless defined$info;return undef unless$info =~ s/^[^:]*://;uri_unescape($info)}1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_DATA';
  package URI::data;use strict;use warnings;use parent 'URI';our$VERSION='5.10';use MIME::Base64 qw(decode_base64 encode_base64);use URI::Escape qw(uri_unescape);sub media_type {my$self=shift;my$opaque=$self->opaque;$opaque =~ /^([^,]*),?/ or die;my$old=$1;my$base64;$base64=$1 if$old =~ s/(;base64)$//i;if (@_){my$new=shift;$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/,/%2C/g;$base64="" unless defined$base64;$opaque =~ s/^[^,]*,?/$new$base64,/;$self->opaque($opaque)}return uri_unescape($old)if$old;"text/plain;charset=US-ASCII"}sub data {my$self=shift;my($enc,$data)=split(",",$self->opaque,2);unless (defined$data){$data="";$enc="" unless defined$enc}my$base64=($enc =~ /;base64$/i);if (@_){$enc =~ s/;base64$//i if$base64;my$new=shift;$new="" unless defined$new;my$uric_count=_uric_count($new);my$urienc_len=$uric_count + (length($new)- $uric_count)* 3;my$base64_len=int((length($new)+2)/ 3)* 4;$base64_len += 7;if ($base64_len < $urienc_len || $_[0]){$enc .= ";base64";$new=encode_base64($new,"")}else {$new =~ s/%/%25/g}$self->opaque("$enc,$new")}return unless defined wantarray;$data=uri_unescape($data);return$base64 ? decode_base64($data): $data}my$ENC=$URI::uric;$ENC =~ s/%//;eval <<EOT;die $@ if $@;1;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
URI_DATA

$fatpacked{"URI/file.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE';
  package URI::file;use strict;use warnings;use parent 'URI::_generic';our$VERSION='5.10';use URI::Escape qw(uri_unescape);our$DEFAULT_AUTHORITY="";our%OS_CLASS=(os2=>"OS2",mac=>"Mac",MacOS=>"Mac",MSWin32=>"Win32",win32=>"Win32",msdos=>"FAT",dos=>"FAT",qnx=>"QNX",);sub os_class {my($OS)=shift || $^O;my$class="URI::file::" .($OS_CLASS{$OS}|| "Unix");no strict 'refs';unless (%{"$class\::"}){eval "require $class";die $@ if $@}$class}sub host {uri_unescape(shift->authority(@_))}sub new {my($class,$path,$os)=@_;os_class($os)->new($path)}sub new_abs {my$class=shift;my$file=$class->new(@_);return$file->abs($class->cwd)unless $$file =~ /^file:/;$file}sub cwd {my$class=shift;require Cwd;my$cwd=Cwd::cwd();$cwd=VMS::Filespec::unixpath($cwd)if $^O eq 'VMS';$cwd=$class->new($cwd);$cwd .= "/" unless substr($cwd,-1,1)eq "/";$cwd}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$scheme=$other->scheme;my$auth=$other->authority;return$other if!defined($scheme)&&!defined($auth);if (!defined($auth)|| $auth eq "" || lc($auth)eq "localhost" || (defined($DEFAULT_AUTHORITY)&& lc($auth)eq lc($DEFAULT_AUTHORITY))){if ((defined($auth)|| defined($DEFAULT_AUTHORITY))&& (!defined($auth)||!defined($DEFAULT_AUTHORITY)|| $auth ne $DEFAULT_AUTHORITY)){$other=$other->clone if$self==$other;$other->authority($DEFAULT_AUTHORITY)}}$other}sub file {my($self,$os)=@_;os_class($os)->file($self)}sub dir {my($self,$os)=@_;os_class($os)->dir($self)}1;
URI_FILE

$fatpacked{"URI/file/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_BASE';
  package URI::file::Base;use strict;use warnings;use URI::Escape ();our$VERSION='5.10';sub new {my$class=shift;my$path=shift;$path="" unless defined$path;my($auth,$escaped_auth,$escaped_path);($auth,$escaped_auth)=$class->_file_extract_authority($path);($path,$escaped_path)=$class->_file_extract_path($path);if (defined$auth){$auth =~ s,%,%25,g unless$escaped_auth;$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;$auth="//$auth";if (defined$path){$path="/$path" unless substr($path,0,1)eq "/"}else {$path=""}}else {return undef unless defined$path;$auth=""}$path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless$escaped_path;$path =~ s/\#/%23/g;my$uri=$auth .$path;$uri="file:$uri" if substr($uri,0,1)eq "/";URI->new($uri,"file")}sub _file_extract_authority {my($class,$path)=@_;return undef unless$class->_file_is_absolute($path);return$URI::file::DEFAULT_AUTHORITY}sub _file_extract_path {return undef}sub _file_is_absolute {return 0}sub _file_is_localhost {shift;my$host=lc(shift);return 1 if$host eq "localhost";eval {require Net::Domain;lc(Net::Domain::hostfqdn()|| '')eq $host || lc(Net::Domain::hostname()|| '')eq $host}}sub file {undef}sub dir {my$self=shift;$self->file(@_)}1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_FAT';
  package URI::file::FAT;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='5.10';sub fix_path {shift;for (@_){my@p=map uc,split(/\./,$_,-1);return if@p > 2;@p=("")unless@p;$_=substr($p[0],0,8);if (@p > 1){my$ext=substr($p[1],0,3);$_ .= ".$ext" if length$ext}}1}1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_MAC';
  package URI::file::Mac;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='5.10';sub _file_extract_path {my$class=shift;my$path=shift;my@pre;if ($path =~ s/^(:+)//){if (length($1)==1){@pre=(".")unless length($path)}else {@pre=("..")x (length($1)- 1)}}else {$pre[0]=""}my$isdir=($path =~ s/:$//);$path =~ s,([%/;]), URI::Escape::escape_char($1),eg;my@path=split(/:/,$path,-1);for (@path){if ($_ eq "." || $_ eq ".."){$_="%2E" x length($_)}$_=".." unless length($_)}push (@path,"")if$isdir;(join("/",@pre,@path),1)}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined$auth){if (lc($auth)ne "localhost" && $auth ne ""){my$u_auth=uri_unescape($auth);if (!$class->_file_is_localhost($u_auth)){@path=("",$auth)}}}my@ps=split("/",$uri->path,-1);shift@ps if@path;push(@path,@ps);my$pre="";if (!@path){return}elsif ($path[0]eq ""){shift(@path);if (@path==1){return if$path[0]eq "";push(@path,"")}@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}else {$pre=":";@ps=@path;@path=();my$part;for (@ps){next if $_ eq ".";$part=$_ eq ".." ? "" : $_;push(@path,$part)}if ($ps[-1]eq ".."){push(@path,"")}}return unless$pre || @path;for (@path){s/;.*//;$_=uri_unescape($_);return if /\0/;return if /:/}$pre .join(":",@path)}sub dir {my$class=shift;my$path=$class->file(@_);return unless defined$path;$path .= ":" unless$path =~ /:$/;$path}1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_OS2';
  package URI::file::OS2;use strict;use warnings;use parent 'URI::file::Win32';our$VERSION='5.10';sub _file_extract_authority {my$class=shift;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ m#^[a-zA-Z]{1,2}:#){return ""}return}sub file {my$p=&URI::file::Win32::file;return unless defined$p;$p =~ s,\\,/,g;$p}1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_QNX';
  package URI::file::QNX;use strict;use warnings;use parent 'URI::file::Unix';our$VERSION='5.10';sub _file_extract_path {my($class,$path)=@_;$path =~ s,(.)//+,$1/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;$path}1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_UNIX';
  package URI::file::Unix;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='5.10';sub _file_extract_path {my($class,$path)=@_;$path =~ s,//+,/,g;$path =~ s,(/\.)+/,/,g;$path="./$path" if$path =~ m,^[^:/]+:,,;return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^/,}sub file {my$class=shift;my$uri=shift;my@path;my$auth=$uri->authority;if (defined($auth)){if (lc($auth)ne "localhost" && $auth ne ""){$auth=uri_unescape($auth);unless ($class->_file_is_localhost($auth)){push(@path,"","",$auth)}}}my@ps=$uri->path_segments;shift@ps if@path;push(@path,@ps);for (@path){return undef if /\0/;return undef if /\//}return join("/",@path)}1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FILE_WIN32';
  package URI::file::Win32;use strict;use warnings;use parent 'URI::file::Base';use URI::Escape qw(uri_unescape);our$VERSION='5.10';sub _file_extract_authority {my$class=shift;return$class->SUPER::_file_extract_authority($_[0])if defined$URI::file::DEFAULT_AUTHORITY;return $1 if $_[0]=~ s,^\\\\([^\\]+),,;return $1 if $_[0]=~ s,^//([^/]+),,;if ($_[0]=~ s,^([a-zA-Z]:),,){my$auth=$1;$auth .= "relative" if $_[0]!~ m,^[\\/],;return$auth}return undef}sub _file_extract_path {my($class,$path)=@_;$path =~ s,\\,/,g;$path =~ s,(/\.)+/,/,g;if (defined$URI::file::DEFAULT_AUTHORITY){$path =~ s,^([a-zA-Z]:),/$1,}return$path}sub _file_is_absolute {my($class,$path)=@_;return$path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],}sub file {my$class=shift;my$uri=shift;my$auth=$uri->authority;my$rel;if (defined$auth){$auth=uri_unescape($auth);if ($auth =~ /^([a-zA-Z])[:|](relative)?/){$auth=uc($1).":";$rel++ if $2}elsif (lc($auth)eq "localhost"){$auth=""}elsif (length$auth){$auth="\\\\" .$auth}}else {$auth=""}my@path=$uri->path_segments;for (@path){return undef if /\0/;return undef if /\//}return undef unless$class->fix_path(@path);my$path=join("\\",@path);$path =~ s/^\\// if$rel;$path=$auth .$path;$path =~ s,^\\([a-zA-Z])[:|],\u$1:,;return$path}sub fix_path {1}1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_FTP';
  package URI::ftp;use strict;use warnings;our$VERSION='5.10';use parent qw(URI::_server URI::_userpass);sub default_port {21}sub path {shift->path_query(@_)}sub _user {shift->SUPER::user(@_)}sub _password {shift->SUPER::password(@_)}sub user {my$self=shift;my$user=$self->_user(@_);$user="anonymous" unless defined$user;$user}sub password {my$self=shift;my$pass=$self->_password(@_);unless (defined$pass){my$user=$self->user;if ($user eq 'anonymous' || $user eq 'ftp'){$pass='anonymous@'}}$pass}1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_GOPHER';
  package URI::gopher;use strict;use warnings;our$VERSION='5.10';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {70}sub _gopher_type {my$self=shift;my$path=$self->path_query;$path =~ s,^/,,;my$gtype=$1 if$path =~ s/^(.)//s;if (@_){my$new_type=shift;if (defined($new_type)){Carp::croak("Bad gopher type '$new_type'")unless length($new_type)==1;substr($path,0,0)=$new_type;$self->path_query($path)}else {Carp::croak("Can't delete gopher type when selector is present")if length($path);$self->path_query(undef)}}return$gtype}sub gopher_type {my$self=shift;my$gtype=$self->_gopher_type(@_);$gtype="1" unless defined$gtype;$gtype}sub gtype {goto&gopher_type}sub selector {shift->_gfield(0,@_)}sub search {shift->_gfield(1,@_)}sub string {shift->_gfield(2,@_)}sub _gfield {my$self=shift;my$fno=shift;my$path=$self->path_query;$path =~ s/\?/\t/;$path=uri_unescape($path);$path =~ s,^/,,;my$gtype=$1 if$path =~ s,^(.),,s;my@path=split(/\t/,$path,3);if (@_){my$new=shift;$path[$fno]=$new;pop(@path)while@path &&!defined($path[-1]);for (@path){$_="" unless defined}$path=$gtype;$path="1" unless defined$path;$path .= join("\t",@path);$self->path_query($path)}$path[$fno]}1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTP';
  package URI::http;use strict;use warnings;our$VERSION='5.10';use parent 'URI::_server';sub default_port {80}sub canonical {my$self=shift;my$other=$self->SUPER::canonical;my$slash_path=defined($other->authority)&& !length($other->path)&&!defined($other->query);if ($slash_path){$other=$other->clone if$other==$self;$other->path("/")}$other}1;
URI_HTTP

$fatpacked{"URI/https.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_HTTPS';
  package URI::https;use strict;use warnings;our$VERSION='5.10';use parent 'URI::http';sub default_port {443}sub secure {1}1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAP';
  package URI::ldap;use strict;use warnings;our$VERSION='5.10';use parent qw(URI::_ldap URI::_server);sub default_port {389}sub _nonldap_canonical {my$self=shift;$self->URI::_server::canonical(@_)}1;
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPI';
  package URI::ldapi;use strict;use warnings;our$VERSION='5.10';use parent qw(URI::_ldap URI::_generic);use URI::Escape ();sub un_path {my$self=shift;my$old=URI::Escape::uri_unescape($self->authority);if (@_){my$p=shift;$p =~ s/:/%3A/g;$p =~ s/\@/%40/g;$self->authority($p)}return$old}sub _nonldap_canonical {my$self=shift;$self->URI::_generic::canonical(@_)}1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_LDAPS';
  package URI::ldaps;use strict;use warnings;our$VERSION='5.10';use parent 'URI::ldap';sub default_port {636}sub secure {1}1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MAILTO';
  package URI::mailto;use strict;use warnings;our$VERSION='5.10';use parent qw(URI URI::_query);sub to {my$self=shift;my@old=$self->headers;if (@_){my@new=@old;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){splice(@new,$i,2);redo}}my$to=shift;$to="" unless defined$to;unshift(@new,"to"=>$to);$self->headers(@new)}return unless defined wantarray;my@to;while (@old){my$h=shift@old;my$v=shift@old;push(@to,$v)if lc($h)eq "to"}join(",",@to)}sub headers {my$self=shift;my$opaque="to=" .$self->opaque;$opaque =~ s/\?/&/;if (@_){my@new=@_;my@to;for (my$i=0;$i < @new;$i += 2){if (lc($new[$i]|| '')eq "to"){push(@to,(splice(@new,$i,2))[1]);redo}}my$new=join(",",@to);$new =~ s/%/%25/g;$new =~ s/\?/%3F/g;$self->opaque($new);$self->query_form(@new)if@new}return unless defined wantarray;URI->new("mailto:?$opaque")->query_form}sub query_form {my$self=shift;my@fields=$self->SUPER::query_form(@_);for (my$i=0 ;$i < @fields ;$i += 2 ){if ($fields[0]eq 'to'){$fields[1]=~ s/ /+/g;last}}return@fields}1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_MMS';
  package URI::mms;use strict;use warnings;our$VERSION='5.10';use parent 'URI::http';sub default_port {1755}1;
URI_MMS

$fatpacked{"URI/news.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NEWS';
  package URI::news;use strict;use warnings;our$VERSION='5.10';use parent 'URI::_server';use URI::Escape qw(uri_unescape);use Carp ();sub default_port {119}sub _group {my$self=shift;my$old=$self->path;if (@_){my($group,$from,$to)=@_;if ($group =~ /\@/){$group =~ s/^<(.*)>$/$1/}$group =~ s,%,%25,g;$group =~ s,/,%2F,g;my$path=$group;if (defined$from){$path .= "/$from";$path .= "-$to" if defined$to}$self->path($path)}$old =~ s,^/,,;if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray){my$extra=$1;return (uri_unescape($old),split(/-/,$extra))}uri_unescape($old)}sub group {my$self=shift;if (@_){Carp::croak("Group name can't contain '\@'")if $_[0]=~ /\@/}my@old=$self->_group(@_);return if$old[0]=~ /\@/;wantarray ? @old : $old[0]}sub message {my$self=shift;if (@_){Carp::croak("Message must contain '\@'")unless $_[0]=~ /\@/}my$old=$self->_group(@_);return undef unless$old =~ /\@/;return$old}1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTP';
  package URI::nntp;use strict;use warnings;our$VERSION='5.10';use parent 'URI::news';1;
URI_NNTP

$fatpacked{"URI/nntps.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_NNTPS';
  package URI::nntps;use strict;use warnings;our$VERSION='5.10';use parent 'URI::nntp';sub default_port {563}sub secure {1}1;
URI_NNTPS

$fatpacked{"URI/pop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_POP';
  package URI::pop;use strict;use warnings;our$VERSION='5.10';use parent 'URI::_server';use URI::Escape qw(uri_unescape);sub default_port {110}sub user {my$self=shift;my$old=$self->userinfo;if (@_){my$new_info=$old;$new_info="" unless defined$new_info;$new_info =~ s/^[^;]*//;my$new=shift;if (!defined($new)&&!length($new_info)){$self->userinfo(undef)}else {$new="" unless defined$new;$new =~ s/%/%25/g;$new =~ s/;/%3B/g;$self->userinfo("$new$new_info")}}return undef unless defined$old;$old =~ s/;.*//;return uri_unescape($old)}sub auth {my$self=shift;my$old=$self->userinfo;if (@_){my$new=$old;$new="" unless defined$new;$new =~ s/(^[^;]*)//;my$user=$1;$new =~ s/;auth=[^;]*//i;my$auth=shift;if (defined$auth){$auth =~ s/%/%25/g;$auth =~ s/;/%3B/g;$new=";AUTH=$auth$new"}$self->userinfo("$user$new")}return undef unless defined$old;$old =~ s/^[^;]*//;return uri_unescape($1)if$old =~ /;auth=(.*)/i;return}1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RLOGIN';
  package URI::rlogin;use strict;use warnings;our$VERSION='5.10';use parent 'URI::_login';sub default_port {513}1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RSYNC';
  package URI::rsync;use strict;use warnings;our$VERSION='5.10';use parent qw(URI::_server URI::_userpass);sub default_port {873}1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSP';
  package URI::rtsp;use strict;use warnings;our$VERSION='5.10';use parent 'URI::http';sub default_port {554}1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_RTSPU';
  package URI::rtspu;use strict;use warnings;our$VERSION='5.10';use parent 'URI::rtsp';sub default_port {554}1;
URI_RTSPU

$fatpacked{"URI/sftp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SFTP';
  package URI::sftp;use strict;use warnings;use parent 'URI::ssh';our$VERSION='5.10';1;
URI_SFTP

$fatpacked{"URI/sip.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIP';
  package URI::sip;use strict;use warnings;use parent qw(URI::_server URI::_userpass);use URI::Escape ();our$VERSION='5.10';sub default_port {5060}sub authority {my$self=shift;$$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;my$old=$2;if (@_){my$auth=shift;$$self=defined($1)? $1 : "";my$rest=$3;if (defined$auth){$auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;$$self .= "$auth"}$$self .= $rest}$old}sub params_form {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my@args=@_;$$self=$1 .$2;my$rest=$4;my@new;for (my$i=0;$i < @args;$i += 2){push(@new,"$args[$i]=$args[$i+1]")}$paramstr=join(";",@new);$$self .= ";" .$paramstr .$rest}$paramstr =~ s/^;//o;return split(/[;=]/,$paramstr)}sub params {my$self=shift;$$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;my$paramstr=$3;if (@_){my$new=shift;$$self=$1 .$2;my$rest=$4;$$self .= $paramstr .$rest}$paramstr =~ s/^;//o;return$paramstr}sub path {}sub path_query {}sub path_segments {}sub abs {shift}sub rel {shift}sub query_keywords {}1;
URI_SIP

$fatpacked{"URI/sips.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SIPS';
  package URI::sips;use strict;use warnings;our$VERSION='5.10';use parent 'URI::sip';sub default_port {5061}sub secure {1}1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SNEWS';
  package URI::snews;use strict;use warnings;our$VERSION='5.10';use parent 'URI::news';sub default_port {563}sub secure {1}1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_SSH';
  package URI::ssh;use strict;use warnings;our$VERSION='5.10';use parent 'URI::_login';sub default_port {22}sub secure {1}1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TELNET';
  package URI::telnet;use strict;use warnings;our$VERSION='5.10';use parent 'URI::_login';sub default_port {23}1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_TN3270';
  package URI::tn3270;use strict;use warnings;our$VERSION='5.10';use parent 'URI::_login';sub default_port {23}1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN';
  package URI::urn;use strict;use warnings;our$VERSION='5.10';use parent 'URI';use Carp qw(carp);my%implementor;my%require_attempted;sub _init {my$class=shift;my$self=$class->SUPER::_init(@_);my$nid=$self->nid;my$impclass=$implementor{$nid};return$impclass->_urn_init($self,$nid)if$impclass;$impclass="URI::urn";if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/){my$id=$nid;$id =~ s/-/_/g;$id="_$id" if$id =~ /^\d/;$impclass="URI::urn::$id";no strict 'refs';unless (@{"${impclass}::ISA"}){if (not exists$require_attempted{$impclass}){my$_old_error=$@;eval "require $impclass";die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;$@=$_old_error}$impclass="URI::urn" unless @{"${impclass}::ISA"}}}else {carp("Illegal namespace identifier '$nid' for URN '$self'")if $^W}$implementor{$nid}=$impclass;return$impclass->_urn_init($self,$nid)}sub _urn_init {my($class,$self,$nid)=@_;bless$self,$class}sub _nid {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;$v =~ s/[^:]*/$new/;$self->opaque($v)}$opaque =~ s/:.*//s;return$opaque}sub nid {my$self=shift;my$nid=$self->_nid(@_);$nid=lc($nid)if defined($nid);return$nid}sub nss {my$self=shift;my$opaque=$self->opaque;if (@_){my$v=$opaque;my$new=shift;if (defined$new){$v =~ s/(:|\z).*/:$new/}else {$v =~ s/:.*//s}$self->opaque($v)}return undef unless$opaque =~ s/^[^:]*://;return$opaque}sub canonical {my$self=shift;my$nid=$self->_nid;my$new=$self->SUPER::canonical;return$new if$nid !~ /[A-Z]/ || $nid =~ /%/;$new=$new->clone if$new==$self;$new->nid(lc($nid));return$new}1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_ISBN';
  package URI::urn::isbn;use strict;use warnings;our$VERSION='5.10';use parent 'URI::urn';use Carp qw(carp);BEGIN {require Business::ISBN;local $^W=0;warn "Using Business::ISBN version " .Business::ISBN->VERSION ." which is deprecated.\nUpgrade to Business::ISBN version 3.005\n" if Business::ISBN->VERSION < 3.005}sub _isbn {my$nss=shift;$nss=$nss->nss if ref($nss);my$isbn=Business::ISBN->new($nss);$isbn=undef if$isbn &&!$isbn->is_valid;return$isbn}sub _nss_isbn {my$self=shift;my$nss=$self->nss(@_);my$isbn=_isbn($nss);$isbn=$isbn->as_string if$isbn;return($nss,$isbn)}sub isbn {my$self=shift;my$isbn;(undef,$isbn)=$self->_nss_isbn(@_);return$isbn}sub isbn_publisher_code {my$isbn=shift->_isbn || return undef;return$isbn->publisher_code}BEGIN {my$group_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code'};sub isbn_group_code {my$isbn=shift->_isbn || return undef;return$isbn->$group_method}}sub isbn_country_code {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn_group_code instead";no strict 'refs';&isbn_group_code}BEGIN {my$isbn13_method=do {local $^W=0;Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean'};sub isbn13 {my$isbn=shift->_isbn || return undef;my$thingy=$isbn->$isbn13_method;return eval {$thingy->can('as_string')}? $thingy->as_string([]): $thingy}}sub isbn_as_ean {my$name=(caller(0))[3];$name =~ s/.*:://;carp "$name is DEPRECATED. Use isbn13 instead";no strict 'refs';&isbn13}sub canonical {my$self=shift;my($nss,$isbn)=$self->_nss_isbn;my$new=$self->SUPER::canonical;return$new unless$nss && $isbn && $nss ne $isbn;$new=$new->clone if$new==$self;$new->nss($isbn);return$new}1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'URI_URN_OID';
  package URI::urn::oid;use strict;use warnings;our$VERSION='5.10';use parent 'URI::urn';sub oid {my$self=shift;my$old=$self->nss;if (@_){$self->nss(join(".",@_))}return split(/\./,$old)if wantarray;return$old}1;
URI_URN_OID

$fatpacked{"Win32/ShellQuote.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'WIN32_SHELLQUOTE';
  package Win32::ShellQuote;use strict;use warnings FATAL=>'all';use base 'Exporter';use Carp;our$VERSION='0.003001';$VERSION=eval$VERSION;our@EXPORT_OK=qw(quote_native quote_cmd quote_system_list quote_system_string quote_system quote_system_cmd quote_literal cmd_escape unquote_native cmd_unescape);our%EXPORT_TAGS=(all=>[@EXPORT_OK]);sub quote_native {return join q{ },quote_system_list(@_)}sub quote_cmd {return cmd_escape(quote_native(@_))}sub quote_system_list {return map {quote_literal($_,1)}@_}sub quote_system_string {my$args=quote_native(@_);if (_has_shell_metachars($args)){$args=cmd_escape($args)}return$args}sub quote_system {if (@_ > 1){return quote_system_list(@_)}else {return quote_system_string(@_)}}sub quote_system_cmd {my$args=quote_native(@_);if (!_has_shell_metachars($args)){return '%PATH:~0,0%' .cmd_escape($args)}return cmd_escape($args)}sub cmd_escape {my$string=shift;if ($string =~ /[\r\n\0]/){croak "can't quote newlines to pass through cmd.exe"}$string =~ s/([()%!^"<>&|])/^$1/g;return$string}sub quote_literal {my ($text,$force)=@_;if (!$force && $text ne '' && $text !~ /[ \t\n\x0b"]/){}else {$text =~ s{(\\*)(?="|\z)}{$1$1}g;$text =~ s{"}{\\"}g;$text=qq{"$text"}}return$text}sub _has_shell_metachars {my$string=shift;return 1 if$string =~ /%/;$string =~ s/(['"]).*?(\1|\z)//sg;return$string =~ /[<>|]/}sub unquote_native {local ($_)=@_;my@argv;my$length=length or return@argv;m/\G\s*/gc;ARGS: until (pos==$length){my$quote_mode;my$arg='';CHARS: until (pos==$length){if (m/\G((?:\\\\)+)(?=\\?(")?)/gc){if (defined $2){$arg .= '\\' x (length($1)/ 2)}else {$arg .= $1}}elsif (m/\G\\"/gc){$arg .= '"'}elsif (m/\G"/gc){if ($quote_mode && m/\G"/gc){$arg .= '"'}$quote_mode=!$quote_mode}elsif (!$quote_mode && m/\G\s+/gc){last}elsif (m/\G(.)/sgc){$arg .= $1}}push@argv,$arg}return@argv}sub cmd_unescape {my ($string)=@_;no warnings 'uninitialized';$string =~ s/\^(.?)|([^^"]+)|("[^"]*(?:"|\z))/$1$2$3/gs;return$string}1;
WIN32_SHELLQUOTE

$fatpacked{"YAML/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP';
  use strict;use warnings;package YAML::PP;our$VERSION='0.031';use YAML::PP::Schema;use YAML::PP::Schema::JSON;use YAML::PP::Loader;use YAML::PP::Dumper;use Scalar::Util qw/blessed/;use Carp qw/croak/;use base 'Exporter';our@EXPORT_OK=qw/Load LoadFile Dump DumpFile/;my%YAML_VERSIONS=('1.1'=>1,'1.2'=>1);sub new {my ($class,%args)=@_;my$bool=delete$args{boolean};$bool='perl' unless defined$bool;my$schemas=delete$args{schema}|| ['+'];my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';my$indent=delete$args{indent};my$width=delete$args{width};my$writer=delete$args{writer};my$header=delete$args{header};my$footer=delete$args{footer};my$duplicate_keys=delete$args{duplicate_keys};my$yaml_version=$class->_arg_yaml_version(delete$args{yaml_version});my$default_yaml_version=$yaml_version->[0];my$version_directive=delete$args{version_directive};my$preserve=delete$args{preserve};my$parser=delete$args{parser};my$emitter=delete$args{emitter}|| {indent=>$indent,width=>$width,writer=>$writer,};if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my%schemas;for my$v (@$yaml_version){my$schema;if (blessed($schemas)and $schemas->isa('YAML::PP::Schema')){$schema=$schemas}else {$schema=YAML::PP::Schema->new(boolean=>$bool,yaml_version=>$v,);$schema->load_subschemas(@$schemas)}$schemas{$v }=$schema}my$default_schema=$schemas{$default_yaml_version };my$loader=YAML::PP::Loader->new(schemas=>\%schemas,cyclic_refs=>$cyclic_refs,parser=>$parser,default_yaml_version=>$default_yaml_version,preserve=>$preserve,duplicate_keys=>$duplicate_keys,);my$dumper=YAML::PP::Dumper->new(schema=>$default_schema,emitter=>$emitter,header=>$header,footer=>$footer,version_directive=>$version_directive,preserve=>$preserve,);my$self=bless {schema=>\%schemas,loader=>$loader,dumper=>$dumper,},$class;return$self}sub clone {my ($self)=@_;my$clone={schema=>$self->schema,loader=>$self->loader->clone,dumper=>$self->dumper->clone,};return bless$clone,ref$self}sub _arg_yaml_version {my ($class,$version)=@_;my@versions=('1.2');if (defined$version){@versions=();if (not ref$version){$version=[$version]}for my$v (@$version){unless ($YAML_VERSIONS{$v }){croak "YAML Version '$v' not supported"}push@versions,$v}}return \@versions}sub loader {if (@_ > 1){$_[0]->{loader}=$_[1]}return $_[0]->{loader}}sub dumper {if (@_ > 1){$_[0]->{dumper}=$_[1]}return $_[0]->{dumper}}sub schema {if (@_ > 1){$_[0]->{schema}->{'1.2'}=$_[1]}return $_[0]->{schema}->{'1.2'}}sub default_schema {my ($self,%args)=@_;my$schema=YAML::PP::Schema->new(boolean=>$args{boolean},);$schema->load_subschemas(qw/Core/);return$schema}sub load_string {my ($self,$yaml)=@_;return$self->loader->load_string($yaml)}sub load_file {my ($self,$file)=@_;return$self->loader->load_file($file)}sub dump {my ($self,@data)=@_;return$self->dumper->dump(@data)}sub dump_string {my ($self,@data)=@_;return$self->dumper->dump_string(@data)}sub dump_file {my ($self,$file,@data)=@_;return$self->dumper->dump_file($file,@data)}sub Load {my ($yaml)=@_;YAML::PP->new->load_string($yaml)}sub LoadFile {my ($file)=@_;YAML::PP->new->load_file($file)}sub Dump {my (@data)=@_;YAML::PP->new->dump_string(@data)}sub DumpFile {my ($file,@data)=@_;YAML::PP->new->dump_file($file,@data)}sub preserved_scalar {my ($self,$value,%args)=@_;my$scalar=YAML::PP::Preserve::Scalar->new(value=>$value,%args,);return$scalar}sub preserved_mapping {my ($self,$hash,%args)=@_;my$data={};tie %$data,'YAML::PP::Preserve::Hash';%$data=%$hash;my$t=tied %$data;$t->{style}=$args{style};$t->{alias}=$args{alias};return$data}sub preserved_sequence {my ($self,$array,%args)=@_;my$data=[];tie @$data,'YAML::PP::Preserve::Array';push @$data,@$array;my$t=tied @$data;$t->{style}=$args{style};$t->{alias}=$args{alias};return$data}package YAML::PP::Preserve::Hash;use Tie::Hash;use base qw/Tie::StdHash/;use Scalar::Util qw/reftype blessed/;sub TIEHASH {my ($class,%args)=@_;my$self=bless {keys=>[keys%args],data=>{%args },},$class}sub STORE {my ($self,$key,$val)=@_;my$keys=$self->{keys};unless (exists$self->{data}->{$key }){push @$keys,$key}if (ref$val and not blessed($val)){if (reftype($val)eq 'HASH' and not tied %$val){tie %$val,'YAML::PP::Preserve::Hash',%$val}elsif (reftype($val)eq 'ARRAY' and not tied @$val){tie @$val,'YAML::PP::Preserve::Array',@$val}}$self->{data}->{$key }=$val}sub FIRSTKEY {my ($self)=@_;return$self->{keys}->[0]}sub NEXTKEY {my ($self,$last)=@_;my$keys=$self->{keys};for my$i (0 .. $#$keys){if ("$keys->[ $i ]" eq "$last"){return$keys->[$i + 1 ]}}return}sub FETCH {my ($self,$key)=@_;my$val=$self->{data}->{$key }}sub DELETE {my ($self,$key)=@_;@{$self->{keys}}=grep {"$_" ne "$key"}@{$self->{keys}};delete$self->{data}->{$key }}sub EXISTS {my ($self,$key)=@_;return exists$self->{data}->{$key }}sub CLEAR {my ($self)=@_;$self->{keys}=[];$self->{data}={}}sub SCALAR {my ($self)=@_;return scalar %{$self->{data}}}package YAML::PP::Preserve::Array;use Tie::Array;use base qw/Tie::StdArray/;use Scalar::Util qw/reftype blessed/;sub TIEARRAY {my ($class,@items)=@_;my$self=bless {data=>[@items],},$class;return$self}sub FETCH {my ($self,$i)=@_;return$self->{data}->[$i ]}sub FETCHSIZE {my ($self)=@_;return $#{$self->{data}}+ 1}sub _preserve {my ($val)=@_;if (ref$val and not blessed($val)){if (reftype($val)eq 'HASH' and not tied %$val){tie %$val,'YAML::PP::Preserve::Hash',%$val}elsif (reftype($val)eq 'ARRAY' and not tied @$val){tie @$val,'YAML::PP::Preserve::Array',@$val}}return$val}sub STORE {my ($self,$i,$val)=@_;_preserve($val);$self->{data}->[$i ]=$val}sub PUSH {my ($self,@args)=@_;push @{$self->{data}},map {_preserve $_}@args}sub STORESIZE {my ($self,$i)=@_;$#{$self->{data}}=$i - 1}sub DELETE {my ($self,$i)=@_;delete$self->{data}->[$i ]}sub EXISTS {my ($self,$i)=@_;return exists$self->{data}->[$i ]}sub CLEAR {my ($self)=@_;$self->{data}=[]}sub SHIFT {my ($self)=@_;shift @{$self->{data}}}sub UNSHIFT {my ($self,@args)=@_;unshift @{$self->{data}},map {_preserve $_}@args}sub SPLICE {my ($self,$offset,$length,@args)=@_;splice @{$self->{data}},$offset,$length,map {_preserve $_}@args}sub EXTEND {}package YAML::PP::Preserve::Scalar;use overload fallback=>1,'+'=>\&value,'""'=>\&value,'bool'=>\&value,;sub new {my ($class,%args)=@_;my$self={%args,};bless$self,$class}sub value {$_[0]->{value}}sub tag {$_[0]->{tag}}sub style {$_[0]->{style}|| 0}sub alias {$_[0]->{alias}}1;
YAML_PP

$fatpacked{"YAML/PP/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_COMMON';
  use strict;use warnings;package YAML::PP::Common;our$VERSION='0.031';use base 'Exporter';our@EXPORT_OK=qw/YAML_ANY_SCALAR_STYLE YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_QUOTED_SCALAR_STYLE YAML_ANY_SEQUENCE_STYLE YAML_BLOCK_SEQUENCE_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_ANY_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_FLOW_MAPPING_STYLE PRESERVE_ALL PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use constant {YAML_ANY_SCALAR_STYLE=>0,YAML_PLAIN_SCALAR_STYLE=>1,YAML_SINGLE_QUOTED_SCALAR_STYLE=>2,YAML_DOUBLE_QUOTED_SCALAR_STYLE=>3,YAML_LITERAL_SCALAR_STYLE=>4,YAML_FOLDED_SCALAR_STYLE=>5,YAML_QUOTED_SCALAR_STYLE=>'Q',YAML_ANY_SEQUENCE_STYLE=>0,YAML_BLOCK_SEQUENCE_STYLE=>1,YAML_FLOW_SEQUENCE_STYLE=>2,YAML_ANY_MAPPING_STYLE=>0,YAML_BLOCK_MAPPING_STYLE=>1,YAML_FLOW_MAPPING_STYLE=>2,PRESERVE_ORDER=>2,PRESERVE_SCALAR_STYLE=>4,PRESERVE_FLOW_STYLE=>8,PRESERVE_ALIAS=>16,PRESERVE_ALL=>31,};my%scalar_style_to_string=(YAML_PLAIN_SCALAR_STYLE()=>':',YAML_SINGLE_QUOTED_SCALAR_STYLE()=>"'",YAML_DOUBLE_QUOTED_SCALAR_STYLE()=>'"',YAML_LITERAL_SCALAR_STYLE()=>'|',YAML_FOLDED_SCALAR_STYLE()=>'>',);sub event_to_test_suite {my ($event,$args)=@_;my$ev=$event->{name};my$string;my$content=$event->{value};my$properties='';$properties .= " &$event->{anchor}" if defined$event->{anchor};$properties .= " <$event->{tag}>" if defined$event->{tag};if ($ev eq 'document_start_event'){$string="+DOC";$string .= " ---" unless$event->{implicit}}elsif ($ev eq 'document_end_event'){$string="-DOC";$string .= " ..." unless$event->{implicit}}elsif ($ev eq 'stream_start_event'){$string="+STR"}elsif ($ev eq 'stream_end_event'){$string="-STR"}elsif ($ev eq 'mapping_start_event'){$string="+MAP";if ($event->{style}and $event->{style}eq YAML_FLOW_MAPPING_STYLE){$string .= ' {}' if$args->{flow}}$string .= $properties;if (0){}}elsif ($ev eq 'sequence_start_event'){$string="+SEQ";if ($event->{style}and $event->{style}eq YAML_FLOW_SEQUENCE_STYLE){$string .= ' []' if$args->{flow}}$string .= $properties;if (0){}}elsif ($ev eq 'mapping_end_event'){$string="-MAP"}elsif ($ev eq 'sequence_end_event'){$string="-SEQ"}elsif ($ev eq 'scalar_event'){$string='=VAL';$string .= $properties;$content =~ s/\\/\\\\/g;$content =~ s/\t/\\t/g;$content =~ s/\r/\\r/g;$content =~ s/\n/\\n/g;$content =~ s/[\b]/\\b/g;$string .= ' ' .$scalar_style_to_string{$event->{style}}.$content}elsif ($ev eq 'alias_event'){$string="=ALI *$content"}return$string}sub test_suite_to_event {my ($str)=@_;my$event={};if ($str =~ s/^\+STR//){$event->{name}='stream_start_event'}elsif ($str =~ s/^\-STR//){$event->{name}='stream_end_event'}elsif ($str =~ s/^\+DOC//){$event->{name}='document_start_event';if ($str =~ s/^ ---//){$event->{implicit}=0}else {$event->{implicit}=1}}elsif ($str =~ s/^\-DOC//){$event->{name}='document_end_event';if ($str =~ s/^ \.\.\.//){$event->{implicit}=0}else {$event->{implicit}=1}}elsif ($str =~ s/^\+SEQ//){$event->{name}='sequence_start_event';if ($str =~ s/^ \&(\S+)//){$event->{anchor}=$1}if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}}elsif ($str =~ s/^\-SEQ//){$event->{name}='sequence_end_event'}elsif ($str =~ s/^\+MAP//){$event->{name}='mapping_start_event';if ($str =~ s/^ \&(\S+)//){$event->{anchor}=$1}if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}}elsif ($str =~ s/^\-MAP//){$event->{name}='mapping_end_event'}elsif ($str =~ s/^=VAL//){$event->{name}='scalar_event';if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}if ($str =~ s/^ [:'">|]//){$event->{style}=$1}if ($str =~ s/^(.*)//){$event->{value}=$1}}elsif ($str =~ s/^=ALI//){$event->{name}='alias_event';if ($str =~ s/^ \*(.*)//){$event->{value}=$1}}else {die "Could not parse event '$str'"}return$event}1;
YAML_PP_COMMON

$fatpacked{"YAML/PP/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_CONSTRUCTOR';
  use strict;use warnings;package YAML::PP::Constructor;our$VERSION='0.031';use YAML::PP;use YAML::PP::Common qw/PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use Scalar::Util qw/reftype/;use Carp qw/croak/;use constant DEBUG=>($ENV{YAML_PP_LOAD_DEBUG}or $ENV{YAML_PP_LOAD_TRACE})? 1 : 0;use constant TRACE=>$ENV{YAML_PP_LOAD_TRACE}? 1 : 0;my%cyclic_refs=qw/allow 1 ignore 1 warn 1 fatal 1/;sub new {my ($class,%args)=@_;my$default_yaml_version=delete$args{default_yaml_version};my$duplicate_keys=delete$args{duplicate_keys};unless (defined$duplicate_keys){$duplicate_keys=0}my$preserve=delete$args{preserve}|| 0;if ($preserve==1){$preserve=PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS}my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';die "Invalid value for cyclic_refs: $cyclic_refs" unless$cyclic_refs{$cyclic_refs };my$schemas=delete$args{schemas};if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {default_yaml_version=>$default_yaml_version,schemas=>$schemas,cyclic_refs=>$cyclic_refs,preserve=>$preserve,duplicate_keys=>$duplicate_keys,},$class;$self->init;return$self}sub clone {my ($self)=@_;my$clone={schemas=>$self->{schemas},schema=>$self->{schema},default_yaml_version=>$self->{default_yaml_version},cyclic_refs=>$self->cyclic_refs,preserve=>$self->{preserve},};return bless$clone,ref$self}sub init {my ($self)=@_;$self->set_docs([]);$self->set_stack([]);$self->set_anchors({});$self->set_yaml_version($self->default_yaml_version);$self->set_schema($self->schemas->{$self->yaml_version })}sub docs {return $_[0]->{docs}}sub stack {return $_[0]->{stack}}sub anchors {return $_[0]->{anchors}}sub set_docs {$_[0]->{docs}=$_[1]}sub set_stack {$_[0]->{stack}=$_[1]}sub set_anchors {$_[0]->{anchors}=$_[1]}sub schemas {return $_[0]->{schemas}}sub schema {return $_[0]->{schema}}sub set_schema {$_[0]->{schema}=$_[1]}sub cyclic_refs {return $_[0]->{cyclic_refs}}sub set_cyclic_refs {$_[0]->{cyclic_refs}=$_[1]}sub yaml_version {return $_[0]->{yaml_version}}sub set_yaml_version {$_[0]->{yaml_version}=$_[1]}sub default_yaml_version {return $_[0]->{default_yaml_version}}sub preserve_order {return $_[0]->{preserve}& PRESERVE_ORDER}sub preserve_scalar_style {return $_[0]->{preserve}& PRESERVE_SCALAR_STYLE}sub preserve_flow_style {return $_[0]->{preserve}& PRESERVE_FLOW_STYLE}sub preserve_alias {return $_[0]->{preserve}& PRESERVE_ALIAS}sub duplicate_keys {return $_[0]->{duplicate_keys}}sub document_start_event {my ($self,$event)=@_;my$stack=$self->stack;if ($event->{version_directive}){my$version=$event->{version_directive};$version="$version->{major}.$version->{minor}";if ($self->{schemas}->{$version }){$self->set_yaml_version($version);$self->set_schema($self->schemas->{$version })}else {$self->set_yaml_version($self->default_yaml_version);$self->set_schema($self->schemas->{$self->default_yaml_version })}}my$ref=[];push @$stack,{type=>'document',ref=>$ref,data=>$ref,event=>$event }}sub document_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;$last->{type}eq 'document' or die "Expected mapping, but got $last->{type}";if (@$stack){die "Got unexpected end of document"}my$docs=$self->docs;push @$docs,$last->{ref}->[0];$self->set_anchors({});$self->set_stack([])}sub mapping_start_event {my ($self,$event)=@_;my ($data,$on_data)=$self->schema->create_mapping($self,$event);my$ref={type=>'mapping',ref=>[],data=>\$data,event=>$event,on_data=>$on_data,};my$stack=$self->stack;my$preserve_order=$self->preserve_order;my$preserve_style=$self->preserve_flow_style;my$preserve_alias=$self->preserve_alias;if (($preserve_order or $preserve_style or $preserve_alias)and not tied(%$data)){tie %$data,'YAML::PP::Preserve::Hash'}if ($preserve_style){my$t=tied %$data;$t->{style}=$event->{style}}push @$stack,$ref;if (defined(my$anchor=$event->{anchor})){if ($preserve_alias){my$t=tied %$data;unless (exists$self->anchors->{$anchor }){$t->{alias}=$anchor}}$self->anchors->{$anchor }={data=>$ref->{data}}}}sub mapping_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;my ($ref,$data)=@{$last}{qw/ref data/};$last->{type}eq 'mapping' or die "Expected mapping, but got $last->{type}";my@merge_keys;my@ref;for (my$i=0;$i < @$ref;$i += 2){my$key=$ref->[$i ];if (ref$key eq 'YAML::PP::Type::MergeKey'){my$merge=$ref->[$i + 1 ];if ((reftype($merge)|| '')eq 'HASH'){push@merge_keys,$merge}elsif ((reftype($merge)|| '')eq 'ARRAY'){for my$item (@$merge){if ((reftype($item)|| '')eq 'HASH'){push@merge_keys,$item}else {die "Expected hash for merge key"}}}else {die "Expected hash or array for merge key"}}else {push@ref,$key,$ref->[$i + 1 ]}}for my$merge (@merge_keys){for my$key (keys %$merge){unless (exists $$data->{$key }){$$data->{$key }=$merge->{$key }}}}my$on_data=$last->{on_data}|| sub {my ($self,$hash,$items)=@_;my%seen;for (my$i=0;$i < @$items;$i += 2){my ($key,$value)=@$items[$i,$i + 1 ];$key='' unless defined$key;if (ref$key){$key=$self->stringify_complex($key)}if ($seen{$key }++ and not $self->duplicate_keys){croak "Duplicate key '$key'"}$$hash->{$key }=$value}};$on_data->($self,$data,\@ref);push @{$stack->[-1]->{ref}},$$data;if (defined(my$anchor=$last->{event}->{anchor})){$self->anchors->{$anchor }->{finished}=1}return}sub sequence_start_event {my ($self,$event)=@_;my ($data,$on_data)=$self->schema->create_sequence($self,$event);my$ref={type=>'sequence',ref=>[],data=>\$data,event=>$event,on_data=>$on_data,};my$stack=$self->stack;my$preserve_style=$self->preserve_flow_style;my$preserve_alias=$self->preserve_alias;if ($preserve_style or $preserve_alias and not tied(@$data)){tie @$data,'YAML::PP::Preserve::Array',@$data;my$t=tied @$data;$t->{style}=$event->{style}}push @$stack,$ref;if (defined(my$anchor=$event->{anchor})){if ($preserve_alias){my$t=tied @$data;unless (exists$self->anchors->{$anchor }){$t->{alias}=$anchor}}$self->anchors->{$anchor }={data=>$ref->{data}}}}sub sequence_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;$last->{type}eq 'sequence' or die "Expected mapping, but got $last->{type}";my ($ref,$data)=@{$last}{qw/ref data/};my$on_data=$last->{on_data}|| sub {my ($self,$array,$items)=@_;push @$$array,@$items};$on_data->($self,$data,$ref);push @{$stack->[-1]->{ref}},$$data;if (defined(my$anchor=$last->{event}->{anchor})){my$test=$self->anchors->{$anchor };$self->anchors->{$anchor }->{finished}=1}return}sub stream_start_event {}sub stream_end_event {}sub scalar_event {my ($self,$event)=@_;DEBUG and warn "CONTENT $event->{value} ($event->{style})\n";my$value=$self->schema->load_scalar($self,$event);my$last=$self->stack->[-1];my$preserve_alias=$self->preserve_alias;my$preserve_style=$self->preserve_scalar_style;if (($preserve_style or $preserve_alias)and not ref$value){my%args=(value=>$value,tag=>$event->{tag},);if ($preserve_style){$args{style}=$event->{style}}if ($preserve_alias and defined$event->{anchor}){my$anchor=$event->{anchor};unless (exists$self->anchors->{$anchor }){$args{alias}=$event->{anchor}}}$value=YAML::PP::Preserve::Scalar->new(%args)}if (defined (my$name=$event->{anchor})){$self->anchors->{$name }={data=>\$value,finished=>1 }}push @{$last->{ref}},$value}sub alias_event {my ($self,$event)=@_;my$value;my$name=$event->{value};if (my$anchor=$self->anchors->{$name }){unless ($anchor->{finished}){my$cyclic_refs=$self->cyclic_refs;if ($cyclic_refs ne 'allow'){if ($cyclic_refs eq 'fatal'){die "Found cyclic ref for alias '$name'"}if ($cyclic_refs eq 'warn'){$anchor={data=>\undef };warn "Found cyclic ref for alias '$name'"}elsif ($cyclic_refs eq 'ignore'){$anchor={data=>\undef }}}}$value=$anchor->{data}}else {croak "No anchor defined for alias '$name'"}my$last=$self->stack->[-1];push @{$last->{ref}},$$value}sub stringify_complex {my ($self,$data)=@_;return$data if (ref$data eq 'YAML::PP::Preserve::Scalar' and ($self->preserve_scalar_style or $self->preserve_alias));require Data::Dumper;local$Data::Dumper::Quotekeys=0;local$Data::Dumper::Terse=1;local$Data::Dumper::Indent=0;local$Data::Dumper::Useqq=0;local$Data::Dumper::Sortkeys=1;my$string=Data::Dumper->Dump([$data],['data']);$string =~ s/^\$data = //;return$string}1;
YAML_PP_CONSTRUCTOR

$fatpacked{"YAML/PP/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_DUMPER';
  use strict;use warnings;package YAML::PP::Dumper;our$VERSION='0.031';use Scalar::Util qw/blessed refaddr reftype/;use YAML::PP;use YAML::PP::Emitter;use YAML::PP::Representer;use YAML::PP::Writer;use YAML::PP::Writer::File;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_ANY_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE/;sub new {my ($class,%args)=@_;my$header=delete$args{header};$header=1 unless defined$header;my$footer=delete$args{footer};$footer=0 unless defined$footer;my$version_directive=delete$args{version_directive};my$preserve=delete$args{preserve};my$schema=delete$args{schema}|| YAML::PP->default_schema(boolean=>'perl',);my$emitter=delete$args{emitter}|| YAML::PP::Emitter->new;unless (blessed($emitter)){$emitter=YAML::PP::Emitter->new(%$emitter)}if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {representer=>YAML::PP::Representer->new(schema=>$schema,preserve=>$preserve,),version_directive=>$version_directive,emitter=>$emitter,seen=>{},anchors=>{},anchor_num=>0,header=>$header,footer=>$footer,},$class;return$self}sub clone {my ($self)=@_;my$clone={representer=>$self->representer->clone,emitter=>$self->emitter->clone,version_directive=>$self->version_directive,seen=>{},anchors=>{},anchor_num=>0,header=>$self->header,footer=>$self->footer,};return bless$clone,ref$self}sub init {my ($self)=@_;$self->{seen}={};$self->{anchors}={};$self->{anchor_num}=0}sub emitter {return $_[0]->{emitter}}sub representer {return $_[0]->{representer}}sub set_representer {$_[0]->{representer}=$_[1]}sub header {return $_[0]->{header}}sub footer {return $_[0]->{footer}}sub version_directive {return $_[0]->{version_directive}}sub dump {my ($self,@docs)=@_;$self->emitter->init;$self->emitter->stream_start_event({});for my$i (0 .. $#docs){my$header_implicit=($i==0 and not $self->header);my%args=(implicit=>$header_implicit,);if ($self->version_directive){my ($major,$minor)=split m/\./,$self->representer->schema->yaml_version;$args{version_directive}={major=>$major,minor=>$minor }}$self->emitter->document_start_event(\%args);$self->init;$self->check_references($docs[$i ]);$self->dump_node($docs[$i ]);my$footer_implicit=(not $self->footer);$self->emitter->document_end_event({implicit=>$footer_implicit })}$self->emitter->stream_end_event({});my$output=$self->emitter->writer->output;$self->emitter->finish;return$output}sub dump_node {my ($self,$value)=@_;my$node={value=>$value,};if (ref$value){my$seen=$self->{seen};my$refaddr=refaddr$value;if ($seen->{$refaddr }and $seen->{$refaddr }> 1){my$anchor=$self->{anchors}->{$refaddr };unless (defined$anchor){if ($self->representer->preserve_alias){if (ref$node->{value}eq 'YAML::PP::Preserve::Scalar'){if (defined$node->{value}->alias){$node->{anchor}=$node->{value}->alias;$self->{anchors}->{$refaddr }=$node->{value}->alias}}elsif (reftype$node->{value}eq 'HASH'){if (my$tied=tied %{$node->{value}}){if (defined$tied->{alias}){$node->{anchor}=$tied->{alias};$self->{anchors}->{$refaddr }=$node->{anchor}}}}elsif (reftype$node->{value}eq 'ARRAY'){if (my$tied=tied @{$node->{value}}){if (defined$tied->{alias}){$node->{anchor}=$tied->{alias};$self->{anchors}->{$refaddr }=$node->{anchor}}}}}unless (defined$node->{anchor}){my$num=++$self->{anchor_num};$self->{anchors}->{$refaddr }=$num;$node->{anchor}=$num}}else {$node->{value}=$anchor;$self->emit_node([alias=>$node ]);return}}}$node=$self->representer->represent_node($node);$self->emit_node($node)}sub emit_node {my ($self,$item)=@_;my ($type,$node,%args)=@$item;if ($type eq 'alias'){$self->emitter->alias_event({value=>$node->{value}});return}if ($type eq 'mapping'){my$style=$args{style}|| YAML_BLOCK_MAPPING_STYLE;if ($node->{items}and @{$node->{items}}==0){}$self->emitter->mapping_start_event({anchor=>$node->{anchor},style=>$style,tag=>$node->{tag},});for (@{$node->{items}}){$self->dump_node($_)}$self->emitter->mapping_end_event;return}if ($type eq 'sequence'){my$style=$args{style}|| YAML_BLOCK_SEQUENCE_STYLE;if (@{$node->{items}}==0){}$self->emitter->sequence_start_event({anchor=>$node->{anchor},style=>$style,tag=>$node->{tag},});for (@{$node->{items}}){$self->dump_node($_)}$self->emitter->sequence_end_event;return}$self->emitter->scalar_event({value=>$node->{items}->[0],style=>$node->{style},anchor=>$node->{anchor},tag=>$node->{tag},})}sub dump_string {my ($self,@docs)=@_;my$writer=YAML::PP::Writer->new;$self->emitter->set_writer($writer);my$output=$self->dump(@docs);return$output}sub dump_file {my ($self,$file,@docs)=@_;my$writer=YAML::PP::Writer::File->new(output=>$file);$self->emitter->set_writer($writer);my$output=$self->dump(@docs);return$output}my%_reftypes=(HASH=>1,ARRAY=>1,Regexp=>1,REGEXP=>1,CODE=>1,SCALAR=>1,REF=>1,GLOB=>1,);sub check_references {my ($self,$doc)=@_;my$reftype=reftype$doc or return;my$seen=$self->{seen};if ($reftype eq 'SCALAR' and ref$doc eq $self->representer->schema->bool_class){if (ref$doc eq 'boolean' or ref$doc eq 'JSON::PP::Boolean'){return}}if (++$seen->{refaddr$doc }> 1){return}unless ($_reftypes{$reftype }){die sprintf "Reference %s not implemented",$reftype}if ($reftype eq 'HASH'){$self->check_references($doc->{$_ })for keys %$doc}elsif ($reftype eq 'ARRAY'){$self->check_references($_)for @$doc}elsif ($reftype eq 'REF'){$self->check_references($$doc)}}1;
YAML_PP_DUMPER

$fatpacked{"YAML/PP/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EMITTER';
  use strict;use warnings;package YAML::PP::Emitter;our$VERSION='0.031';use Data::Dumper;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE/;use constant DEBUG=>$ENV{YAML_PP_EMIT_DEBUG}? 1 : 0;use constant DEFAULT_WIDTH=>80;sub new {my ($class,%args)=@_;my$self=bless {indent=>$args{indent}|| 2,writer=>$args{writer},width=>$args{width}|| DEFAULT_WIDTH,},$class;$self->init;return$self}sub clone {my ($self)=@_;my$clone={indent=>$self->indent,};return bless$clone,ref$self}sub event_stack {return $_[0]->{event_stack}}sub set_event_stack {$_[0]->{event_stack}=$_[1]}sub indent {return $_[0]->{indent}}sub width {return $_[0]->{width}}sub line {return $_[0]->{line}}sub column {return $_[0]->{column}}sub set_indent {$_[0]->{indent}=$_[1]}sub writer {$_[0]->{writer}}sub set_writer {$_[0]->{writer}=$_[1]}sub tagmap {return $_[0]->{tagmap}}sub set_tagmap {$_[0]->{tagmap}=$_[1]}sub init {my ($self)=@_;unless ($self->writer){$self->set_writer(YAML::PP::Writer->new)}$self->set_tagmap({'tag:yaml.org,2002:'=>'!!',});$self->{open_ended}=0;$self->{line}=0;$self->{column}=0;$self->writer->init}sub mapping_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_start_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$new_indent=$indent;my$yaml='';my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('map',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$flow=$last->{flow}|| 0;$flow++ if ($info->{style}|| 0)eq YAML_FLOW_MAPPING_STYLE;my$newline=0;if ($flow > 1){if ($last->{type}eq 'SEQ'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "["}else {$yaml .= ","}}elsif ($last->{type}eq 'MAP'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "{"}else {$yaml .= ","}}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": "}if ($props){$yaml .= " $props "}$new_indent .= ' ' x $self->indent}else {if ($last->{type}eq 'DOC'){$newline=$last->{newline}}else {if ($last->{newline}){$yaml .= "\n";$last->{column}=0}if ($last->{type}eq 'MAPVALUE'){$new_indent .= ' ' x $self->indent;$newline=1}else {$new_indent=$indent;if (not $props and $self->indent==1){$new_indent .= ' ' x 2}else {$new_indent .= ' ' x $self->indent}if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'SEQ'){$yaml .= '-'}elsif ($last->{type}eq 'MAP'){$yaml .= "?";$last->{type}='COMPLEX'}elsif ($last->{type}eq 'COMPLEXVALUE'){$yaml .= ":"}else {die "Should not happen ($last->{type} in mapping_start)"}$last->{column}=1}$last->{newline}=0}if ($props){$yaml .= $last->{column}? ' ' : $indent;$yaml .= $props;$newline=1}}$self->_write($yaml);my$new_info={index=>0,indent=>$new_indent,info=>$info,newline=>$newline,column=>$self->column,flow=>$flow,};$new_info->{type}='MAP';push @{$stack},$new_info;$last->{index}++;$self->{open_ended}=0}sub mapping_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_end_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=pop @{$stack};if ($last->{index}==0){my$indent=$last->{indent};my$zero_indent=$last->{zero_indent};if ($last->{zero_indent}){$indent .= ' ' x $self->indent}if ($self->column){$self->_write(" {}\n")}else {$self->_write("$indent\{}\n")}}elsif ($last->{flow}){my$yaml="}";if ($last->{flow}==1){$yaml .= "\n"}$self->_write("$yaml")}$last=$stack->[-1];$last->{column}=$self->column;if ($last->{type}eq 'SEQ'){}elsif ($last->{type}eq 'MAP'){$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'COMPLEX'){$last->{type}='COMPLEXVALUE'}elsif ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP'}}sub sequence_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_start_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$new_indent=$indent;my$yaml='';my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('seq',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$flow=$last->{flow}|| 0;$flow++ if$flow or ($info->{style}|| 0)eq YAML_FLOW_SEQUENCE_STYLE;my$newline=0;my$zero_indent=0;if ($flow > 1){if ($last->{type}eq 'SEQ'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "["}else {$yaml .= ","}}elsif ($last->{type}eq 'MAP'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "{"}else {$yaml .= ","}}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": "}if ($props){$yaml .= " $props "}$new_indent .= ' ' x $self->indent}else {if ($last->{type}eq 'DOC'){$newline=$last->{newline}}else {if ($last->{newline}){$yaml .= "\n";$last->{column}=0}if ($last->{type}eq 'MAPVALUE'){$zero_indent=1;$newline=1}else {if (not $props and $self->indent==1){$new_indent .= ' ' x 2}else {$new_indent .= ' ' x $self->indent}if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'SEQ'){$yaml .= "-"}elsif ($last->{type}eq 'MAP'){$last->{type}='COMPLEX';$zero_indent=1;$yaml .= "?"}elsif ($last->{type}eq 'COMPLEXVALUE'){$yaml .= ":";$zero_indent=1}else {die "Should not happen ($last->{type} in sequence_start)"}$last->{column}=1}$last->{newline}=0}if ($props){$yaml .= $last->{column}? ' ' : $indent;$yaml .= $props;$newline=1}}$self->_write($yaml);$last->{index}++;my$new_info={index=>0,indent=>$new_indent,info=>$info,zero_indent=>$zero_indent,newline=>$newline,column=>$self->column,flow=>$flow,};$new_info->{type}='SEQ';push @{$stack},$new_info;$self->{open_ended}=0}sub sequence_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_end_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=pop @{$stack};if ($last->{index}==0){my$indent=$last->{indent};my$zero_indent=$last->{zero_indent};if ($last->{zero_indent}){$indent .= ' ' x $self->indent}my$yaml .= $self->column ? ' ' : $indent;$yaml .= "[]";if ($last->{flow}< 2){$yaml .= "\n"}$self->_write($yaml)}elsif ($last->{flow}){my$yaml="]";if ($last->{flow}==1){$yaml .= "\n"}$self->_write($yaml)}$last=$stack->[-1];$last->{column}=$self->column;if ($last->{type}eq 'SEQ'){}elsif ($last->{type}eq 'MAP'){$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'COMPLEX'){$last->{type}='COMPLEXVALUE'}elsif ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP'}}my%forbidden_first=(qw/! 1 & 1 * 1 { 1 } 1 [ 1 ] 1 | 1 > 1 @ 1 ` 1 " 1 ' 1/,'#'=>1,'%'=>1,','=>1," "=>1);my%forbidden_first_plus_space=(qw/? 1 - 1 : 1/);my%control=("\x00"=>'\0',"\x01"=>'\x01',"\x02"=>'\x02',"\x03"=>'\x03',"\x04"=>'\x04',"\x05"=>'\x05',"\x06"=>'\x06',"\x07"=>'\a',"\x08"=>'\b',"\x0b"=>'\v',"\x0c"=>'\f',"\x0e"=>'\x0e',"\x0f"=>'\x0f',"\x10"=>'\x10',"\x11"=>'\x11',"\x12"=>'\x12',"\x13"=>'\x13',"\x14"=>'\x14',"\x15"=>'\x15',"\x16"=>'\x16',"\x17"=>'\x17',"\x18"=>'\x18',"\x19"=>'\x19',"\x1a"=>'\x1a',"\x1b"=>'\e',"\x1c"=>'\x1c',"\x1d"=>'\x1d',"\x1e"=>'\x1e',"\x1f"=>'\x1f',"\x7f"=>'\x7f',"\x80"=>'\x80',"\x81"=>'\x81',"\x82"=>'\x82',"\x83"=>'\x83',"\x84"=>'\x84',"\x86"=>'\x86',"\x87"=>'\x87',"\x88"=>'\x88',"\x89"=>'\x89',"\x8a"=>'\x8a',"\x8b"=>'\x8b',"\x8c"=>'\x8c',"\x8d"=>'\x8d',"\x8e"=>'\x8e',"\x8f"=>'\x8f',"\x90"=>'\x90',"\x91"=>'\x91',"\x92"=>'\x92',"\x93"=>'\x93',"\x94"=>'\x94',"\x95"=>'\x95',"\x96"=>'\x96',"\x97"=>'\x97',"\x98"=>'\x98',"\x99"=>'\x99',"\x9a"=>'\x9a',"\x9b"=>'\x9b',"\x9c"=>'\x9c',"\x9d"=>'\x9d',"\x9e"=>'\x9e',"\x9f"=>'\x9f',"\x{2029}"=>'\P',"\x{2028}"=>'\L',"\x85"=>'\N',"\xa0"=>'\_',);my$control_re='\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x84\x86-\x9f\x{d800}-\x{dfff}\x{fffe}\x{ffff}\x{2028}\x{2029}\x85\xa0';my%to_escape=("\n"=>'\n',"\t"=>'\t',"\r"=>'\r','\\'=>'\\\\','"'=>'\\"',%control,);my$escape_re=$control_re .'\n\t\r';my$escape_re_without_lb=$control_re .'\t\r';sub scalar_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ scalar_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$value=$info->{value};my$flow=$last->{flow};my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('scalar',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$style=$info->{style};DEBUG and local$Data::Dumper::Useqq=1;$value='' unless defined$value;my$first=substr($value,0,1);if ($value eq ''){if ($flow and $last->{type}ne 'MAPVALUE' and $last->{type}ne 'MAP'){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif (not $style){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}elsif ($value =~ m/[$control_re]/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}$style ||= YAML_PLAIN_SCALAR_STYLE;if ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE){if ($value =~ m/ \n/ or $value =~ m/\n / or $value =~ m/^\n/ or $value =~ m/\n$/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value eq "\n"){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}}elsif ($style==YAML_LITERAL_SCALAR_STYLE or $style==YAML_FOLDED_SCALAR_STYLE){if ($value eq ''){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($flow){if ($value =~ tr/\n//){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}else {$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}}elsif ($style==YAML_PLAIN_SCALAR_STYLE){if (not length$value){}elsif ($value =~ m/[$escape_re_without_lb]/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value eq "\n"){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value !~ tr/ //c){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value !~ tr/ \n//c){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value =~ tr/\n//){$style=$flow ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_LITERAL_SCALAR_STYLE}elsif ($forbidden_first{$first }){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($flow and $value =~ tr/,[]{}//){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif (substr($value,0,3)=~ m/^(?:---|\.\.\.)/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/: /){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/ #/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/[: \t]\z/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/[^\x20-\x3A\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($forbidden_first_plus_space{$first }){if (length ($value)==1 or substr($value,1,1)=~ m/^\s/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}}if ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE and not $info->{style}){if ($value =~ tr/'// and $value !~ tr/"//){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}}my$open_ended=0;if ($style==YAML_PLAIN_SCALAR_STYLE){$value =~ s/\n/\n\n/g}elsif ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE){my$new_indent=$last->{indent}.(' ' x $self->indent);$value =~ s/(\n+)/"\n" x (1 + (length $1))/eg;my@lines=split m/\n/,$value,-1;if (@lines > 1){for my$line (@lines[1 .. $#lines]){$line=$new_indent .$line if length$line}}$value=join "\n",@lines;$value =~ s/'/''/g;$value="'" .$value ."'"}elsif ($style==YAML_LITERAL_SCALAR_STYLE){DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value],['value']);my$indicators='';if ($value =~ m/\A\n* +/){$indicators .= $self->indent}my$indent=$indent .' ' x $self->indent;if ($value !~ m/\n\z/){$indicators .= '-';$value .= "\n"}elsif ($value =~ m/(\n|\A)\n\z/){$indicators .= '+';$open_ended=1}$value =~ s/^(?=.)/$indent/gm;$value="|$indicators\n$value"}elsif ($style==YAML_FOLDED_SCALAR_STYLE){DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value],['value']);my@lines=split /\n/,$value,-1;DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\@lines],['lines']);my$eol=0;my$indicators='';if ($value =~ m/\A\n* +/){$indicators .= $self->indent}my$indent=$indent .' ' x $self->indent;if ($lines[-1]eq ''){pop@lines;$eol=1}else {$indicators .= '-'}$value=">$indicators\n";for my$i (0 .. $#lines){my$line=$lines[$i ];if (length$line){$value .= "$indent$line\n"}if ($i!=$#lines){$value .= "\n"}}}else {$value =~ s/([$escape_re"\\])/$to_escape{ $1 } || sprintf '\\u%04x', ord($1)/eg;$value='"' .$value .'"'}DEBUG and warn __PACKAGE__.':'.__LINE__.": (@$stack)\n";my$yaml='';my$pvalue=$props;if ($props and length$value){$pvalue .= " $value"}elsif (length$value){$pvalue .= $value}my$multiline=($style==YAML_LITERAL_SCALAR_STYLE or $style==YAML_FOLDED_SCALAR_STYLE);my$newline=0;if ($flow){$indent=0;if ($props and not length$value){$pvalue .= ' '}if ($last->{type}eq 'SEQ'){if ($last->{index}==0){if ($self->column){$yaml .= ' '}$yaml .= "["}else {$yaml .= ", "}}elsif ($last->{type}eq 'MAP'){if ($last->{index}==0){if ($self->column){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ", "}$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": ";$last->{type}='MAP'}if ($self->column + length$pvalue > $self->width){$yaml .= "\n";$yaml .= $last->{indent};$yaml .= ' ' x $self->indent}$yaml .= $pvalue}else {if ($last->{type}eq 'MAP' or $last->{type}eq 'SEQ'){if ($last->{index}==0 and $last->{newline}){$yaml .= "\n";$last->{column}=0;$last->{newline}=0}}my$space=' ';if ($last->{type}eq 'MAP'){if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($props and not length$value){$pvalue .= ' '}my$new_event='MAPVALUE';$last->{type}=$new_event;if ($multiline){$yaml .= "? ";$new_event='COMPLEXVALUE';$last->{type}=$new_event}if (not $multiline){$pvalue .= ":"}}else {if ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'DOC'){}else {if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP';$yaml .= ":"}elsif ($last->{type}eq 'SEQ'){$yaml .= "-"}else {die "Should not happen ($last->{type} in scalar_event)"}$last->{column}=1}if (length$pvalue){if ($last->{column}){$pvalue="$space$pvalue"}}if (not $multiline){$pvalue .= "\n"}}$yaml .= $pvalue}$last->{index}++;$last->{newline}=$newline;$self->_write($yaml);$last->{column}=$self->column;$self->{open_ended}=$open_ended}sub alias_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ alias_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$flow=$last->{flow};my$alias='*' .$info->{value};my$yaml='';if ($last->{type}eq 'MAP' or $last->{type}eq 'SEQ'){if ($last->{index}==0 and $last->{newline}){$yaml .= "\n";$last->{column}=0;$last->{newline}=0}}$yaml .= $last->{column}? ' ' : $indent;if ($flow){my$space='';if ($last->{type}eq 'SEQ'){if ($last->{index}==0){if ($flow==1){$yaml .= ' '}$yaml .= "["}else {$yaml .= ", "}}elsif ($last->{type}eq 'MAP'){if ($last->{index}==0){if ($flow==1){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ", "}$last->{type}='MAPVALUE';$space=' '}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die 23;if ($flow==1){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ": "}$last->{type}='MAP'}$yaml .= "$alias$space"}else {if ($last->{type}eq 'MAP'){$yaml .= "$alias :";$last->{type}='MAPVALUE'}else {if ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'DOC'){}else {if ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP';$yaml .= ": "}elsif ($last->{type}eq 'COMPLEX'){$yaml .= ": "}elsif ($last->{type}eq 'SEQ'){$yaml .= "- "}else {die "Unexpected"}}$yaml .= "$alias\n"}}$self->_write("$yaml");$last->{index}++;$last->{column}=$self->column;$self->{open_ended}=0}sub document_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_start_event\n";my ($self,$info)=@_;my$newline=0;my$implicit=$info->{implicit};if ($info->{version_directive}){if ($self->{open_ended}){$self->_write("...\n")}$self->_write("%YAML $info->{version_directive}->{major}.$info->{version_directive}->{minor}\n");$self->{open_ended}=0;$implicit=0}unless ($implicit){$newline=1;$self->_write("---")}$self->set_event_stack([{type=>'DOC',index=>0,indent=>'',info=>$info,newline=>$newline,column=>$self->column,}])}sub document_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_end_event\n";my ($self,$info)=@_;$self->set_event_stack([]);if ($self->{open_ended}or not $info->{implicit}){$self->_write("...\n");$self->{open_ended}=0}else {$self->{open_ended}=1}}sub stream_start_event {}sub stream_end_event {}sub emit_tag {my ($self,$type,$tag)=@_;my$map=$self->tagmap;for my$key (sort keys %$map){if ($tag =~ m/^\Q$key\E(.*)/){$tag=$map->{$key }.$1;return$tag}}if ($tag =~ m/^(!.*)/){$tag="$1"}else {$tag="!<$tag>"}return$tag}sub finish {my ($self)=@_;$self->writer->finish}sub _write {my ($self,$yaml)=@_;return unless length$yaml;my@lines=split m/\n/,$yaml,-1;my$newlines=@lines - 1;$self->{line}+= $newlines;if (length$lines[-1]){if ($newlines){$self->{column}=length$lines[-1]}else {$self->{column}+= length$lines[-1]}}else {$self->{column}=0}$self->writer->write($yaml)}1;
YAML_PP_EMITTER

$fatpacked{"YAML/PP/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EXCEPTION';
  use strict;use warnings;package YAML::PP::Exception;our$VERSION='0.031';use overload '""'=>\&to_string;sub new {my ($class,%args)=@_;my$self=bless {line=>$args{line},msg=>$args{msg},next=>$args{next},where=>$args{where},yaml=>$args{yaml},got=>$args{got},expected=>$args{expected},column=>$args{column},},$class;return$self}sub to_string {my ($self)=@_;my$next=$self->{next};my$line=$self->{line};my$column=$self->{column};my$yaml='';for my$token (@$next){last if$token->{name}eq 'EOL';$yaml .= $token->{value}}$column='???' unless defined$column;my$remaining_yaml=$self->{yaml};$remaining_yaml='' unless defined$remaining_yaml;$yaml .= $remaining_yaml;{local $@;require Data::Dumper;local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;$yaml=Data::Dumper->Dump([$yaml],['yaml']);chomp$yaml}my$lines=5;my@fields;if ($self->{got}and $self->{expected}){$lines=6;$line=$self->{got}->{line};$column=$self->{got}->{column}+ 1;@fields=("Line"=>$line,"Column"=>$column,"Expected",join(" ",@{$self->{expected}}),"Got",$self->{got}->{name},"Where",$self->{where},"YAML",$yaml,)}else {@fields=("Line"=>$line,"Column"=>$column,"Message",$self->{msg},"Where",$self->{where},"YAML",$yaml,)}my$fmt=join "\n",("%-10s: %s")x $lines;my$string=sprintf$fmt,@fields;return$string}1;
YAML_PP_EXCEPTION

$fatpacked{"YAML/PP/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_GRAMMAR';
  use strict;use warnings;package YAML::PP::Grammar;our$VERSION='0.031';use base 'Exporter';our@EXPORT_OK=qw/$GRAMMAR/;our$GRAMMAR={};$GRAMMAR={'DIRECTIVE'=>{'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_doc_start_explicit' },'EOL'=>{'new'=>'DIRECTIVE' },'RESERVED_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_reserved_directive' },'TAG_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_tag_directive' },'YAML_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_set_yaml_version_directive' }},'DOCUMENT_END'=>{'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'DOCUMENT_END' }},'END_FLOW'=>{'EOL'=>{'match'=>'cb_end_outer_flow','return'=>1 }},'FLOWMAP'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP_ANCHOR' },'EOL'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'match'=>'cb_anchor' },'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'DEFAULT'=>{'new'=>'FLOWMAP_CONTENT' },'EOL'=>{'new'=>'FLOWMAP' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap','return'=>1 },'TAG'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP_TAG' },'EOL'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'match'=>'cb_tag' },'WS'=>{'new'=>'FLOWMAP' }},'FLOWMAP_CONTENT'=>{'ALIAS'=>{'match'=>'cb_send_alias','return'=>1 },'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'match'=>'cb_flowkey_plain','return'=>1 },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'match'=>'cb_flowkey_quoted','return'=>1 },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'FLOWMAP_EMPTYKEY'=>{'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 }},'FLOWMAP_EXPLICIT_KEY'=>{'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'FLOWMAP_EXPLICIT_KEY' },'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 },'WS'=>{'new'=>'FLOWMAP_EXPLICIT_KEY' }},'FLOWMAP_PROPS'=>{'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_END'=>{'match'=>'cb_end_empty_flowmap_key_value','return'=>1 },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_key_value','return'=>1 },'PLAIN'=>{'match'=>'cb_flowkey_plain','return'=>1 },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'match'=>'cb_flowkey_quoted','return'=>1 },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'FLOWSEQ'=>{'ALIAS'=>{'match'=>'cb_send_flow_alias','new'=>'FLOWSEQ_NEXT' },'COLON'=>{'EOL'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','new'=>'FLOWSEQ_NEXT' },'QUOTED'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','new'=>'FLOWSEQ_NEXT' }},'FLOWSEQ_EMPTY'=>{'FLOWSEQ_END'=>{'match'=>'cb_empty_flowseq_end','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowseq_comma','return'=>1 }},'FLOWSEQ_MAYBE_KEY'=>{'COLON'=>{'DEFAULT'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'EOL'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'DEFAULT'=>{'new'=>'FLOWSEQ_NEXT' },'WS'=>{'new'=>'FLOWSEQ_MAYBE_KEY' }},'FLOWSEQ_NEXT'=>{'EOL'=>{'new'=>'FLOWSEQ_NEXT' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_flow_comma','return'=>1 },'WS'=>{'new'=>'FLOWSEQ_NEXT' }},'FLOWSEQ_PROPS'=>{'COLON'=>{'EOL'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_insert_empty_implicit_flowseq_map','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_END'=>{'match'=>'cb_empty_flowseq_end','return'=>1 },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flowseq_comma','return'=>1 },'PLAIN'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','new'=>'FLOWSEQ_NEXT' },'QUOTED'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_MAYBE_KEY' },'EOL'=>{'match'=>'cb_send_scalar','new'=>'FLOWSEQ_NEXT' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','new'=>'FLOWSEQ_NEXT' }},'FULLMAPVALUE_INLINE'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG' },'WS'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' }},'match'=>'cb_tag' }},'FULLNODE'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG' },'WS'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_ANCHOR'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_ANCHOR' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_TAG'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_TAG' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_TAG_ANCHOR'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_TAG_ANCHOR' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'NEWFLOWMAP'=>{'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'NEWFLOWMAP' },'QUESTION'=>{'match'=>'cb_flow_question','new'=>'FLOWMAP_EXPLICIT_KEY' },'WS'=>{'new'=>'NEWFLOWMAP' }},'NEWFLOWMAP_ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' }},'NEWFLOWMAP_ANCHOR_SPC'=>{'DEFAULT'=>{'new'=>'FLOWMAP_PROPS' },'EOL'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' },'TAG'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' },'EOL'=>{'new'=>'FLOWMAP_PROPS' },'WS'=>{'new'=>'FLOWMAP_PROPS' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWMAP_ANCHOR_SPC' }},'NEWFLOWMAP_TAG'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' }},'NEWFLOWMAP_TAG_SPC'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWMAP_EMPTYKEY' },'EOL'=>{'new'=>'FLOWMAP_PROPS' },'WS'=>{'new'=>'FLOWMAP_PROPS' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWMAP_PROPS' },'EOL'=>{'new'=>'NEWFLOWMAP_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWMAP_TAG_SPC' }},'NEWFLOWSEQ'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ_ANCHOR' },'EOL'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWSEQ' },'EOL'=>{'new'=>'NEWFLOWSEQ' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'TAG'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ_TAG' },'EOL'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWSEQ' }},'NEWFLOWSEQ_ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' }},'NEWFLOWSEQ_ANCHOR_SPC'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_PROPS' },'EOL'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' },'TAG'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' },'EOL'=>{'new'=>'FLOWSEQ_PROPS' },'WS'=>{'new'=>'FLOWSEQ_PROPS' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWSEQ_ANCHOR_SPC' }},'NEWFLOWSEQ_TAG'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' }},'NEWFLOWSEQ_TAG_SPC'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWSEQ_EMPTY' },'EOL'=>{'new'=>'FLOWSEQ_PROPS' },'WS'=>{'new'=>'FLOWSEQ_PROPS' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWSEQ_PROPS' },'EOL'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' },'WS'=>{'new'=>'NEWFLOWSEQ_TAG_SPC' }},'NODETYPE_COMPLEX'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_complexcolon' },'DEFAULT'=>{'match'=>'cb_empty_complexvalue','new'=>'NODETYPE_MAP' },'EOL'=>{'new'=>'NODETYPE_COMPLEX' }},'NODETYPE_FLOWMAP'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP' },'EOL'=>{'new'=>'NODETYPE_FLOWMAP' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_flow_comma','new'=>'NEWFLOWMAP' },'WS'=>{'new'=>'NODETYPE_FLOWMAP' }},'NODETYPE_FLOWMAPVALUE'=>{'COLON'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR' },'match'=>'cb_flow_colon' },'EOL'=>{'new'=>'NODETYPE_FLOWMAPVALUE' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap_empty','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_value','return'=>1 },'WS'=>{'new'=>'NODETYPE_FLOWMAPVALUE' }},'NODETYPE_FLOWSEQ'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ' },'EOL'=>{'new'=>'NODETYPE_FLOWSEQ' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'WS'=>{'new'=>'NODETYPE_FLOWSEQ' }},'NODETYPE_MAP'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'RULE_MAPKEY' },'TAG'=>{'WS'=>{'new'=>'RULE_MAPKEY' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_MAPKEY' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'RULE_MAPKEY' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_MAPKEY' }},'match'=>'cb_tag' }},'NODETYPE_MAPVALUE_INLINE'=>{'ALIAS'=>{'EOL'=>{},'match'=>'cb_send_alias' },'BLOCK_SCALAR'=>{'EOL'=>{},'match'=>'cb_send_block_scalar' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'EOL'=>{},'match'=>'cb_send_plain_multi' },'QUOTED'=>{'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'EOL'=>{},'match'=>'cb_quoted_multiline' }},'NODETYPE_NODE'=>{'DASH'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_seqstart' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'NODETYPE_SCALAR_OR_MAP'=>{'ALIAS'=>{'EOL'=>{'match'=>'cb_send_alias_from_stack' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map_alias' }},'match'=>'cb_alias' },'BLOCK_SCALAR'=>{'EOL'=>{},'match'=>'cb_send_block_scalar' },'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_empty_map' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' }},'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'EOL'=>{},'match'=>'cb_send_plain_multi' },'QUESTION'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_questionstart' },'QUOTED'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' }},'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'EOL'=>{},'match'=>'cb_quoted_multiline' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }},'NODETYPE_SEQ'=>{'DASH'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_seqitem' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'NODETYPE_SEQ' }},'RULE_FLOWSCALAR'=>{'ALIAS'=>{'match'=>'cb_send_alias','return'=>1 },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap_empty','return'=>1 },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flow_mapkey','return'=>1 },'PLAIN'=>{'DEFAULT'=>{'match'=>'cb_send_scalar','return'=>1 },'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'DEFAULT'=>{'match'=>'cb_send_scalar','return'=>1 },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'match'=>'cb_send_scalar','return'=>1 },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'RULE_FULLFLOWSCALAR'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'TAG'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' },'match'=>'cb_tag' }},'RULE_FULLFLOWSCALAR_ANCHOR'=>{'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'TAG'=>{'EOL'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FLOWSCALAR' },'match'=>'cb_tag' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' }},'RULE_FULLFLOWSCALAR_TAG'=>{'ANCHOR'=>{'EOL'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FLOWSCALAR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' }},'RULE_MAPKEY'=>{'ALIAS'=>{'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }}},'match'=>'cb_send_alias' },'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_empty_mapkey' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'RULE_MAPKEY' },'PLAIN'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_send_mapkey' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_send_mapkey' }},'match'=>'cb_mapkey' },'QUESTION'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_question' },'QUOTED'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }},'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }}},'match'=>'cb_take_quoted_key' }},'STREAM'=>{'DEFAULT'=>{'match'=>'cb_doc_start_implicit','new'=>'FULLNODE' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document_empty' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_doc_start_explicit' },'EOL'=>{'new'=>'STREAM' },'RESERVED_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_reserved_directive' },'TAG_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_tag_directive' },'YAML_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_set_yaml_version_directive' }}};1;
YAML_PP_GRAMMAR

$fatpacked{"YAML/PP/Highlight.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_HIGHLIGHT';
  use strict;use warnings;package YAML::PP::Highlight;our$VERSION='0.031';our@EXPORT_OK=qw/Dump/;use base 'Exporter';use YAML::PP;use YAML::PP::Parser;use Encode;sub Dump {my (@docs)=@_;require YAML::PP::Schema::Perl;my$yp=YAML::PP->new(schema=>[qw/+ Perl/]);my$yaml=$yp->dump_string(@docs);my ($error,$tokens)=YAML::PP::Parser->yaml_to_tokens(string=>$yaml);my$highlighted=YAML::PP::Highlight->ansicolored($tokens);encode_utf8$highlighted}my%ansicolors=(ANCHOR=>[qw/green/],ALIAS=>[qw/bold green/],TAG=>[qw/bold blue/],INDENT=>[qw/white on_grey3/],COMMENT=>[qw/grey12/],COLON=>[qw/bold magenta/],DASH=>[qw/bold magenta/],QUESTION=>[qw/bold magenta/],YAML_DIRECTIVE=>[qw/cyan/],TAG_DIRECTIVE=>[qw/bold cyan/],SINGLEQUOTE=>[qw/bold green/],SINGLEQUOTED=>[qw/green/],SINGLEQUOTED_LINE=>[qw/green/],DOUBLEQUOTE=>[qw/bold green/],DOUBLEQUOTED=>[qw/green/],DOUBLEQUOTED_LINE=>[qw/green/],LITERAL=>[qw/bold yellow/],FOLDED=>[qw/bold yellow/],DOC_START=>[qw/bold/],DOC_END=>[qw/bold/],BLOCK_SCALAR_CONTENT=>[qw/yellow/],TAB=>[qw/on_blue/],ERROR=>[qw/bold red/],EOL=>[qw/grey12/],TRAILING_SPACE=>[qw/on_grey6/],FLOWSEQ_START=>[qw/bold magenta/],FLOWSEQ_END=>[qw/bold magenta/],FLOWMAP_START=>[qw/bold magenta/],FLOWMAP_END=>[qw/bold magenta/],FLOW_COMMA=>[qw/bold magenta/],PLAINKEY=>[qw/bright_blue/],);sub ansicolored {my ($class,$tokens,%args)=@_;my$expand_tabs=$args{expand_tabs};$expand_tabs=1 unless defined$expand_tabs;require Term::ANSIColor;local$Term::ANSIColor::EACHLINE="\n";my$ansi='';my$highlighted='';my@list=$class->transform($tokens);for my$token (@list){my$name=$token->{name};my$str=$token->{value};my$color=$ansicolors{$name };if ($color){$str=Term::ANSIColor::colored($color,$str)}$highlighted .= $str}if ($expand_tabs){$highlighted =~ s/\t/' ' x 8/eg}$ansi .= $highlighted;return$ansi}my%htmlcolors=(ANCHOR=>'anchor',ALIAS=>'alias',SINGLEQUOTE=>'singlequote',DOUBLEQUOTE=>'doublequote',SINGLEQUOTED=>'singlequoted',DOUBLEQUOTED=>'doublequoted',SINGLEQUOTED_LINE=>'singlequoted',DOUBLEQUOTED_LINE=>'doublequoted',INDENT=>'indent',DASH=>'dash',COLON=>'colon',QUESTION=>'question',YAML_DIRECTIVE=>'yaml_directive',TAG_DIRECTIVE=>'tag_directive',TAG=>'tag',COMMENT=>'comment',LITERAL=>'literal',FOLDED=>'folded',DOC_START=>'doc_start',DOC_END=>'doc_end',BLOCK_SCALAR_CONTENT=>'block_scalar_content',TAB=>'tab',ERROR=>'error',EOL=>'eol',TRAILING_SPACE=>'trailing_space',FLOWSEQ_START=>'flowseq_start',FLOWSEQ_END=>'flowseq_end',FLOWMAP_START=>'flowmap_start',FLOWMAP_END=>'flowmap_end',FLOW_COMMA=>'flow_comma',PLAINKEY=>'plainkey',);sub htmlcolored {require HTML::Entities;my ($class,$tokens)=@_;my$html='';my@list=$class->transform($tokens);for my$token (@list){my$name=$token->{name};my$str=$token->{value};my$colorclass=$htmlcolors{$name }|| 'default';$str=HTML::Entities::encode_entities($str);$html .= qq{<span class="$colorclass">$str</span>}}return$html}sub transform {my ($class,$tokens)=@_;my@list;for my$token (@$tokens){my@values;my$value=$token->{value};my$subtokens=$token->{subtokens};if ($subtokens){@values=@$subtokens}else {@values=$token}for my$token (@values){my$value=defined$token->{orig}? $token->{orig}: $token->{value};push@list,map {$_ =~ tr/\t/\t/ ? {name=>'TAB',value=>$_ }: {name=>$token->{name},value=>$_ }}split m/(\t+)/,$value}}for my$i (0 .. $#list){my$token=$list[$i ];my$name=$token->{name};my$str=$token->{value};my$trailing_space=0;if ($token->{name}eq 'EOL'){if ($str =~ m/ +([\r\n]|\z)/){$token->{name}="TRAILING_SPACE"}}elsif ($i < $#list){if ($name eq 'PLAIN'){for my$n ($i+1 .. $#list){my$next=$list[$n ];last if$next->{name}eq 'EOL';next if$next->{name}=~ m/^(WS|SPACE)$/;if ($next->{name}eq 'COLON'){$token->{name}='PLAINKEY'}}}my$next=$list[$i + 1];if ($next->{name}eq 'EOL'){if ($str =~ m/ \z/ and $name =~ m/^(BLOCK_SCALAR_CONTENT|WS)$/){$token->{name}="TRAILING_SPACE"}}}}return@list}1;
YAML_PP_HIGHLIGHT

$fatpacked{"YAML/PP/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LEXER';
  use strict;use warnings;package YAML::PP::Lexer;our$VERSION='0.031';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;use constant DEBUG=>($ENV{YAML_PP_DEBUG}|| $ENV{YAML_PP_TRACE})? 1 : 0;use YAML::PP::Grammar qw/$GRAMMAR/;use Carp qw/croak/;sub new {my ($class,%args)=@_;my$self=bless {reader=>$args{reader},},$class;$self->init;return$self}sub init {my ($self)=@_;$self->{next_tokens}=[];$self->{next_line}=undef;$self->{line}=0;$self->{offset}=0;$self->{flowcontext}=0}sub next_line {return $_[0]->{next_line}}sub set_next_line {$_[0]->{next_line}=$_[1]}sub reader {return $_[0]->{reader}}sub set_reader {$_[0]->{reader}=$_[1]}sub next_tokens {return $_[0]->{next_tokens}}sub line {return $_[0]->{line}}sub set_line {$_[0]->{line}=$_[1]}sub offset {return $_[0]->{offset}}sub set_offset {$_[0]->{offset}=$_[1]}sub inc_line {return $_[0]->{line}++}sub context {return $_[0]->{context}}sub set_context {$_[0]->{context}=$_[1]}sub flowcontext {return $_[0]->{flowcontext}}sub set_flowcontext {$_[0]->{flowcontext}=$_[1]}sub block {return $_[0]->{block}}sub set_block {$_[0]->{block}=$_[1]}my$RE_WS='[\t ]';my$RE_LB='[\r\n]';my$RE_DOC_END=qr/\A(\.\.\.)(?=$RE_WS|$)/m;my$RE_DOC_START=qr/\A(---)(?=$RE_WS|$)/m;my$RE_EOL=qr/\A($RE_WS+#.*|$RE_WS+)\z/;my$RE_NS_WORD_CHAR='[0-9A-Za-z-]';my$RE_URI_CHAR='(?:' .'%[0-9a-fA-F]{2}' .'|'.q{[0-9A-Za-z#;/?:@&=+$,_.!*'\(\)\[\]-]} .')';my$RE_NS_TAG_CHAR='(?:' .'%[0-9a-fA-F]{2}' .'|'.q{[0-9A-Za-z#;/?:@&=+$_.*'\(\)-]} .')';my$RE_ANCHOR_CAR='[\x21-\x2B\x2D-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_START='[\x21\x22\x24-\x39\x3B-\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_END='[\x21-\x39\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';my$RE_PLAIN_FIRST='[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_START_FLOW='[\x21\x22\x24-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_END_FLOW='[\x21-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';my$RE_PLAIN_FIRST_FLOW='[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_WORD="(?::+$RE_PLAIN_END|$RE_PLAIN_START)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";my$RE_PLAIN_FIRST_WORD="(?:[:?-]+$RE_PLAIN_END|$RE_PLAIN_FIRST)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";my$RE_PLAIN_WORDS="(?:$RE_PLAIN_FIRST_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";my$RE_PLAIN_WORDS2="(?:$RE_PLAIN_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";my$RE_PLAIN_WORD_FLOW="(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_START_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";my$RE_PLAIN_FIRST_WORD_FLOW="(?:[:?-]+$RE_PLAIN_END_FLOW|$RE_PLAIN_FIRST_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";my$RE_PLAIN_WORDS_FLOW="(?:$RE_PLAIN_FIRST_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";my$RE_PLAIN_WORDS_FLOW2="(?:$RE_PLAIN_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";my$RE_TAG="!(?:$RE_NS_WORD_CHAR*!$RE_NS_TAG_CHAR+|$RE_NS_TAG_CHAR+|<$RE_URI_CHAR+>|)";my$RE_SEQSTART=qr/\A(-)(?=$RE_WS|$)/m;my$RE_COMPLEX=qr/(\?)(?=$RE_WS|$)/m;my$RE_COMPLEXCOLON=qr/\A(:)(?=$RE_WS|$)/m;my$RE_ANCHOR="&$RE_ANCHOR_CAR+";my$RE_ALIAS="\\*$RE_ANCHOR_CAR+";my%REGEXES=(ANCHOR=>qr{($RE_ANCHOR)},TAG=>qr{($RE_TAG)},ALIAS=>qr{($RE_ALIAS)},SINGLEQUOTED=>qr{(?:''|[^'\r\n]+)*},);sub fetch_next_line {my ($self)=@_;my$next_line=$self->next_line;if (defined$next_line){return$next_line}my$line=$self->reader->readline;unless (defined$line){$self->set_next_line(undef);return}$self->set_block(1);$self->inc_line;$line =~ m/\A( *)([^\r\n]*)([\r\n]|\z)/ or die "Unexpected";$next_line=[$1,$2,$3 ];$self->set_next_line($next_line);if ($line =~ tr/\x00-\x08\x0b-\x0c\x0e-\x1f//){$self->exception("Control characters are not allowed")}return$next_line}my%TOKEN_NAMES=('"'=>'DOUBLEQUOTE',"'"=>'SINGLEQUOTE','|'=>'LITERAL','>'=>'FOLDED','!'=>'TAG','*'=>'ALIAS','&'=>'ANCHOR',':'=>'COLON','-'=>'DASH','?'=>'QUESTION','['=>'FLOWSEQ_START',']'=>'FLOWSEQ_END','{'=>'FLOWMAP_START','}'=>'FLOWMAP_END',','=>'FLOW_COMMA','---'=>'DOC_START','...'=>'DOC_END',);sub fetch_next_tokens {my ($self)=@_;my$next=$self->next_tokens;return$next if @$next;my$next_line=$self->fetch_next_line;if (not $next_line){return []}my$spaces=$next_line->[0];my$yaml=\$next_line->[1];if (not length $$yaml){$self->push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}if (substr($$yaml,0,1)eq '#'){$self->push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}if (not $spaces and substr($$yaml,0,1)eq "%"){$self->_fetch_next_tokens_directive($yaml,$next_line->[2]);$self->set_context(0);$self->set_next_line(undef);return$next}if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//){$self->push_tokens([$TOKEN_NAMES{$1 }=>$1,$self->line ])}elsif ($self->flowcontext and $$yaml =~ m/\A[ \t]+(#.*)?\z/){$self->push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}else {$self->push_tokens([SPACE=>$spaces,$self->line ])}my$partial=$self->_fetch_next_tokens($next_line);unless ($partial){$self->set_next_line(undef)}return$next}my%ANCHOR_ALIAS_TAG=('&'=>1,'*'=>1,'!'=>1);my%BLOCK_SCALAR=('|'=>1,'>'=>1);my%COLON_DASH_QUESTION=(':'=>1,'-'=>1,'?'=>1);my%QUOTED=('"'=>1,"'"=>1);my%FLOW=('{'=>1,'['=>1,'}'=>1,']'=>1,','=>1);my%CONTEXT=('"'=>1,"'"=>1,'>'=>1,'|'=>1);my$RE_ESCAPES=qr{(?:
      \\([ \\\/_0abefnrtvLNP\t"]) | \\x([0-9a-fA-F]{2})
      | \\u([A-Fa-f0-9]{4}) | \\U([A-Fa-f0-9]{4,8})
  )}x;my%CONTROL=('\\'=>'\\','/'=>'/',n=>"\n",t=>"\t",r=>"\r",b=>"\b",'a'=>"\a",'b'=>"\b",'e'=>"\e",'f'=>"\f",'v'=>"\x0b","\t"=>"\t",'P'=>"\x{2029}",L=>"\x{2028}",'N'=>"\x85",'0'=>"\0",'_'=>"\xa0",' '=>' ',q/"/=>q/"/,);sub _fetch_next_tokens {TRACE and warn __PACKAGE__.':'.__LINE__.": _fetch_next_tokens\n";my ($self,$next_line)=@_;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my@tokens;while (1){unless (length $$yaml){push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}my$first=substr($$yaml,0,1);my$plain=0;if ($self->context){if ($$yaml =~ s/\A($RE_WS*)://){push@tokens,(WS=>$1,$self->line)if $1;push@tokens,(COLON=>':',$self->line);$self->set_context(0);next}if ($$yaml =~ s/\A($RE_WS*(?: #.*))\z//){push@tokens,(EOL=>$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}$self->set_context(0)}if ($CONTEXT{$first }){push@tokens,(CONTEXT=>$first,$self->line);$self->push_tokens(\@tokens);return 1}elsif ($COLON_DASH_QUESTION{$first }){my$token_name=$TOKEN_NAMES{$first };if ($$yaml =~ s/\A\Q$first\E($RE_WS+|\z)//){if (not $self->flowcontext and not $self->block){$self->push_tokens(\@tokens);$self->exception("Tabs can not be used for indentation")}my$after=$1;if ($after =~ tr/\t//){$self->set_block(0)}my$token_name=$TOKEN_NAMES{$first };push@tokens,($token_name=>$first,$self->line);if (not defined $1){push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}my$ws=$1;if ($$yaml =~ s/\A(#.*|)\z//){push@tokens,(EOL=>$ws .$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}push@tokens,(WS=>$ws,$self->line);next}elsif ($self->flowcontext and $$yaml =~ s/\A:(?=[,\{\}\[\]])//){push@tokens,($token_name=>$first,$self->line);next}$plain=1}elsif ($ANCHOR_ALIAS_TAG{$first }){my$token_name=$TOKEN_NAMES{$first };my$REGEX=$REGEXES{$token_name };if ($$yaml =~ s/\A$REGEX//){push@tokens,($token_name=>$1,$self->line)}else {push@tokens,("Invalid $token_name"=>$$yaml,$self->line);$self->push_tokens(\@tokens);return}}elsif ($first eq ' ' or $first eq "\t"){if ($$yaml =~ s/\A($RE_WS+)//){my$ws=$1;if ($$yaml =~ s/\A((?:#.*)?\z)//){push@tokens,(EOL=>$ws .$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}push@tokens,(WS=>$ws,$self->line)}}elsif ($FLOW{$first }){push@tokens,($TOKEN_NAMES{$first }=>$first,$self->line);substr($$yaml,0,1,'');my$flowcontext=$self->flowcontext;if ($first eq '{' or $first eq '['){$self->set_flowcontext(++$flowcontext)}elsif ($first eq '}' or $first eq ']'){$self->set_flowcontext(--$flowcontext)}}else {$plain=1}if ($plain){push@tokens,(CONTEXT=>'',$self->line);$self->push_tokens(\@tokens);return 1}}return}sub fetch_plain {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my$REGEX=$RE_PLAIN_WORDS;if ($self->flowcontext){$REGEX=$RE_PLAIN_WORDS_FLOW}my@tokens;unless ($$yaml =~ s/\A($REGEX)//){$self->push_tokens(\@tokens);$self->exception("Invalid plain scalar")}my$plain=$1;push@tokens,(PLAIN=>$plain,$self->line);if ($$yaml =~ s/\A(?:($RE_WS+#.*)|($RE_WS*))\z//){if (defined $1){push@tokens,(EOL=>$1 .$eol,$self->line);$self->push_tokens(\@tokens);$self->set_next_line(undef);return}else {push@tokens,(EOL=>$2.$eol,$self->line);$self->set_next_line(undef)}}else {$self->push_tokens(\@tokens);my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}return}my$RE2=$RE_PLAIN_WORDS2;if ($self->flowcontext){$RE2=$RE_PLAIN_WORDS_FLOW2}my$fetch_next=0;my@lines=($plain);my@next;LOOP: while (1){$next_line=$self->fetch_next_line;if (not $next_line){last LOOP}my$spaces=$next_line->[0];my$yaml=\$next_line->[1];my$eol=$next_line->[2];if (not length $$yaml){push@tokens,(EOL=>$spaces .$eol,$self->line);$self->set_next_line(undef);push@lines,'';next LOOP}if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//){push@next,$TOKEN_NAMES{$1 }=>$1,$self->line;$fetch_next=1;last LOOP}if ((length$spaces)< $indent){last LOOP}my$ws='';if ($$yaml =~ s/\A($RE_WS+)//){$ws=$1}if (not length $$yaml){push@tokens,(EOL=>$spaces .$ws .$eol,$self->line);$self->set_next_line(undef);push@lines,'';next LOOP}if ($$yaml =~ s/\A(#.*)\z//){push@tokens,(EOL=>$spaces .$ws .$1 .$eol,$self->line);$self->set_next_line(undef);last LOOP}if ($$yaml =~ s/\A($RE2)//){push@tokens,INDENT=>$spaces,$self->line;push@tokens,WS=>$ws,$self->line;push@tokens,PLAIN=>$1,$self->line;push@lines,$1;my$ws='';if ($$yaml =~ s/\A($RE_WS+)//){$ws=$1}if (not length $$yaml){push@tokens,EOL=>$ws .$eol,$self->line;$self->set_next_line(undef);next LOOP}if ($$yaml =~ s/\A(#.*)\z//){push@tokens,EOL=>$ws .$1 .$eol,$self->line;$self->set_next_line(undef);last LOOP}else {push@tokens,WS=>$ws,$self->line if$ws;$fetch_next=1}}else {push@tokens,SPACE=>$spaces,$self->line;push@tokens,WS=>$ws,$self->line;if ($self->flowcontext){$fetch_next=1}else {push@tokens,ERROR=>$$yaml,$self->line}}last LOOP}while (@lines > 1 and $lines[-1]eq ''){pop@lines}if (@lines > 1){my$value=YAML::PP::Render->render_multi_val(\@lines);my@eol;if ($tokens[-3]eq 'EOL'){@eol=splice@tokens,-3}$self->push_subtokens({name=>'PLAIN_MULTI',value=>$value },\@tokens);$self->push_tokens([@eol,@next ])}else {$self->push_tokens([@tokens,@next ])}@tokens=();if ($fetch_next){my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}}return}sub fetch_block {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my@tokens;my$token_name=$TOKEN_NAMES{$context };$$yaml =~ s/\A\Q$context\E// or die "Unexpected";push@tokens,($token_name=>$context,$self->line);my$current_indent=$indent;my$started=0;my$set_indent=0;my$chomp='';if ($$yaml =~ s/\A([1-9])([+-]?)//){push@tokens,(BLOCK_SCALAR_INDENT=>$1,$self->line);$set_indent=$1;$chomp=$2 if $2;push@tokens,(BLOCK_SCALAR_CHOMP=>$2,$self->line)if $2}elsif ($$yaml =~ s/\A([+-])([1-9])?//){push@tokens,(BLOCK_SCALAR_CHOMP=>$1,$self->line);$chomp=$1;push@tokens,(BLOCK_SCALAR_INDENT=>$2,$self->line)if $2;$set_indent=$2 if $2}if ($set_indent){$started=1;$indent-- if$indent > 0;$current_indent=$indent + $set_indent}if (not length $$yaml){push@tokens,(EOL=>$eol,$self->line)}elsif ($$yaml =~ s/\A($RE_WS*(?:$RE_WS#.*|))\z//){push@tokens,(EOL=>$1 .$eol,$self->line)}else {$self->push_tokens(\@tokens);$self->exception("Invalid block scalar")}my@lines;while (1){$self->set_next_line(undef);$next_line=$self->fetch_next_line;if (not $next_line){last}my$spaces=$next_line->[0];my$content=$next_line->[1];my$eol=$next_line->[2];if (not $spaces and $content =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/){last}if ((length$spaces)< $current_indent){if (length$content){if ($content =~ m/\A\t/){$self->exception("Invalid block scalar")}last}else {push@lines,'';push@tokens,(EOL=>$spaces .$eol,$self->line);next}}if ((length$spaces)> $current_indent){if ($started){($spaces,my$more_spaces)=unpack "a${current_indent}a*",$spaces;$content=$more_spaces .$content}}unless (length$content){push@lines,'';push@tokens,(INDENT=>$spaces,$self->line,EOL=>$eol,$self->line);unless ($started){$current_indent=length$spaces}next}unless ($started){$started=1;$current_indent=length$spaces}push@lines,$content;push@tokens,(INDENT=>$spaces,$self->line,BLOCK_SCALAR_CONTENT=>$content,$self->line,EOL=>$eol,$self->line,)}my$value=YAML::PP::Render->render_block_scalar($context,$chomp,\@lines);my@eol=splice@tokens,-3;$self->push_subtokens({name=>'BLOCK_SCALAR',value=>$value },\@tokens);$self->push_tokens([@eol ]);return 0}sub fetch_quoted {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$spaces=$next_line->[0];my$token_name=$TOKEN_NAMES{$context };$$yaml =~ s/\A\Q$context// or die "Unexpected";;my@tokens=($token_name=>$context,$self->line);my$start=1;my@values;while (1){unless ($start){$next_line=$self->fetch_next_line or do {for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Missing closing quote <$context> at EOF")};$start=0;$spaces=$next_line->[0];$yaml=\$next_line->[1];if (not length $$yaml){push@tokens,(EOL=>$spaces .$next_line->[2],$self->line);$self->set_next_line(undef);push@values,{value=>'',orig=>'' };next}elsif (not $spaces and $$yaml =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/){for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Missing closing quote <$context> or invalid document marker")}elsif ((length$spaces)< $indent){for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Wrong indendation or missing closing quote <$context>")}if ($$yaml =~ s/\A($RE_WS+)//){$spaces .= $1}push@tokens,(WS=>$spaces,$self->line)}my$v=$self->_read_quoted_tokens($start,$context,$yaml,\@tokens);push@values,$v;if ($tokens[-3]eq $token_name){if ($start){$self->push_subtokens({name=>'QUOTED',value=>$v->{value}},\@tokens)}else {my$value=YAML::PP::Render->render_quoted($context,\@values);$self->push_subtokens({name=>'QUOTED_MULTILINE',value=>$value },\@tokens)}$self->set_context(1)if$self->flowcontext;if (length $$yaml){my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}return 0}else {@tokens=();push@tokens,(EOL=>$next_line->[2],$self->line);$self->push_tokens(\@tokens);$self->set_next_line(undef);return}}$tokens[-2].= $next_line->[2];$self->set_next_line(undef);$start=0}}sub _read_quoted_tokens {my ($self,$start,$first,$yaml,$tokens)=@_;my$quoted='';my$decoded='';my$token_name=$TOKEN_NAMES{$first };my$eol='';if ($first eq "'"){my$regex=$REGEXES{SINGLEQUOTED};if ($$yaml =~ s/\A($regex)//){$quoted .= $1;$decoded .= $1;$decoded =~ s/''/'/g}unless (length $$yaml){if ($quoted =~ s/($RE_WS+)\z//){$eol=$1;$decoded =~ s/($eol)\z//}}}else {($quoted,$decoded,$eol)=$self->_read_doublequoted($yaml)}my$value={value=>$decoded,orig=>$quoted };if ($$yaml =~ s/\A$first//){if ($start){push @$tokens,($token_name .'D'=>$value,$self->line)}else {push @$tokens,($token_name .'D_LINE'=>$value,$self->line)}push @$tokens,($token_name=>$first,$self->line);return$value}if (length $$yaml){push @$tokens,($token_name .'D'=>$value->{orig},$self->line);$self->push_tokens($tokens);$self->exception("Invalid quoted <$first> string")}push @$tokens,($token_name .'D_LINE'=>$value,$self->line);push @$tokens,(EOL=>$eol,$self->line);return$value}sub _read_doublequoted {my ($self,$yaml)=@_;my$quoted='';my$decoded='';my$eol='';while (1){my$last=1;if ($$yaml =~ s/\A([^"\\ \t]+)//){$quoted .= $1;$decoded .= $1;$last=0}if ($$yaml =~ s/\A($RE_ESCAPES)//){$quoted .= $1;my$dec=defined $2 ? $CONTROL{$2 }: defined $3 ? chr hex $3 : defined $4 ? chr hex $4 : chr hex $5;$decoded .= $dec;$last=0}if ($$yaml =~ s/\A([ \t]+)//){my$spaces=$1;if (length $$yaml){$quoted .= $spaces;$decoded .= $spaces;$last=0}else {$eol=$spaces;last}}if ($$yaml =~ s/\A(\\)\z//){$quoted .= $1;$decoded .= $1;last}last if$last}return ($quoted,$decoded,$eol)}sub _fetch_next_tokens_directive {my ($self,$yaml,$eol)=@_;my@tokens;my$trailing_ws='';if ($$yaml =~ s/\A(\s*%YAML\b)//){my$dir=$1;if ($$yaml =~ s/\A([ \t]+)//){$dir .= $1;if ($$yaml =~ s/\A(1\.[12])($RE_WS*)//){$dir .= $1;$trailing_ws=$2;push@tokens,(YAML_DIRECTIVE=>$dir,$self->line)}else {$$yaml =~ s/\A(.*)//;$dir .= $1;my$warn=$ENV{YAML_PP_RESERVED_DIRECTIVE}|| 'warn';if ($warn eq 'warn'){warn "Found reserved directive '$dir'"}elsif ($warn eq 'fatal'){die "Found reserved directive '$dir'"}push@tokens,(RESERVED_DIRECTIVE=>"$dir",$self->line)}}else {$$yaml =~ s/\A(.*)//;$dir .= $1;push@tokens,('Invalid directive'=>$dir,$self->line);push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}}elsif ($$yaml =~ s/\A(\s*%TAG[ \t]+(!$RE_NS_WORD_CHAR*!|!)[ \t]+(tag:\S+|!$RE_URI_CHAR+))($RE_WS*)//){push@tokens,(TAG_DIRECTIVE=>$1,$self->line);my$tag_alias=$2;my$tag_url=$3;$trailing_ws=$4}elsif ($$yaml =~ s/\A(\s*\A%(?:\w+).*)//){push@tokens,(RESERVED_DIRECTIVE=>$1,$self->line);my$warn=$ENV{YAML_PP_RESERVED_DIRECTIVE}|| 'warn';if ($warn eq 'warn'){warn "Found reserved directive '$1'"}elsif ($warn eq 'fatal'){die "Found reserved directive '$1'"}}else {push@tokens,('Invalid directive'=>$$yaml,$self->line);push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}if (not length $$yaml){push@tokens,(EOL=>$eol,$self->line)}elsif ($trailing_ws and $$yaml =~ s/\A(#.*)?\z//){push@tokens,(EOL=>"$trailing_ws$1$eol",$self->line);$self->push_tokens(\@tokens);return}elsif ($$yaml =~ s/\A([ \t]+#.*)?\z//){push@tokens,(EOL=>"$1$eol",$self->line);$self->push_tokens(\@tokens);return}else {push@tokens,('Invalid directive'=>$$yaml,$self->line);push@tokens,(EOL=>$eol,$self->line)}$self->push_tokens(\@tokens);return}sub push_tokens {my ($self,$new_tokens)=@_;my$next=$self->next_tokens;my$line=$self->line;my$column=$self->offset;for (my$i=0;$i < @$new_tokens;$i += 3){my$value=$new_tokens->[$i + 1 ];my$name=$new_tokens->[$i ];my$line=$new_tokens->[$i + 2 ];my$push={name=>$name,line=>$line,column=>$column,value=>$value,};$column += length$value unless$name eq 'CONTEXT';push @$next,$push;if ($name eq 'EOL'){$column=0}}$self->set_offset($column);return$next}sub push_subtokens {my ($self,$token,$subtokens)=@_;my$next=$self->next_tokens;my$line=$self->line;my$column=$self->offset;$token->{column}=$column;$token->{subtokens}=\my@sub;for (my$i=0;$i < @$subtokens;$i+=3){my$name=$subtokens->[$i ];my$value=$subtokens->[$i + 1 ];my$line=$subtokens->[$i + 2 ];my$push={name=>$subtokens->[$i ],line=>$line,column=>$column,};if (ref$value eq 'HASH'){%$push=(%$push,%$value);$column += length$value->{orig}}else {$push->{value}=$value;$column += length$value}if ($push->{name}eq 'EOL'){$column=0}push@sub,$push}$token->{line}=$sub[0]->{line};push @$next,$token;$self->set_offset($column);return$next}sub exception {my ($self,$msg)=@_;my$next=$self->next_tokens;$next=[];my$line=@$next ? $next->[0]->{line}: $self->line;my@caller=caller(0);my$yaml='';if (my$nl=$self->next_line){$yaml=join '',@$nl;$yaml=$nl->[1]}my$e=YAML::PP::Exception->new(line=>$line,column=>$self->offset + 1,msg=>$msg,next=>$next,where=>$caller[1].' line ' .$caller[2],yaml=>$yaml,);croak$e}1;
YAML_PP_LEXER

$fatpacked{"YAML/PP/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LOADER';
  use strict;use warnings;package YAML::PP::Loader;our$VERSION='0.031';use YAML::PP::Parser;use YAML::PP::Constructor;use YAML::PP::Reader;sub new {my ($class,%args)=@_;my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';my$default_yaml_version=delete$args{default_yaml_version}|| '1.2';my$preserve=delete$args{preserve};my$duplicate_keys=delete$args{duplicate_keys};my$schemas=delete$args{schemas};$schemas ||= {'1.2'=>YAML::PP->default_schema(boolean=>'perl',)};my$constructor=delete$args{constructor}|| YAML::PP::Constructor->new(schemas=>$schemas,cyclic_refs=>$cyclic_refs,default_yaml_version=>$default_yaml_version,preserve=>$preserve,duplicate_keys=>$duplicate_keys,);my$parser=delete$args{parser};unless ($parser){$parser=YAML::PP::Parser->new(default_yaml_version=>$default_yaml_version,)}unless ($parser->receiver){$parser->set_receiver($constructor)}if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {parser=>$parser,constructor=>$constructor,},$class;return$self}sub clone {my ($self)=@_;my$clone={parser=>$self->parser->clone,constructor=>$self->constructor->clone,};bless$clone,ref$self;$clone->parser->set_receiver($clone->constructor);return$clone}sub parser {return $_[0]->{parser}}sub constructor {return $_[0]->{constructor}}sub filename {my ($self)=@_;my$reader=$self->parser->reader;if ($reader->isa('YAML::PP::Reader::File')){return$reader->input}die "Reader is not a YAML::PP::Reader::File"}sub load_string {my ($self,$yaml)=@_;$self->parser->set_reader(YAML::PP::Reader->new(input=>$yaml));$self->load()}sub load_file {my ($self,$file)=@_;$self->parser->set_reader(YAML::PP::Reader::File->new(input=>$file));$self->load()}sub load {my ($self)=@_;my$parser=$self->parser;my$constructor=$self->constructor;$constructor->init;$parser->parse();my$docs=$constructor->docs;return wantarray ? @$docs : $docs->[0]}1;
YAML_PP_LOADER

$fatpacked{"YAML/PP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PARSER';
  use strict;use warnings;package YAML::PP::Parser;our$VERSION='0.031';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;use constant DEBUG=>($ENV{YAML_PP_DEBUG}|| $ENV{YAML_PP_TRACE})? 1 : 0;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE/;use YAML::PP::Render;use YAML::PP::Lexer;use YAML::PP::Grammar qw/$GRAMMAR/;use YAML::PP::Exception;use YAML::PP::Reader;use Carp qw/croak/;sub new {my ($class,%args)=@_;my$reader=delete$args{reader}|| YAML::PP::Reader->new;my$default_yaml_version=delete$args{default_yaml_version};my$self=bless {default_yaml_version=>$default_yaml_version || '1.2',lexer=>YAML::PP::Lexer->new(reader=>$reader,),},$class;my$receiver=delete$args{receiver};if ($receiver){$self->set_receiver($receiver)}return$self}sub clone {my ($self)=@_;my$clone={default_yaml_version=>$self->default_yaml_version,lexer=>YAML::PP::Lexer->new(),};return bless$clone,ref$self}sub receiver {return $_[0]->{receiver}}sub set_receiver {my ($self,$receiver)=@_;my$callback;if (ref$receiver eq 'CODE'){$callback=$receiver}else {$callback=sub {my ($self,$event,$info)=@_;return$receiver->$event($info)}}$self->{callback}=$callback;$self->{receiver}=$receiver}sub reader {return $_[0]->lexer->{reader}}sub set_reader {my ($self,$reader)=@_;$self->lexer->set_reader($reader)}sub lexer {return $_[0]->{lexer}}sub callback {return $_[0]->{callback}}sub set_callback {$_[0]->{callback}=$_[1]}sub level {return $#{$_[0]->{offset}}}sub offset {return $_[0]->{offset}}sub set_offset {$_[0]->{offset}=$_[1]}sub events {return $_[0]->{events}}sub set_events {$_[0]->{events}=$_[1]}sub new_node {return $_[0]->{new_node}}sub set_new_node {$_[0]->{new_node}=$_[1]}sub tagmap {return $_[0]->{tagmap}}sub set_tagmap {$_[0]->{tagmap}=$_[1]}sub tokens {return $_[0]->{tokens}}sub set_tokens {$_[0]->{tokens}=$_[1]}sub event_stack {return $_[0]->{event_stack}}sub set_event_stack {$_[0]->{event_stack}=$_[1]}sub default_yaml_version {return $_[0]->{default_yaml_version}}sub yaml_version {return $_[0]->{yaml_version}}sub set_yaml_version {$_[0]->{yaml_version}=$_[1]}sub yaml_version_directive {return $_[0]->{yaml_version_directive}}sub set_yaml_version_directive {$_[0]->{yaml_version_directive}=$_[1]}sub rule {return $_[0]->{rule}}sub set_rule {my ($self,$name)=@_;no warnings 'uninitialized';DEBUG and $self->info("set_rule($name)");$self->{rule}=$name}sub init {my ($self)=@_;$self->set_offset([]);$self->set_events([]);$self->set_new_node(0);$self->set_tagmap({'!!'=>"tag:yaml.org,2002:",});$self->set_tokens([]);$self->set_rule(undef);$self->set_event_stack([]);$self->set_yaml_version($self->default_yaml_version);$self->set_yaml_version_directive(undef);$self->lexer->init}sub parse_string {my ($self,$yaml)=@_;$self->set_reader(YAML::PP::Reader->new(input=>$yaml));$self->parse()}sub parse_file {my ($self,$file)=@_;$self->set_reader(YAML::PP::Reader::File->new(input=>$file));$self->parse()}my%nodetypes=(MAPVALUE=>'NODETYPE_COMPLEX',MAP=>'NODETYPE_MAP',SEQ=>'NODETYPE_SEQ',SEQ0=>'NODETYPE_SEQ',FLOWMAP=>'NODETYPE_FLOWMAP',FLOWMAPVALUE=>'NODETYPE_FLOWMAPVALUE',FLOWSEQ=>'NODETYPE_FLOWSEQ',FLOWSEQ_NEXT=>'FLOWSEQ_NEXT',DOC=>'FULLNODE',DOC_END=>'DOCUMENT_END',STR=>'STREAM',END_FLOW=>'END_FLOW',);sub parse {my ($self)=@_;TRACE and warn "=== parse()\n";TRACE and $self->debug_yaml;$self->init;$self->lexer->init;eval {$self->start_stream;$self->set_rule('STREAM');$self->parse_tokens();$self->end_stream};if (my$error=$@){if (ref$error){croak "$error\n "}croak$error}DEBUG and $self->highlight_yaml;TRACE and $self->debug_tokens}sub lex_next_tokens {my ($self)=@_;DEBUG and $self->info("----------------> lex_next_tokens");TRACE and $self->debug_events;my$indent=$self->offset->[-1];my$event_types=$self->events;my$next_tokens=$self->lexer->fetch_next_tokens($indent);return unless @$next_tokens;my$next=$next_tokens->[0];return 1 if ($next->{name}ne 'SPACE');my$flow=$event_types->[-1]=~ m/^FLOW/;my$space=length$next->{value};my$tokens=$self->tokens;if (not $space){shift @$next_tokens}else {push @$tokens,shift @$next_tokens}if ($flow){if ($space >= $indent){return 1}$self->exception("Bad indendation in " .$self->events->[-1])}$next=$next_tokens->[0];if ($space > $indent){return 1 if$indent < 0;unless ($self->new_node){$self->exception("Bad indendation in " .$self->events->[-1])}return 1}if ($self->new_node){if ($space < $indent){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' });$self->remove_nodes($space)}else {my$exp=$self->events->[-1];my$seq_start=$next->{name}eq 'DASH';if ($seq_start and ($exp eq 'MAPVALUE' or $exp eq 'MAP')){}else {$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}}}else {if ($space < $indent){$self->remove_nodes($space)}}my$exp=$self->events->[-1];if ($exp eq 'SEQ0' and $next->{name}ne 'DASH'){TRACE and $self->info("In unindented sequence");$self->end_sequence;$exp=$self->events->[-1]}if ($self->offset->[-1]!=$space){$self->exception("Expected " .$self->events->[-1])}return 1}my%next_event=(MAP=>'MAPVALUE',IMAP=>'IMAPVALUE',MAPVALUE=>'MAP',IMAPVALUE=>'IMAP',SEQ=>'SEQ',SEQ0=>'SEQ0',DOC=>'DOC_END',STR=>'STR',FLOWSEQ=>'FLOWSEQ_NEXT',FLOWSEQ_NEXT=>'FLOWSEQ',FLOWMAP=>'FLOWMAPVALUE',FLOWMAPVALUE=>'FLOWMAP',);my%event_to_method=(MAP=>'mapping',IMAP=>'mapping',FLOWMAP=>'mapping',SEQ=>'sequence',SEQ0=>'sequence',FLOWSEQ=>'sequence',DOC=>'document',STR=>'stream',VAL=>'scalar',ALI=>'alias',MAPVALUE=>'mapping',IMAPVALUE=>'mapping',);my%fetch_method=('"'=>'fetch_quoted',"'"=>'fetch_quoted','|'=>'fetch_block','>'=>'fetch_block',''=>'fetch_plain',);sub parse_tokens {my ($self)=@_;my$event_types=$self->events;my$offsets=$self->offset;my$tokens=$self->tokens;my$next_tokens=$self->lexer->next_tokens;unless ($self->lex_next_tokens){$self->end_document(1);return 0}unless ($self->new_node){if ($self->level > 0){my$new_rule=$nodetypes{$event_types->[-1]}or die "Did not find '$event_types->[-1]'";$self->set_rule($new_rule)}}my$rule_name=$self->rule;DEBUG and $self->info("----------------> parse_tokens($rule_name)");my$rule=$GRAMMAR->{$rule_name }or die "Could not find rule $rule_name";TRACE and $self->debug_rules($rule);TRACE and $self->debug_yaml;DEBUG and $self->debug_next_line;RULE: while ($rule_name){DEBUG and $self->info("RULE: $rule_name");TRACE and $self->debug_tokens($next_tokens);unless (@$next_tokens){$self->exception("No more tokens")}TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$next_tokens->[0]],['next_token']);my$got=$next_tokens->[0]->{name};if ($got eq 'CONTEXT'){my$context=shift @$next_tokens;my$indent=$offsets->[-1];$indent++ unless$self->lexer->flowcontext;my$method=$fetch_method{$context->{value}};my$partial=$self->lexer->$method($indent,$context->{value});next RULE}my$def=$rule->{$got };if ($def){push @$tokens,shift @$next_tokens}elsif ($def=$rule->{DEFAULT}){$got='DEFAULT'}else {$self->expected(expected=>[keys %$rule],got=>$next_tokens->[0],)}DEBUG and $self->got("---got $got");if (my$sub=$def->{match}){DEBUG and $self->info("CALLBACK $sub");$self->$sub(@$tokens ? $tokens->[-1]: ())}my$eol=$got eq 'EOL';my$new=$def->{new};if ($new){DEBUG and $self->got("NEW: $new");$rule_name=$new;$self->set_rule($rule_name)}elsif ($eol){}elsif ($def->{return}){$rule_name=$nodetypes{$event_types->[-1]}or die "Unexpected event type $event_types->[-1]";$self->set_rule($rule_name)}else {$rule_name .= " - $got";$rule=$def;next RULE}if ($eol){unless ($self->lex_next_tokens){if ($rule_name eq 'DIRECTIVE'){$self->exception("Directive needs document start")}$self->end_document(1);return 0}unless ($self->new_node){if ($self->level > 0){$rule_name=$nodetypes{$event_types->[-1]}or die "Did not find '$event_types->[-1]'";$self->set_rule($rule_name)}}$rule_name=$self->rule}$rule=$GRAMMAR->{$rule_name }or die "Unexpected rule $rule_name"}die "Unexpected"}sub end_sequence {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'sequence_end_event' };$self->callback->($self,$info->{name}=>$info);$event_types->[-1]=$next_event{$event_types->[-1]}}sub remove_nodes {my ($self,$space)=@_;my$offset=$self->offset;my$event_types=$self->events;my$exp=$event_types->[-1];while (@$offset){if ($offset->[-1 ]<= $space){last}if ($exp eq 'MAPVALUE'){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' });$exp='MAP'}my$info={name=>$exp };$info->{name}=$event_to_method{$exp }.'_end_event';pop @{$event_types};pop @{$offset};$self->callback->($self,$info->{name}=>$info);$event_types->[-1]=$next_event{$event_types->[-1]};$exp=$event_types->[-1]}return$exp}sub start_stream {my ($self)=@_;push @{$self->events},'STR';push @{$self->offset},-1;$self->callback->($self,'stream_start_event',{name=>'stream_start_event',})}sub start_document {my ($self,$implicit)=@_;push @{$self->events},'DOC';push @{$self->offset},-1;my$directive=$self->yaml_version_directive;my%directive;if ($directive){my ($major,$minor)=split m/\./,$self->yaml_version;%directive=(version_directive=>{major=>$major,minor=>$minor })}$self->callback->($self,'document_start_event',{name=>'document_start_event',implicit=>$implicit,%directive,});$self->set_yaml_version_directive(undef);$self->set_rule('FULLNODE');$self->set_new_node(1)}sub start_sequence {my ($self,$offset)=@_;my$offsets=$self->offset;if ($offsets->[-1]==$offset){push @{$self->events},'SEQ0'}else {push @{$self->events},'SEQ'}push @{$offsets},$offset;my$event_stack=$self->event_stack;my$info={name=>'sequence_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$self->node_properties($properties->[1],$info)}$self->callback->($self,'sequence_start_event',$info)}sub start_flow_sequence {my ($self,$offset)=@_;my$offsets=$self->offset;my$new_offset=$offsets->[-1];my$event_types=$self->events;if ($new_offset < 0){$new_offset=0}elsif ($self->new_node){if ($event_types->[-1]!~ m/^FLOW/){$new_offset++}}push @{$self->events},'FLOWSEQ';push @{$offsets},$new_offset;my$event_stack=$self->event_stack;my$info={style=>YAML_FLOW_SEQUENCE_STYLE,name=>'sequence_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($event_stack,$info)}$self->callback->($self,'sequence_start_event',$info)}sub start_flow_mapping {my ($self,$offset,$implicit_flowseq_map)=@_;my$offsets=$self->offset;my$new_offset=$offsets->[-1];my$event_types=$self->events;if ($new_offset < 0){$new_offset=0}elsif ($self->new_node){if ($event_types->[-1]!~ m/^FLOW/){$new_offset++}}push @{$self->events},$implicit_flowseq_map ? 'IMAP' : 'FLOWMAP';push @{$offsets},$new_offset;my$event_stack=$self->event_stack;my$info={name=>'mapping_start_event',style=>YAML_FLOW_MAPPING_STYLE };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($event_stack,$info)}$self->callback->($self,'mapping_start_event',$info)}sub end_flow_sequence {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'sequence_end_event' };$self->callback->($self,$info->{name},$info);if ($event_types->[-1]=~ m/^FLOW|^IMAP/){$event_types->[-1]=$next_event{$event_types->[-1]}}else {push @$event_types,'END_FLOW'}}sub end_flow_mapping {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'mapping_end_event' };$self->callback->($self,$info->{name},$info);if ($event_types->[-1]=~ m/^FLOW|^IMAP/){$event_types->[-1]=$next_event{$event_types->[-1]}}else {push @$event_types,'END_FLOW'}}sub cb_end_outer_flow {my ($self)=@_;my$event_types=$self->events;pop @$event_types;$event_types->[-1]=$next_event{$event_types->[-1]}}sub start_mapping {my ($self,$offset)=@_;my$offsets=$self->offset;push @{$self->events},'MAP';push @{$offsets},$offset;my$event_stack=$self->event_stack;my$info={name=>'mapping_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$self->node_properties($properties->[1],$info)}$self->callback->($self,'mapping_start_event',$info)}sub end_document {my ($self,$implicit)=@_;my$event_types=$self->events;if ($event_types->[-1]=~ m/FLOW/){die "Unexpected end of flow context"}if ($self->new_node){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}$self->remove_nodes(-1);if ($event_types->[-1]eq 'STR'){return}my$last=pop @{$event_types};if ($last ne 'DOC' and $last ne 'DOC_END'){$self->exception("Unexpected event type $last")}pop @{$self->offset};$self->callback->($self,'document_end_event',{name=>'document_end_event',implicit=>$implicit,});if ($self->yaml_version eq '1.2'){$self->set_tagmap({'!!'=>"tag:yaml.org,2002:" })}$event_types->[-1]=$next_event{$event_types->[-1]};$self->set_rule('STREAM')}sub end_stream {my ($self)=@_;my$last=pop @{$self->events};$self->exception("Unexpected event type $last")unless$last eq 'STR';pop @{$self->offset};$self->callback->($self,'stream_end_event',{name=>'stream_end_event',})}sub fetch_inline_properties {my ($self,$stack,$info)=@_;my$properties=$stack->[-1];$properties=$properties->[1];my$property_offset;if ($properties){for my$p (@{$properties->{inline}}){my$type=$p->{type};if (exists$info->{$type }){$self->exception("A node can only have one $type")}$info->{$type }=$p->{value};unless (defined$property_offset){$property_offset=$p->{offset};$info->{offset}=$p->{offset}}}delete$properties->{inline};undef$properties unless$properties->{newline}}unless ($properties){pop @$stack}}sub node_properties {my ($self,$properties,$info)=@_;if ($properties){for my$p (@{$properties->{newline}}){my$type=$p->{type};if (exists$info->{$type }){$self->exception("A node can only have one $type")}$info->{$type }=$p->{value}}undef$properties}}sub scalar_event {my ($self,$info)=@_;my$event_types=$self->events;my$event_stack=$self->event_stack;if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$properties=$self->node_properties($properties->[1],$info)}$info->{name}='scalar_event';$self->callback->($self,'scalar_event',$info);$self->set_new_node(0);$event_types->[-1]=$next_event{$event_types->[-1]}}sub alias_event {my ($self,$info)=@_;my$event_stack=$self->event_stack;if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->exception("Parse error: Alias not allowed in this context")}my$event_types=$self->events;$info->{name}='alias_event';$self->callback->($self,'alias_event',$info);$self->set_new_node(0);$event_types->[-1]=$next_event{$event_types->[-1]}}sub yaml_to_tokens {my ($class,$type,$input)=@_;my$yp=YAML::PP::Parser->new(receiver=>sub {});my@docs=eval {$type eq 'string' ? $yp->parse_string($input): $yp->parse_file($input)};my$error=$@;my$tokens=$yp->tokens;if ($error){my$remaining_tokens=$yp->_remaining_tokens;push @$tokens,map {+{%$_,name=>'ERROR' }}@$remaining_tokens}return$error,$tokens}sub _remaining_tokens {my ($self)=@_;my@tokens;my$next=$self->lexer->next_tokens;push@tokens,@$next;my$next_line=$self->lexer->next_line;my$remaining='';if ($next_line){if ($self->lexer->offset > 0){$remaining=$next_line->[1].$next_line->[2]}else {$remaining=join '',@$next_line}}$remaining .= $self->reader->read;$remaining='' unless defined$remaining;push@tokens,{name=>"ERROR",value=>$remaining };return \@tokens}sub event_to_test_suite {my ($self,$event)=@_;if (ref$event eq 'ARRAY'){return YAML::PP::Common::event_to_test_suite($event->[1])}return YAML::PP::Common::event_to_test_suite($event)}sub debug_events {my ($self)=@_;$self->note("EVENTS: (" .join (' | ',@{$_[0]->events}).')');$self->debug_offset}sub debug_offset {my ($self)=@_;$self->note(qq{OFFSET: (} .join (' | ',map {defined $_ ? sprintf "%-3d",$_ : '?'}@{$_[0]->offset}).qq/) level=@{[ $_[0]->level ]}]}/)}sub debug_yaml {my ($self)=@_;my$line=$self->lexer->line;$self->note("LINE NUMBER: $line");my$next_tokens=$self->lexer->next_tokens;if (@$next_tokens){$self->debug_tokens($next_tokens)}}sub debug_next_line {my ($self)=@_;my$next_line=$self->lexer->next_line || [];my$line=$next_line->[0];$line='' unless defined$line;$line =~ s/( +)$/'' x length $1/e;$line =~ s/\t//g;$self->note("NEXT LINE: >>$line<<")}sub note {my ($self,$msg)=@_;$self->_colorize_warn(["yellow"],"============ $msg")}sub info {my ($self,$msg)=@_;$self->_colorize_warn(["cyan"],"============ $msg")}sub got {my ($self,$msg)=@_;$self->_colorize_warn(["green"],"============ $msg")}sub _colorize_warn {my ($self,$colors,$text)=@_;require Term::ANSIColor;warn Term::ANSIColor::colored($colors,$text),"\n"}sub debug_event {my ($self,$event)=@_;my$str=YAML::PP::Common::event_to_test_suite($event);require Term::ANSIColor;warn Term::ANSIColor::colored(["magenta"],"============ $str"),"\n"}sub debug_rules {my ($self,$rules)=@_;local$Data::Dumper::Maxdepth=2;$self->note("RULES:");for my$rule ($rules){if (ref$rule eq 'ARRAY'){my$first=$rule->[0];if (ref$first eq 'SCALAR'){$self->info("-> $$first")}else {if (ref$first eq 'ARRAY'){$first=$first->[0]}$self->info("TYPE $first")}}else {eval {my@keys=sort keys %$rule;$self->info("@keys")}}}}sub debug_tokens {my ($self,$tokens)=@_;$tokens ||= $self->tokens;require Term::ANSIColor;for my$token (@$tokens){my$type=Term::ANSIColor::colored(["green"],sprintf "%-22s L %2d C %2d ",$token->{name},$token->{line},$token->{column}+ 1);local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;require Data::Dumper;my$str=Data::Dumper->Dump([$token->{value}],['str']);chomp$str;$str =~ s/(^.|.$)/Term::ANSIColor::colored(['blue'], $1)/ge;warn "$type$str\n"}}sub highlight_yaml {my ($self)=@_;require YAML::PP::Highlight;my$tokens=$self->tokens;my$highlighted=YAML::PP::Highlight->ansicolored($tokens);warn$highlighted}sub exception {my ($self,$msg,%args)=@_;my$next=$self->lexer->next_tokens;my$line=@$next ? $next->[0]->{line}: $self->lexer->line;my$offset=@$next ? $next->[0]->{column}: $self->lexer->offset;$offset++;my$next_line=$self->lexer->next_line;my$remaining='';if ($next_line){if ($self->lexer->offset > 0){$remaining=$next_line->[1].$next_line->[2]}else {$remaining=join '',@$next_line}}my$caller=$args{caller}|| [caller(0)];my$e=YAML::PP::Exception->new(got=>$args{got},expected=>$args{expected},line=>$line,column=>$offset,msg=>$msg,next=>$next,where=>$caller->[1].' line ' .$caller->[2],yaml=>$remaining,);croak$e}sub expected {my ($self,%args)=@_;my$expected=$args{expected};@$expected=sort grep {m/^[A-Z_]+$/}@$expected;my$got=$args{got}->{name};my@caller=caller(0);$self->exception("Expected (@$expected), but got $got",caller=>\@caller,expected=>$expected,got=>$args{got},)}sub cb_tag {my ($self,$token)=@_;my$stack=$self->event_stack;if (!@$stack or $stack->[-1]->[0]ne 'properties'){push @$stack,[properties=>{}]}my$last=$stack->[-1]->[1];my$tag=$self->_read_tag($token->{value},$self->tagmap);$last->{inline}||= [];push @{$last->{inline}},{type=>'tag',value=>$tag,offset=>$token->{column},}}sub _read_tag {my ($self,$tag,$map)=@_;if ($tag eq '!'){return "!"}elsif ($tag =~ m/^!<(.*)>/){return $1}elsif ($tag =~ m/^(![^!]*!|!)(.+)/){my$alias=$1;my$name=$2;$name =~ s/%([0-9a-fA-F]{2})/chr hex $1/eg;if (exists$map->{$alias }){$tag=$map->{$alias }.$name}else {if ($alias ne '!' and $alias ne '!!'){die "Found undefined tag handle '$alias'"}$tag="!$name"}}else {die "Invalid tag"}return$tag}sub cb_anchor {my ($self,$token)=@_;my$anchor=$token->{value};$anchor=substr($anchor,1);my$stack=$self->event_stack;if (!@$stack or $stack->[-1]->[0]ne 'properties'){push @$stack,[properties=>{}]}my$last=$stack->[-1]->[1];$last->{inline}||= [];push @{$last->{inline}},{type=>'anchor',value=>$anchor,offset=>$token->{column},}}sub cb_property_eol {my ($self,$res)=@_;my$stack=$self->event_stack;my$last=$stack->[-1]->[1];my$inline=delete$last->{inline}or return;my$newline=$last->{newline}||= [];push @$newline,@$inline}sub cb_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_send_mapkey {my ($self,$res)=@_;my$last=pop @{$self->event_stack};$self->scalar_event($last->[1]);$self->set_new_node(1)}sub cb_send_scalar {my ($self,$res)=@_;my$last=pop @{$self->event_stack};return unless$last;$self->scalar_event($last->[1]);my$e=$self->events;if ($e->[-1]eq 'IMAP'){$self->end_flow_mapping}}sub cb_empty_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info);$self->set_new_node(1)}sub cb_send_flow_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias })}sub cb_send_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias })}sub cb_send_alias_from_stack {my ($self,$token)=@_;my$last=pop @{$self->event_stack};$self->alias_event($last->[1])}sub cb_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);push @{$self->event_stack},[alias=>{value=>$alias,offset=>$token->{column},}]}sub cb_question {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_flow_question {my ($self,$res)=@_;$self->set_new_node(2)}sub cb_empty_complexvalue {my ($self,$res)=@_;$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}sub cb_questionstart {my ($self,$token)=@_;$self->start_mapping($token->{column})}sub cb_complexcolon {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_seqstart {my ($self,$token)=@_;my$column=$token->{column};$self->start_sequence($column);$self->set_new_node(1)}sub cb_seqitem {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_take_quoted {my ($self,$token)=@_;my$subtokens=$token->{subtokens};my$stack=$self->event_stack;my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_quoted_multiline {my ($self,$token)=@_;my$subtokens=$token->{subtokens};my$stack=$self->event_stack;my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_take_quoted_key {my ($self,$token)=@_;$self->cb_take_quoted($token);$self->cb_send_mapkey}sub cb_send_plain_multi {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_start_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_start_flowseq {my ($self,$token)=@_;$self->start_flow_sequence($token->{column})}sub cb_start_flowmap {my ($self,$token)=@_;$self->start_flow_mapping($token->{column})}sub cb_end_flowseq {my ($self,$res)=@_;$self->cb_send_scalar;$self->end_flow_sequence;$self->set_new_node(0)}sub cb_flow_comma {my ($self)=@_;my$event_types=$self->events;$self->set_new_node(0);if ($event_types->[-1]=~ m/^FLOWSEQ/){$self->cb_send_scalar;$event_types->[-1]=$next_event{$event_types->[-1]}}}sub cb_flow_colon {my ($self)=@_;$self->set_new_node(1)}sub cb_empty_flow_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_end_flowmap {my ($self,$res)=@_;$self->end_flow_mapping;$self->set_new_node(0)}sub cb_end_flowmap_empty {my ($self,$res)=@_;$self->cb_empty_flowmap_value;$self->end_flow_mapping;$self->set_new_node(0)}sub cb_flowkey_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_flowkey_quoted {my ($self,$token)=@_;my$stack=$self->event_stack;my$subtokens=$token->{subtokens};my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_empty_flowmap_key_value {my ($self,$token)=@_;$self->cb_empty_flow_mapkey($token);$self->cb_empty_flowmap_value;$self->cb_flow_comma}sub cb_end_empty_flowmap_key_value {my ($self,$token)=@_;$self->cb_empty_flow_mapkey($token);$self->cb_empty_flowmap_value;$self->cb_flow_comma;$self->cb_end_flowmap}sub cb_empty_flowmap_value {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_empty_flowseq_comma {my ($self,$token)=@_;$self->cb_empty_flowmap_value($token);$self->cb_flow_comma}sub cb_empty_flowseq_end {my ($self,$token)=@_;$self->cb_empty_flowmap_value($token);$self->cb_end_flowseq}sub cb_insert_map_alias {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_mapping($info->{offset});$self->alias_event($info);$self->set_new_node(1)}sub cb_insert_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_mapping($info->{offset});$self->scalar_event($info);$self->set_new_node(1)}sub cb_insert_implicit_flowseq_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_flow_mapping($info->{offset},1);$self->scalar_event($info);$self->set_new_node(1)}sub cb_insert_empty_implicit_flowseq_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_flow_mapping($info->{offset},1);$self->cb_empty_flowmap_value;$self->set_new_node(2)}sub cb_insert_empty_map {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->start_mapping($info->{offset});$self->scalar_event($info);$self->set_new_node(1)}sub cb_send_block_scalar {my ($self,$token)=@_;my$type=$token->{subtokens}->[0]->{value};my$stack=$self->event_stack;my$info={style=>$type eq '|' ? YAML_LITERAL_SCALAR_STYLE : YAML_FOLDED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$self->event_stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_end_document {my ($self,$token)=@_;$self->end_document(0)}sub cb_end_document_empty {my ($self,$token)=@_;$self->end_document(0)}sub cb_doc_start_implicit {my ($self,$token)=@_;$self->start_document(1)}sub cb_doc_start_explicit {my ($self,$token)=@_;$self->start_document(0)}sub cb_end_doc_start_document {my ($self,$token)=@_;$self->end_document(1);$self->start_document(0)}sub cb_tag_directive {my ($self,$token)=@_;my ($name,$tag_alias,$tag_url)=split ' ',$token->{value};$self->tagmap->{$tag_alias }=$tag_url}sub cb_reserved_directive {}sub cb_set_yaml_version_directive {my ($self,$token)=@_;if ($self->yaml_version_directive){croak "Found duplicate YAML directive"}my ($version)=$token->{value}=~ m/^%YAML[ \t]+(1\.[12])/;$self->set_yaml_version($version);$self->set_yaml_version_directive(1)}1;
YAML_PP_PARSER

$fatpacked{"YAML/PP/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PERL';
  use strict;use warnings;package YAML::PP::Perl;our$VERSION='0.031';use base 'Exporter';use base 'YAML::PP';our@EXPORT_OK=qw/Load Dump LoadFile DumpFile/;use YAML::PP;use YAML::PP::Schema::Perl;sub new {my ($class,%args)=@_;$args{schema}||= [qw/Core Perl/];$class->SUPER::new(%args)}sub Load {my ($yaml)=@_;__PACKAGE__->new->load_string($yaml)}sub LoadFile {my ($file)=@_;__PACKAGE__->new->load_file($file)}sub Dump {my (@data)=@_;__PACKAGE__->new->dump_string(@data)}sub DumpFile {my ($file,@data)=@_;__PACKAGE__->new->dump_file($file,@data)}1;
YAML_PP_PERL

$fatpacked{"YAML/PP/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_READER';
  use strict;use warnings;package YAML::PP::Reader;our$VERSION='0.031';sub input {return $_[0]->{input}}sub set_input {$_[0]->{input}=$_[1]}sub new {my ($class,%args)=@_;my$input=delete$args{input};return bless {input=>$input,},$class}sub read {my ($self)=@_;my$pos=pos$self->{input}|| 0;my$yaml=substr($self->{input},$pos);$self->{input}='';return$yaml}sub readline {my ($self)=@_;unless (length$self->{input}){return}if ($self->{input}=~ m/\G([^\r\n]*(?:\n|\r\n|\r|\z))/g){my$line=$1;unless (length$line){$self->{input}='';return}return$line}return}package YAML::PP::Reader::File;use Scalar::Util qw/openhandle/;our@ISA=qw/YAML::PP::Reader/;use Carp qw/croak/;sub open_handle {if (openhandle($_[0]->{input})){return $_[0]->{input}}open my$fh,'<:encoding(UTF-8)',$_[0]->{input}or croak "Could not open '$_[0]->{input}' for reading: $!";return$fh}sub read {my$fh=$_[0]->{filehandle}||= $_[0]->open_handle;if (wantarray){my@yaml=<$fh>;return@yaml}else {local $/;my$yaml=<$fh>;return$yaml}}sub readline {my$fh=$_[0]->{filehandle}||= $_[0]->open_handle;return scalar <$fh>}1;
YAML_PP_READER

$fatpacked{"YAML/PP/Render.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_RENDER';
  use strict;use warnings;package YAML::PP::Render;our$VERSION='0.031';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;sub render_quoted {my ($self,$style,$lines)=@_;my$quoted='';my$addspace=0;for my$i (0 .. $#$lines){my$line=$lines->[$i ];my$value=$line->{value};my$last=$i==$#$lines;my$first=$i==0;if ($value eq ''){if ($first){$addspace=1}elsif ($last){$quoted .= ' ' if$addspace}else {$addspace=0;$quoted .= "\n"}next}$quoted .= ' ' if$addspace;$addspace=1;if ($style eq '"'){if ($line->{orig}=~ m/\\$/){$line->{value}=~ s/\\$//;$value =~ s/\\$//;$addspace=0}}$quoted .= $value}return$quoted}sub render_block_scalar {my ($self,$block_type,$chomp,$lines)=@_;my ($folded,$keep,$trim);if ($block_type eq '>'){$folded=1}if ($chomp eq '+'){$keep=1}elsif ($chomp eq '-'){$trim=1}my$string='';if (not $keep){while (@$lines){last if$lines->[-1]ne '';pop @$lines}}if ($folded){my$prev='START';for my$i (0 .. $#$lines){my$line=$lines->[$i ];my$type=$line eq '' ? 'EMPTY' : $line =~ m/\A[ \t]/ ? 'MORE' : 'CONTENT';if ($prev eq 'MORE' and $type eq 'EMPTY'){$type='MORE'}elsif ($prev eq 'CONTENT'){if ($type ne 'CONTENT'){$string .= "\n"}elsif ($type eq 'CONTENT'){$string .= ' '}}elsif ($prev eq 'START' and $type eq 'EMPTY'){$string .= "\n";$type='START'}elsif ($prev eq 'EMPTY' and $type ne 'CONTENT'){$string .= "\n"}$string .= $line;if ($type eq 'MORE' and $i < $#$lines){$string .= "\n"}$prev=$type}$string .= "\n" if @$lines and not $trim}else {for my$i (0 .. $#$lines){$string .= $lines->[$i ];$string .= "\n" if ($i!=$#$lines or not $trim)}}TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$string],['string']);return$string}sub render_multi_val {my ($self,$multi)=@_;my$string='';my$start=1;for my$line (@$multi){if (not $start){if ($line eq ''){$string .= "\n";$start=1}else {$string .= " $line"}}else {$string .= $line;$start=0}}return$string}1;
YAML_PP_RENDER

$fatpacked{"YAML/PP/Representer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_REPRESENTER';
  use strict;use warnings;package YAML::PP::Representer;our$VERSION='0.031';use Scalar::Util qw/reftype blessed refaddr/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_ANY_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use B;sub new {my ($class,%args)=@_;my$preserve=delete$args{preserve}|| 0;if ($preserve==1){$preserve=PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS}my$self=bless {schema=>delete$args{schema},preserve=>$preserve,},$class;if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}return$self}sub clone {my ($self)=@_;my$clone={schema=>$self->schema,preserve=>$self->{preserve},};return bless$clone,ref$self}sub schema {return $_[0]->{schema}}sub preserve_order {return $_[0]->{preserve}& PRESERVE_ORDER}sub preserve_scalar_style {return $_[0]->{preserve}& PRESERVE_SCALAR_STYLE}sub preserve_flow_style {return $_[0]->{preserve}& PRESERVE_FLOW_STYLE}sub preserve_alias {return $_[0]->{preserve}& PRESERVE_ALIAS}sub represent_node {my ($self,$node)=@_;my$preserve_alias=$self->preserve_alias;my$preserve_style=$self->preserve_scalar_style;if ($preserve_style or $preserve_alias){if (ref$node->{value}eq 'YAML::PP::Preserve::Scalar'){my$value=$node->{value}->value;if ($preserve_style and $node->{value}->style!=YAML_FOLDED_SCALAR_STYLE){$node->{style}=$node->{value}->style}$node->{value}=$value}}$node->{reftype}=reftype($node->{value});if (not $node->{reftype}and reftype(\$node->{value})eq 'GLOB'){$node->{reftype}='GLOB'}if ($node->{reftype}){$self->represent_noderef($node)}else {$self->represent_node_nonref($node)}$node->{reftype}=(reftype$node->{data})|| '';if ($node->{reftype}eq 'HASH' and my$tied=tied(%{$node->{data}})){my$representers=$self->schema->representers;$tied=ref$tied;if (my$def=$representers->{tied_equals}->{$tied }){my$code=$def->{code};my$done=$code->($self,$node)}}if ($node->{reftype}eq 'HASH'){unless (defined$node->{items}){my@keys;if ($self->preserve_order){@keys=keys %{$node->{data}}}else {@keys=sort keys %{$node->{data}}}for my$key (@keys){push @{$node->{items}},$key,$node->{data}->{$key }}}my%args;if ($self->preserve_flow_style and reftype$node->{value}eq 'HASH'){if (my$tied=tied %{$node->{value}}){$args{style}=$tied->{style}}}return [mapping=>$node,%args ]}elsif ($node->{reftype}eq 'ARRAY'){unless (defined$node->{items}){@{$node->{items}}=@{$node->{data}}}my%args;if ($self->preserve_flow_style and reftype$node->{value}eq 'ARRAY'){if (my$tied=tied @{$node->{value}}){$args{style}=$tied->{style}}}return [sequence=>$node,%args ]}elsif ($node->{reftype}){die "Cannot handle reftype '$node->{reftype}' (you might want to enable YAML::PP::Schema::Perl)"}else {unless (defined$node->{items}){$node->{items}=[$node->{data}]}return [scalar=>$node ]}}sub represent_node_nonref {my ($self,$node)=@_;my$representers=$self->schema->representers;if (not defined$node->{value}){if (my$undef=$representers->{undef}){return 1 if$undef->($self,$node)}else {$node->{style}=YAML_SINGLE_QUOTED_SCALAR_STYLE;$node->{data}='';return 1}}for my$rep (@{$representers->{flags}}){my$check_flags=$rep->{flags};my$flags=B::svref_2object(\$node->{value})->FLAGS;if ($flags & $check_flags){return 1 if$rep->{code}->($self,$node)}}if (my$rep=$representers->{equals}->{$node->{value}}){return 1 if$rep->{code}->($self,$node)}for my$rep (@{$representers->{regex}}){if ($node->{value}=~ $rep->{regex}){return 1 if$rep->{code}->($self,$node)}}unless (defined$node->{data}){$node->{data}=$node->{value}}unless (defined$node->{style}){$node->{style}=YAML_ANY_SCALAR_STYLE;$node->{style}=""}}sub represent_noderef {my ($self,$node)=@_;my$representers=$self->schema->representers;if (my$classname=blessed($node->{value})){if (my$def=$representers->{class_equals}->{$classname }){my$code=$def->{code};return 1 if$code->($self,$node)}for my$matches (@{$representers->{class_matches}}){my ($re,$code)=@$matches;if (ref$re and $classname =~ $re or $re){return 1 if$code->($self,$node)}}for my$isa (@{$representers->{class_isa}}){my ($class_name,$code)=@$isa;if ($node->{value }->isa($class_name)){return 1 if$code->($self,$node)}}}if ($node->{reftype}eq 'SCALAR' and my$scalarref=$representers->{scalarref}){my$code=$scalarref->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'REF' and my$refref=$representers->{refref}){my$code=$refref->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'CODE' and my$coderef=$representers->{coderef}){my$code=$coderef->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'GLOB' and my$glob=$representers->{glob}){my$code=$glob->{code};return 1 if$code->($self,$node)}$node->{data}=$node->{value}}1;
YAML_PP_REPRESENTER

$fatpacked{"YAML/PP/Schema.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA';
  use strict;use warnings;package YAML::PP::Schema;use B;use Module::Load qw//;our$VERSION='0.031';use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;use Scalar::Util qw/blessed/;sub new {my ($class,%args)=@_;my$yaml_version=delete$args{yaml_version};my$bool=delete$args{boolean};$bool='perl' unless defined$bool;if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$true;my$false;my$bool_class='';if ($bool eq 'JSON::PP'){require JSON::PP;$true=\&bool_jsonpp_true;$false=\&bool_jsonpp_false;$bool_class='JSON::PP::Boolean'}elsif ($bool eq 'boolean'){require boolean;$true=\&bool_booleanpm_true;$false=\&bool_booleanpm_false;$bool_class='boolean'}elsif ($bool eq 'perl'){$true=\&bool_perl_true;$false=\&bool_perl_false}else {die "Invalid value for 'boolean': '$bool'. Allowed: ('perl', 'boolean', 'JSON::PP')"}my%representers=('undef'=>undef,flags=>[],equals=>{},regex=>[],class_equals=>{},class_matches=>[],class_isa=>[],scalarref=>undef,refref=>undef,coderef=>undef,glob=>undef,tied_equals=>{},);my$self=bless {yaml_version=>$yaml_version,resolvers=>{},representers=>\%representers,true=>$true,false=>$false,bool_class=>$bool_class,},$class;return$self}sub resolvers {return $_[0]->{resolvers}}sub representers {return $_[0]->{representers}}sub true {return $_[0]->{true}}sub false {return $_[0]->{false}}sub bool_class {return $_[0]->{bool_class}}sub yaml_version {return $_[0]->{yaml_version}}my%LOADED_SCHEMA=(JSON=>1,);my%DEFAULT_SCHEMA=('1.2'=>'Core','1.1'=>'YAML1_1',);sub load_subschemas {my ($self,@schemas)=@_;my$yaml_version=$self->yaml_version;my$i=0;while ($i < @schemas){my$item=$schemas[$i ];if ($item eq '+'){$item=$DEFAULT_SCHEMA{$yaml_version }}$i++;if (blessed($item)){$item->register(schema=>$self,);next}my@options;while ($i < @schemas and ($schemas[$i ]=~ m/^[^A-Za-z]/ or $schemas[$i ]=~ m/^[a-zA-Z0-9]+=/)){push@options,$schemas[$i ];$i++}my$class;if ($item =~ m/^\:(.*)/){$class="$1";unless ($class =~ m/\A[A-Za-z0-9_:]+\z/){die "Module name '$class' is invalid"}Module::Load::load$class}else {$class="YAML::PP::Schema::$item";unless ($class =~ m/\A[A-Za-z0-9_:]+\z/){die "Module name '$class' is invalid"}$LOADED_SCHEMA{$item }||= Module::Load::load$class}$class->register(schema=>$self,options=>\@options,)}}sub add_resolver {my ($self,%args)=@_;my$tag=$args{tag};my$rule=$args{match};my$resolvers=$self->resolvers;my ($type,@rule)=@$rule;my$implicit=$args{implicit};$implicit=1 unless defined$implicit;my$resolver_list=[];if ($tag){if (ref$tag eq 'Regexp'){my$res=$resolvers->{tags}||= [];push @$res,[$tag,{}];push @$resolver_list,$res->[-1]->[1]}else {my$res=$resolvers->{tag}->{$tag }||= {};push @$resolver_list,$res}}if ($implicit){push @$resolver_list,$resolvers->{value}||= {}}for my$res (@$resolver_list){if ($type eq 'equals'){my ($match,$value)=@rule;unless (exists$res->{equals}->{$match }){$res->{equals}->{$match }=$value}next}elsif ($type eq 'regex'){my ($match,$value)=@rule;push @{$res->{regex}},[$match=>$value ]}elsif ($type eq 'all'){my ($value)=@rule;$res->{all}=$value}}}sub add_sequence_resolver {my ($self,%args)=@_;return$self->add_collection_resolver(sequence=>%args)}sub add_mapping_resolver {my ($self,%args)=@_;return$self->add_collection_resolver(mapping=>%args)}sub add_collection_resolver {my ($self,$type,%args)=@_;my$tag=$args{tag};my$implicit=$args{implicit};my$resolvers=$self->resolvers;if ($tag and ref$tag eq 'Regexp'){my$res=$resolvers->{$type }->{tags}||= [];push @$res,[$tag,{on_create=>$args{on_create},on_data=>$args{on_data},}]}elsif ($tag){my$res=$resolvers->{$type }->{tag}->{$tag }||= {on_create=>$args{on_create},on_data=>$args{on_data},}}}sub add_representer {my ($self,%args)=@_;my$representers=$self->representers;if (my$flags=$args{flags}){my$rep=$representers->{flags};push @$rep,\%args;return}if (my$regex=$args{regex}){my$rep=$representers->{regex};push @$rep,\%args;return}if (my$regex=$args{class_matches}){my$rep=$representers->{class_matches};push @$rep,[$args{class_matches},$args{code}];return}if (my$class_equals=$args{class_equals}){my$rep=$representers->{class_equals};$rep->{$class_equals }={code=>$args{code},};return}if (my$class_isa=$args{class_isa}){my$rep=$representers->{class_isa};push @$rep,[$args{class_isa},$args{code}];return}if (my$tied_equals=$args{tied_equals}){my$rep=$representers->{tied_equals};$rep->{$tied_equals }={code=>$args{code},};return}if (defined(my$equals=$args{equals})){my$rep=$representers->{equals};$rep->{$equals }={code=>$args{code},};return}if (defined(my$scalarref=$args{scalarref})){$representers->{scalarref}={code=>$args{code},};return}if (defined(my$refref=$args{refref})){$representers->{refref}={code=>$args{code},};return}if (defined(my$coderef=$args{coderef})){$representers->{coderef}={code=>$args{code},};return}if (defined(my$glob=$args{glob})){$representers->{glob}={code=>$args{code},};return}if (my$undef=$args{undefined}){$representers->{undef}=$undef;return}}sub load_scalar {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$value=$event->{value};my$resolvers=$self->resolvers;my$res;if ($tag){$res=$resolvers->{tag}->{$tag };if (not $res and my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$rule)=@$match;if ($tag =~ $re){$res=$rule;last}}}}else {$res=$resolvers->{value};if ($event->{style}ne YAML_PLAIN_SCALAR_STYLE){return$value}}if (my$equals=$res->{equals}){if (exists$equals->{$value }){my$res=$equals->{$value };if (ref$res eq 'CODE'){return$res->($constructor,$event)}return$res}}if (my$regex=$res->{regex}){for my$item (@$regex){my ($re,$sub)=@$item;my@matches=$value =~ $re;if (@matches){return$sub->($constructor,$event,\@matches)}}}if (my$catch_all=$res->{all}){if (ref$catch_all eq 'CODE'){return$catch_all->($constructor,$event)}return$catch_all}return$value}sub create_sequence {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$data=[];my$on_data;my$resolvers=$self->resolvers->{sequence};if ($tag){if (my$equals=$resolvers->{tag}->{$tag }){my$on_create=$equals->{on_create};$on_data=$equals->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}if (my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$actions)=@$match;my$on_create=$actions->{on_create};if ($tag =~ $re){$on_data=$actions->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}}}}return ($data,$on_data)}sub create_mapping {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$data={};my$on_data;my$resolvers=$self->resolvers->{mapping};if ($tag){if (my$equals=$resolvers->{tag}->{$tag }){my$on_create=$equals->{on_create};$on_data=$equals->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}if (my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$actions)=@$match;my$on_create=$actions->{on_create};if ($tag =~ $re){$on_data=$actions->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}}}}return ($data,$on_data)}sub bool_jsonpp_true {JSON::PP::true()}sub bool_booleanpm_true {boolean::true()}sub bool_perl_true {1}sub bool_jsonpp_false {JSON::PP::false()}sub bool_booleanpm_false {boolean::false()}sub bool_perl_false {!1}1;
YAML_PP_SCHEMA

$fatpacked{"YAML/PP/Schema/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_BINARY';
  use strict;use warnings;package YAML::PP::Schema::Binary;our$VERSION='0.031';use MIME::Base64 qw/decode_base64 encode_base64/;use YAML::PP::Common qw/YAML_ANY_SCALAR_STYLE/;sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:binary',match=>[all=>sub {my ($constructor,$event)=@_;my$base64=$event->{value};my$binary=decode_base64($base64);return$binary}],implicit=>0,);$schema->add_representer(regex=>qr{.*},code=>sub {my ($rep,$node)=@_;my$binary=$node->{value};unless ($binary =~ m/[\x{7F}-\x{10FFFF}]/){return}if (utf8::is_utf8($binary)){return}my$base64=encode_base64($binary);$node->{style}=YAML_ANY_SCALAR_STYLE;$node->{data}=$base64;$node->{tag}="tag:yaml.org,2002:binary";return 1},)}1;
YAML_PP_SCHEMA_BINARY

$fatpacked{"YAML/PP/Schema/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_CORE';
  use strict;use warnings;package YAML::PP::Schema::Core;our$VERSION='0.031';use YAML::PP::Schema::JSON qw/represent_int represent_float represent_literal represent_bool represent_undef/;use B;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;my$RE_INT_CORE=qr{^([+-]?(?:[0-9]+))$};my$RE_FLOAT_CORE=qr{^([+-]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][+-]?[0-9]+)?)$};my$RE_INT_OCTAL=qr{^0o([0-7]+)$};my$RE_INT_HEX=qr{^0x([0-9a-fA-F]+)$};sub _from_oct {oct $_[2]->[0]}sub _from_hex {hex $_[2]->[0]}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>$_=>undef ],)for (qw/null NULL Null ~/,'');$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->true ],)for (qw/true TRUE True/);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->false ],)for (qw/false FALSE False/);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_CORE=>\&YAML::PP::Schema::JSON::_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_OCTAL=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_HEX=>\&_from_hex ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT_CORE=>\&YAML::PP::Schema::JSON::_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "inf" ],)for (qw/.inf .Inf .INF +.inf +.Inf +.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 - "inf" ],)for (qw/-.inf -.Inf -.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "nan" ],)for (qw/.nan .NaN .NAN/);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(undefined=>\&represent_undef,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true TRUE True false FALSE False null NULL Null ~ .inf .Inf .INF +.inf +.Inf +.INF -.inf -.Inf -.INF .nan .NaN .NAN/);$schema->add_representer(regex=>qr{$RE_INT_CORE|$RE_FLOAT_CORE|$RE_INT_OCTAL|$RE_INT_HEX},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}1;
YAML_PP_SCHEMA_CORE

$fatpacked{"YAML/PP/Schema/Failsafe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_FAILSAFE';
  use strict;use warnings;package YAML::PP::Schema::Failsafe;our$VERSION='0.031';sub register {my ($self,%args)=@_;return}1;
YAML_PP_SCHEMA_FAILSAFE

$fatpacked{"YAML/PP/Schema/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_INCLUDE';
  use strict;use warnings;package YAML::PP::Schema::Include;our$VERSION='0.031';use Carp qw/croak/;use Scalar::Util qw/weaken/;use File::Basename qw/dirname/;sub new {my ($class,%args)=@_;my$paths=delete$args{paths};if (defined$paths){unless (ref$paths eq 'ARRAY'){$paths=[$paths]}}else {$paths=[]}my$allow_absolute=$args{allow_absolute}|| 0;my$loader=$args{loader}|| \&default_loader;my$self=bless {paths=>$paths,allow_absolute=>$allow_absolute,last_includes=>[],cached=>{},loader=>$loader,},$class;return$self}sub init {my ($self)=@_;$self->{last_includes}=[];$self->{cached}=[]}sub paths {$_[0]->{paths}}sub allow_absolute {$_[0]->{allow_absolute}}sub yp {my ($self,$yp)=@_;if (@_==2){$self->{yp}=$yp;weaken$self->{yp};return$yp}return$self->{yp}}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'!include',match=>[all=>sub {$self->include(@_)}],implicit=>0,)}sub include {my ($self,$constructor,$event)=@_;my$yp=$self->yp;my$search_paths=$self->paths;my$allow_absolute=$self->allow_absolute;my$relative=not @$search_paths;if ($relative){my$last_includes=$self->{last_includes};if (@$last_includes){$search_paths=[$last_includes->[-1]]}else {my$filename=$yp->loader->filename;$search_paths=[dirname$filename]}}my$filename=$event->{value};my$fullpath;if (File::Spec->file_name_is_absolute($filename)){unless ($allow_absolute){croak "Absolute filenames not allowed"}$fullpath=$filename}else {my@paths=File::Spec->splitdir($filename);unless ($allow_absolute){@paths=File::Spec->no_upwards(@paths)}for my$candidate (@$search_paths){my$test=File::Spec->catfile($candidate,@paths);if (-e $test){$fullpath=$test;last}}croak "File '$filename' not found" unless defined$fullpath}if ($self->{cached}->{$fullpath }++){croak "Circular include '$fullpath'"}if ($relative){push @{$self->{last_includes}},dirname$fullpath}my$clone=$yp->clone;my ($data)=$self->loader->($clone,$fullpath);if ($relative){pop @{$self->{last_includes}}}unless (--$self->{cached}->{$fullpath }){delete$self->{cached}->{$fullpath }}return$data}sub loader {my ($self,$code)=@_;if (@_==2){$self->{loader}=$code;return$code}return$self->{loader}}sub default_loader {my ($yp,$filename)=@_;$yp->load_file($filename)}1;
YAML_PP_SCHEMA_INCLUDE

$fatpacked{"YAML/PP/Schema/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_JSON';
  use strict;use warnings;package YAML::PP::Schema::JSON;our$VERSION='0.031';use base 'Exporter';our@EXPORT_OK=qw/represent_int represent_float represent_literal represent_bool represent_undef/;use B;use Carp qw/croak/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE/;my$RE_INT=qr{^(-?(?:0|[1-9][0-9]*))$};my$RE_FLOAT=qr{^(-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)$};sub _to_int {0 + $_[2]->[0]}sub _to_float {unpack F=>pack F=>$_[2]->[0]}sub register {my ($self,%args)=@_;my$schema=$args{schema};my$options=$args{options};my$empty_null=0;for my$opt (@$options){if ($opt eq 'empty=str'){}elsif ($opt eq 'empty=null'){$empty_null=1}else {croak "Invalid option for JSON Schema: '$opt'"}}$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>null=>undef ],);if ($empty_null){$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>''=>undef ],implicit=>1,)}else {$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[equals=>''=>'' ],implicit=>1,)}$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>true=>$schema->true ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>false=>$schema->false ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT=>\&_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT=>\&_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],);$schema->add_representer(undefined=>\&represent_undef,);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);my%special=((0+'nan').''=>'.nan',(0+'inf').''=>'.inf',(0-'inf').''=>'-.inf');$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true false null/);$schema->add_representer(regex=>qr{$RE_INT|$RE_FLOAT},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}sub represent_undef {my ($rep,$node)=@_;$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}='null';return 1}sub represent_literal {my ($rep,$node)=@_;$node->{style}||= YAML_SINGLE_QUOTED_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}sub represent_int {my ($rep,$node)=@_;if (int($node->{value})ne $node->{value}){return 0}$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}my%special=((0+'nan').''=>'.nan',(0+'inf').''=>'.inf',(0-'inf').''=>'-.inf');sub represent_float {my ($rep,$node)=@_;if (exists$special{$node->{value}}){$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}=$special{$node->{value}};return 1}if (0.0 + $node->{value}ne $node->{value}){return 0}if (int($node->{value})eq $node->{value}and not $node->{value}=~ m/\./){$node->{value}.= '.0'}$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}sub represent_bool {my ($rep,$node)=@_;my$string=$node->{value}? 'true' : 'false';$node->{style}=YAML_PLAIN_SCALAR_STYLE;@{$node->{items}}=$string;$node->{data}=$string;return 1}1;
YAML_PP_SCHEMA_JSON

$fatpacked{"YAML/PP/Schema/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_MERGE';
  use strict;use warnings;package YAML::PP::Schema::Merge;our$VERSION='0.031';use YAML::PP::Type::MergeKey;sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:merge',match=>[equals=>'<<'=>YAML::PP::Type::MergeKey->new ],)}1;
YAML_PP_SCHEMA_MERGE

$fatpacked{"YAML/PP/Schema/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_PERL';
  use strict;use warnings;package YAML::PP::Schema::Perl;our$VERSION='0.031';use Scalar::Util qw/blessed reftype/;my$qr_prefix;{$qr_prefix=qr{\(\?-xism\:};if ($] >= 5.014){$qr_prefix=qr{\(\?\^(?:[uadl])?\:}}}sub new {my ($class,%args)=@_;my$tags=$args{tags}|| [];my$loadcode=$args{loadcode};$loadcode ||= 0;my$classes=$args{classes};my$self=bless {tags=>$tags,loadcode=>$loadcode,classes=>$classes,},$class}sub register {my ($self,%args)=@_;my$schema=$args{schema};my$tags;my$loadcode=0;my$classes;if (blessed($self)){$tags=$self->{tags};@$tags=('!perl')unless @$tags;$loadcode=$self->{loadcode};$classes=$self->{classes}}else {my$options=$args{options};my$tagtype='!perl';for my$option (@$options){if ($option =~ m/^tags?=(.+)$/){$tagtype=$1}elsif ($option eq '+loadcode'){$loadcode=1}}$tags=[split m/\+/,$tagtype]}my$perl_tag;my%tagtypes;my@perl_tags;for my$type (@$tags){if ($type eq '!perl'){$perl_tag ||= $type;push@perl_tags,'!perl'}elsif ($type eq '!!perl'){$perl_tag ||= 'tag:yaml.org,2002:perl';push@perl_tags,'tag:yaml.org,2002:perl'}else {die "Invalid tagtype '$type'"}$tagtypes{$type }=1}my$perl_regex='!perl';if ($tagtypes{'!perl'}and $tagtypes{'!!perl'}){$perl_regex='(?:tag:yaml\\.org,2002:|!)perl'}elsif ($tagtypes{'!perl'}){$perl_regex='!perl'}elsif ($tagtypes{'!!perl'}){$perl_regex='tag:yaml\\.org,2002:perl'}my$class_regex=qr{.+};my$no_objects=0;if ($classes){if (@$classes){$class_regex='(' .join('|',map "\Q$_\E",@$classes).')'}else {$no_objects=1;$class_regex=''}}if ($loadcode){my$load_code=sub {my ($constructor,$event)=@_;return$self->evaluate_code($event->{value})};my$load_code_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/code:}{};my$sub=$self->evaluate_code($event->{value});return$self->object($sub,$class)};$schema->add_resolver(tag=>"$_/code",match=>[all=>$load_code],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/code:$class_regex$},match=>[all=>$load_code_blessed ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/code:.+},match=>[all=>$load_code ],implicit=>0,)if$no_objects}else {my$loadcode_dummy=sub {return sub {}};my$loadcode_blessed_dummy=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/code:}{};return$self->object(sub {},$class)};$schema->add_resolver(tag=>"$_/code",match=>[all=>$loadcode_dummy ],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/code:$class_regex$},match=>[all=>$loadcode_blessed_dummy ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/code:.+},match=>[all=>$loadcode_dummy ],implicit=>0,)if$no_objects}my$load_glob=sub {my$value=undef;return \$value};my$load_glob_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/glob:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/glob",on_create=>$load_glob,on_data=>sub {my ($constructor,$ref,$list)=@_;$$ref=$self->construct_glob($list)},)for@perl_tags;if ($no_objects){$schema->add_mapping_resolver(tag=>qr{^$perl_regex/glob:.+$},on_create=>$load_glob,on_data=>sub {my ($constructor,$ref,$list)=@_;$$ref=$self->construct_glob($list)},)}else {$schema->add_mapping_resolver(tag=>qr{^$perl_regex/glob:$class_regex$},on_create=>$load_glob_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_glob($list)},)}my$load_regex=sub {my ($constructor,$event)=@_;return$self->construct_regex($event->{value})};my$load_regex_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/regexp:}{};my$qr=$self->construct_regex($event->{value});return$self->object($qr,$class)};$schema->add_resolver(tag=>"$_/regexp",match=>[all=>$load_regex ],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/regexp:$class_regex$},match=>[all=>$load_regex_blessed ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/regexp:$class_regex$},match=>[all=>$load_regex ],implicit=>0,)if$no_objects;my$load_sequence=sub {return []};my$load_sequence_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/array:}{};return$self->object([],$class)};$schema->add_sequence_resolver(tag=>"$_/array",on_create=>$load_sequence,)for@perl_tags;$schema->add_sequence_resolver(tag=>qr{^$perl_regex/array:$class_regex$},on_create=>$load_sequence_blessed,);$schema->add_sequence_resolver(tag=>qr{^$perl_regex/array:.+$},on_create=>$load_sequence,)if$no_objects;my$load_mapping=sub {return {}};my$load_mapping_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/hash:}{};return$self->object({},$class)};$schema->add_mapping_resolver(tag=>"$_/hash",on_create=>$load_mapping,)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/hash:$class_regex$},on_create=>$load_mapping_blessed,);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/hash:.+$},on_create=>$load_mapping,)if$no_objects;my$load_ref=sub {my$value=undef;return \$value};my$load_ref_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/ref:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/ref",on_create=>$load_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/ref:$class_regex$},on_create=>$load_ref_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/ref:.+$},on_create=>$load_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},)if$no_objects;my$load_scalar_ref=sub {my$value=undef;return \$value};my$load_scalar_ref_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/scalar:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/scalar",on_create=>$load_scalar_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/scalar:$class_regex$},on_create=>$load_scalar_ref_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/scalar:.+$},on_create=>$load_scalar_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},)if$no_objects;$schema->add_representer(scalarref=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/scalar";$node->{data}=$self->represent_scalar($node->{value})},);$schema->add_representer(refref=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/ref";$node->{data}=$self->represent_ref($node->{value})},);$schema->add_representer(coderef=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/code";$node->{data}=$self->represent_code($node->{value})},);$schema->add_representer(glob=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/glob";$node->{data}=$self->represent_glob($node->{value})},);$schema->add_representer(class_matches=>1,code=>sub {my ($rep,$node)=@_;my$blessed=blessed$node->{value};my$tag_blessed=":$blessed";if ($blessed !~ m/^$class_regex$/){$tag_blessed=''}$node->{tag}=sprintf "$perl_tag/%s%s",lc($node->{reftype}),$tag_blessed;if ($node->{reftype}eq 'HASH'){$node->{data}=$node->{value}}elsif ($node->{reftype}eq 'ARRAY'){$node->{data}=$node->{value}}elsif ($node->{reftype}eq 'REGEXP'){if ($blessed eq 'Regexp'){$node->{tag}=$perl_tag ."/regexp"}$node->{data}=$self->represent_regex($node->{value})}elsif ($node->{reftype}eq 'SCALAR'){if ($blessed eq 'Regexp'){$node->{tag}=$perl_tag .'/regexp';$node->{data}=$self->represent_regex($node->{value})}elsif ($] <= 5.010001 and not defined ${$node->{value}}and $node->{value}=~ m/^\(\?/){$node->{tag}=$perl_tag .'/regexp' .$tag_blessed;$node->{data}=$self->represent_regex($node->{value})}else {$node->{data}=$self->represent_scalar($node->{value})}}elsif ($node->{reftype}eq 'REF'){$node->{data}=$self->represent_ref($node->{value})}elsif ($node->{reftype}eq 'CODE'){$node->{data}=$self->represent_code($node->{value})}elsif ($node->{reftype}eq 'GLOB'){$node->{data}=$self->represent_glob($node->{value})}else {die "Reftype '$node->{reftype}' not implemented"}return 1},);return}sub evaluate_code {my ($self,$code)=@_;unless ($code =~ m/^ \s* \{ .* \} \s* \z/xs){die "Malformed code"}$code="sub $code";my$sub=eval$code;if ($@){die "Couldn't eval code: $@>>$code<<"}return$sub}sub construct_regex {my ($self,$regex)=@_;if ($regex =~ m/^$qr_prefix(.*)\)\z/s){$regex=$1}my$qr=qr{$regex};return$qr}sub construct_glob {my ($self,$list)=@_;if (@$list % 2){die "Unexpected data in perl/glob construction"}my%globdata=@$list;my$name=delete$globdata{NAME}or die "Missing NAME in perl/glob";my$pkg=delete$globdata{PACKAGE};$pkg='main' unless defined$pkg;my@allowed=qw(SCALAR ARRAY HASH CODE IO);delete@globdata{@allowed };if (my@keys=keys%globdata){die "Unexpected keys in perl/glob: @keys"}no strict 'refs';return *{"${pkg}::$name"}}sub construct_scalar {my ($self,$list)=@_;if (@$list!=2){die "Unexpected data in perl/scalar construction"}my ($key,$value)=@$list;unless ($key eq '='){die "Unexpected data in perl/scalar construction"}return$value}sub construct_ref {&construct_scalar}sub represent_scalar {my ($self,$value)=@_;return {'='=>$$value }}sub represent_ref {&represent_scalar}sub represent_code {my ($self,$code)=@_;require B::Deparse;my$deparse=B::Deparse->new("-p","-sC");return$deparse->coderef2text($code)}my@stats=qw/device inode mode links uid gid rdev size atime mtime ctime blksize blocks/;sub represent_glob {my ($self,$glob)=@_;my%glob;for my$type (qw/PACKAGE NAME SCALAR ARRAY HASH CODE IO/){my$value=*{$glob}{$type};if ($type eq 'SCALAR'){$value=$$value}elsif ($type eq 'IO'){if (defined$value){undef$value;$value->{stat}={};if ($value->{fileno}=fileno(*{$glob})){@{$value->{stat}}{@stats }=stat(*{$glob});$value->{tell}=tell *{$glob}}}}$glob{$type }=$value if defined$value}return \%glob}sub represent_regex {my ($self,$regex)=@_;$regex="$regex";if ($regex =~ m/^$qr_prefix(.*)\)\z/s){$regex=$1}return$regex}sub object {my ($self,$data,$class)=@_;return bless$data,$class}1;
YAML_PP_SCHEMA_PERL

$fatpacked{"YAML/PP/Schema/Tie/IxHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_TIE_IXHASH';
  use strict;use warnings;package YAML::PP::Schema::Tie::IxHash;our$VERSION='0.031';use base 'YAML::PP::Schema';use Scalar::Util qw/blessed reftype/;my$ixhash=eval {require Tie::IxHash};sub register {my ($self,%args)=@_;my$schema=$args{schema};unless ($ixhash){die "You need to install Tie::IxHash in order to use this module"}$schema->add_representer(tied_equals=>'Tie::IxHash',code=>sub {my ($rep,$node)=@_;$node->{items}=[%{$node->{data}}];return 1},);return}1;
YAML_PP_SCHEMA_TIE_IXHASH

$fatpacked{"YAML/PP/Schema/YAML1_1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_YAML1_1';
  use strict;use warnings;package YAML::PP::Schema::YAML1_1;our$VERSION='0.031';use YAML::PP::Schema::JSON qw/represent_int represent_float represent_literal represent_bool represent_undef/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;my$RE_INT_1_1=qr{^([+-]?(?:0|[1-9][0-9_]*))$};my$RE_FLOAT_1_1=qr{^([+-]?(?:[0-9][0-9_]*)?\.[0-9_]*(?:[eE][+-][0-9]+)?)$};my$RE_SEXAGESIMAL=qr{^([+-]?[0-9][0-9_]*(:[0-5]?[0-9])+\.[0-9_]*)$};my$RE_SEXAGESIMAL_INT=qr{^([-+]?[1-9][0-9_]*(:[0-5]?[0-9])+)$};my$RE_INT_OCTAL_1_1=qr{^([+-]?)0([0-7_]+)$};my$RE_INT_HEX_1_1=qr{^([+-]?)(0x[0-9a-fA-F_]+)$};my$RE_INT_BIN_1_1=qr{^([-+]?)(0b[0-1_]+)$};sub _from_oct {my ($constructor,$event,$matches)=@_;my ($sign,$oct)=@$matches;$oct =~ tr/_//d;my$result=oct$oct;$result=-$result if$sign eq '-';return$result}sub _from_hex {my ($constructor,$event,$matches)=@_;my ($sign,$hex)=@$matches;my$result=hex$hex;$result=-$result if$sign eq '-';return$result}sub _sexa_to_float {my ($constructor,$event,$matches)=@_;my ($float)=@$matches;my$result=0;my$i=0;my$sign=1;$float =~ s/^-// and $sign=-1;for my$part (reverse split m/:/,$float){$result += $part * (60 ** $i);$i++}$result=unpack F=>pack F=>$result;return$result * $sign}sub _to_float {my ($constructor,$event,$matches)=@_;my ($float)=@$matches;$float =~ tr/_//d;$float=unpack F=>pack F=>$float;return$float}sub _to_int {my ($constructor,$event,$matches)=@_;my ($int)=@$matches;$int =~ tr/_//d;0 + $int}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>$_=>undef ],)for (qw/null NULL Null ~/,'');$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->true ],)for (qw/true TRUE True y Y yes Yes YES on On ON/);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->false ],)for (qw/false FALSE False n N no No NO off Off OFF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_OCTAL_1_1=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_1_1=>\&_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_HEX_1_1=>\&_from_hex ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT_1_1=>\&_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_BIN_1_1=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_SEXAGESIMAL_INT=>\&_sexa_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_SEXAGESIMAL=>\&_sexa_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "inf" ],)for (qw/.inf .Inf .INF +.inf +.Inf +.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 - "inf" ],)for (qw/-.inf -.Inf -.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "nan" ],)for (qw/.nan .NaN .NAN/);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],implicit=>0,);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(undefined=>\&represent_undef,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true TRUE True y Y yes Yes YES on On ON false FALSE False n N n no No NO off Off OFF null NULL Null ~ .inf .Inf .INF -.inf -.Inf -.INF +.inf +.Inf +.INF .nan .NaN .NAN/);$schema->add_representer(regex=>qr{$RE_INT_1_1|$RE_FLOAT_1_1|$RE_INT_OCTAL_1_1|$RE_INT_HEX_1_1|$RE_INT_BIN_1_1|$RE_SEXAGESIMAL_INT|$RE_SEXAGESIMAL},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}1;
YAML_PP_SCHEMA_YAML1_1

$fatpacked{"YAML/PP/Type/MergeKey.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_TYPE_MERGEKEY';
  use strict;use warnings;package YAML::PP::Type::MergeKey;our$VERSION='0.031';sub new {my ($class)=@_;return bless {},$class}1;
YAML_PP_TYPE_MERGEKEY

$fatpacked{"YAML/PP/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER';
  use strict;use warnings;package YAML::PP::Writer;our$VERSION='0.031';sub output {return $_[0]->{output}}sub set_output {$_[0]->{output}=$_[1]}sub new {my ($class,%args)=@_;my$output=delete$args{output};$output='' unless defined$output;return bless {output=>$output,},$class}sub write {my ($self,$line)=@_;$self->{output}.= $line}sub init {$_[0]->set_output('')}sub finish {my ($self)=@_;$_[0]->set_output(undef)}1;
YAML_PP_WRITER

$fatpacked{"YAML/PP/Writer/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER_FILE';
  use strict;use warnings;package YAML::PP::Writer::File;our$VERSION='0.031';use Scalar::Util qw/openhandle/;use base qw/YAML::PP::Writer/;use Carp qw/croak/;sub _open_handle {my ($self)=@_;if (openhandle($self->{output})){$self->{filehandle}=$self->{output};return$self->{output}}open my$fh,'>:encoding(UTF-8)',$self->{output}or croak "Could not open '$self->{output}' for writing: $!";$self->{filehandle}=$fh;return$fh}sub write {my ($self,$line)=@_;my$fh=$self->{filehandle};print$fh $line}sub init {my ($self)=@_;my$fh=$self->_open_handle}sub finish {my ($self)=@_;if (openhandle($self->{output})){return}close$self->{filehandle}}1;
YAML_PP_WRITER_FILE

$fatpacked{"lib/core/only.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIB_CORE_ONLY';
  package lib::core::only;use strict;use warnings FATAL=>'all';use Config;sub import {@INC=@Config{qw(privlibexp archlibexp)};return}1;
LIB_CORE_ONLY

$fatpacked{"local/lib.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LOCAL_LIB';
  package local::lib;use 5.006;BEGIN {if ($ENV{RELEASE_TESTING}){require strict;strict->import;require warnings;warnings->import}}use Config ();our$VERSION='2.000028';$VERSION =~ tr/_//d;BEGIN {*_WIN32=($^O eq 'MSWin32' || $^O eq 'NetWare' || $^O eq 'symbian')? sub(){1}: sub(){0};*_USE_FSPEC=($^O eq 'MacOS' || $^O eq 'VMS' || $INC{'File/Spec.pm'})? sub(){1}: sub(){0}}my$_archname=$Config::Config{archname};my$_version=$Config::Config{version};my@_inc_version_list=reverse split / /,$Config::Config{inc_version_list};my$_path_sep=$Config::Config{path_sep};our$_DIR_JOIN=_WIN32 ? '\\' : '/';our$_DIR_SPLIT=(_WIN32 || $^O eq 'cygwin')? qr{[\\/]} : qr{/};our$_ROOT=_WIN32 ? do {my$UNC=qr{[\\/]{2}[^\\/]+[\\/][^\\/]+};qr{^(?:$UNC|[A-Za-z]:|)$_DIR_SPLIT}}: qr{^/};our$_PERL;sub _perl {if (!$_PERL){($_PERL,my$exe)=$^X =~ /((?:.*$_DIR_SPLIT)?(.+))/;$_PERL='perl' if$exe !~ /perl/;if (_is_abs($_PERL)){}elsif (-x $Config::Config{perlpath}){$_PERL=$Config::Config{perlpath}}elsif ($_PERL =~ $_DIR_SPLIT && -x $_PERL){$_PERL=_rel2abs($_PERL)}else {($_PERL)=map {/(.*)/}grep {-x $_}map {($_,_WIN32 ? ("$_.exe"): ())}map {join($_DIR_JOIN,$_,$_PERL)}split /\Q$_path_sep\E/,$ENV{PATH}}}$_PERL}sub _cwd {if (my$cwd =defined&Cwd::sys_cwd ? \&Cwd::sys_cwd : defined&Cwd::cwd ? \&Cwd::cwd : undef){no warnings 'redefine';*_cwd=$cwd;goto &$cwd}my$drive=shift;return Win32::GetCwd()if _WIN32 && defined&Win32::GetCwd &&!$drive;local@ENV{qw(PATH IFS CDPATH ENV BASH_ENV)};my$cmd=$drive ? "eval { Cwd::getdcwd(q($drive)) }" : 'getcwd';my$perl=_perl;my$cwd=`"$perl" -MCwd -le "print $cmd"`;chomp$cwd;if (!length$cwd && $drive){$cwd=$drive}$cwd =~ s/$_DIR_SPLIT?$/$_DIR_JOIN/;$cwd}sub _catdir {if (_USE_FSPEC){require File::Spec;File::Spec->catdir(@_)}else {my$dir=join($_DIR_JOIN,@_);$dir =~ s{($_DIR_SPLIT)(?:\.?$_DIR_SPLIT)+}{$1}g;$dir}}sub _is_abs {if (_USE_FSPEC){require File::Spec;File::Spec->file_name_is_absolute($_[0])}else {$_[0]=~ $_ROOT}}sub _rel2abs {my ($dir,$base)=@_;return$dir if _is_abs($dir);$base=_WIN32 && $dir =~ s/^([A-Za-z]:)// ? _cwd("$1"): $base ? _rel2abs($base): _cwd;return _catdir($base,$dir)}our$_DEVNULL;sub _devnull {return$_DEVNULL ||= _USE_FSPEC ? (require File::Spec,File::Spec->devnull): _WIN32 ? 'nul' : $^O eq 'os2' ? '/dev/nul' : '/dev/null'}sub import {my ($class,@args)=@_;if ($0 eq '-'){push@args,@ARGV;require Cwd}my@steps;my%opts;my%attr;my$shelltype;while (@args){my$arg=shift@args;if ($arg =~ /\xE2\x88\x92/){die <<'DEATH'}elsif ($arg eq '--self-contained'){die <<'DEATH'}elsif($arg =~ /^--deactivate(?:=(.*))?$/){my$path=defined $1 ? $1 : shift@args;push@steps,['deactivate',$path]}elsif ($arg eq '--deactivate-all'){push@steps,['deactivate_all']}elsif ($arg =~ /^--shelltype(?:=(.*))?$/){$shelltype=defined $1 ? $1 : shift@args}elsif ($arg eq '--no-create'){$opts{no_create}=1}elsif ($arg eq '--quiet'){$attr{quiet}=1}elsif ($arg eq '--always'){$attr{always}=1}elsif ($arg =~ /^--/){die "Unknown import argument: $arg"}else {push@steps,['activate',$arg,\%opts]}}if (!@steps){push@steps,['activate',undef,\%opts]}my$self=$class->new(%attr);for (@steps){my ($method,@args)=@$_;$self=$self->$method(@args)}if ($0 eq '-'){print$self->environment_vars_string($shelltype);exit 0}else {$self->setup_local_lib}}sub new {my$class=shift;bless {@_},$class}sub clone {my$self=shift;bless {%$self,@_},ref$self}sub inc {$_[0]->{inc}||= \@INC}sub libs {$_[0]->{libs}||= [\'PERL5LIB' ]}sub bins {$_[0]->{bins}||= [\'PATH' ]}sub roots {$_[0]->{roots}||= [\'PERL_LOCAL_LIB_ROOT' ]}sub extra {$_[0]->{extra}||= {}}sub quiet {$_[0]->{quiet}}sub _as_list {my$list=shift;grep length,map {!(ref $_ && ref $_ eq 'SCALAR')? $_ : (defined$ENV{$$_}? split(/\Q$_path_sep/,$ENV{$$_}): ())}ref$list ? @$list : $list}sub _remove_from {my ($list,@remove)=@_;return @$list if!@remove;my%remove=map {$_=>1}@remove;grep!$remove{$_},_as_list($list)}my@_lib_subdirs=([$_version,$_archname],[$_version],[$_archname],(map [$_],@_inc_version_list),[],);sub install_base_bin_path {my ($class,$path)=@_;return _catdir($path,'bin')}sub install_base_perl_path {my ($class,$path)=@_;return _catdir($path,'lib','perl5')}sub install_base_arch_path {my ($class,$path)=@_;_catdir($class->install_base_perl_path($path),$_archname)}sub lib_paths_for {my ($class,$path)=@_;my$base=$class->install_base_perl_path($path);return map {_catdir($base,@$_)}@_lib_subdirs}sub _mm_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;if ($path =~ s/ /\\ /g){$path=qq{"$path"}}return$path}sub _mb_escape_path {my$path=shift;$path =~ s/\\/\\\\/g;return qq{"$path"}}sub installer_options_for {my ($class,$path)=@_;return (PERL_MM_OPT=>defined$path ? "INSTALL_BASE="._mm_escape_path($path): undef,PERL_MB_OPT=>defined$path ? "--install_base "._mb_escape_path($path): undef,)}sub active_paths {my ($self)=@_;$self=ref$self ? $self : $self->new;return grep {my$active_ll=$self->install_base_perl_path($_);grep {$_ eq $active_ll}@{$self->inc}}_as_list($self->roots)}sub deactivate {my ($self,$path)=@_;$self=$self->new unless ref$self;$path=$self->resolve_path($path);$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (!grep {$_ eq $path}@active_lls){warn "Tried to deactivate inactive local::lib '$path'\n";return$self}my%args=(bins=>[_remove_from($self->bins,$self->install_base_bin_path($path))],libs=>[_remove_from($self->libs,$self->install_base_perl_path($path))],inc=>[_remove_from($self->inc,$self->lib_paths_for($path))],roots=>[_remove_from($self->roots,$path)],);$args{extra}={$self->installer_options_for($args{roots}[0])};$self->clone(%args)}sub deactivate_all {my ($self)=@_;$self=$self->new unless ref$self;my@active_lls=$self->active_paths;my%args;if (@active_lls){%args=(bins=>[_remove_from($self->bins,map$self->install_base_bin_path($_),@active_lls)],libs=>[_remove_from($self->libs,map$self->install_base_perl_path($_),@active_lls)],inc=>[_remove_from($self->inc,map$self->lib_paths_for($_),@active_lls)],roots=>[_remove_from($self->roots,@active_lls)],)}$args{extra}={$self->installer_options_for(undef)};$self->clone(%args)}sub activate {my ($self,$path,$opts)=@_;$opts ||= {};$self=$self->new unless ref$self;$path=$self->resolve_path($path);$self->ensure_dir_structure_for($path,{quiet=>$self->quiet })unless$opts->{no_create};$path=$self->normalize_path($path);my@active_lls=$self->active_paths;if (grep {$_ eq $path}@active_lls[1 .. $#active_lls]){$self=$self->deactivate($path)}my%args;if ($opts->{always}||!@active_lls || $active_lls[0]ne $path){%args=(bins=>[$self->install_base_bin_path($path),@{$self->bins}],libs=>[$self->install_base_perl_path($path),@{$self->libs}],inc=>[$self->lib_paths_for($path),@{$self->inc}],roots=>[$path,@{$self->roots}],)}$args{extra}={$self->installer_options_for($path)};$self->clone(%args)}sub normalize_path {my ($self,$path)=@_;$path=(Win32::GetShortPathName($path)|| $path)if $^O eq 'MSWin32';return$path}sub build_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_activate_environment_vars_for {my$self=$_[0]->new->activate($_[1],{always=>1 });$self->build_environment_vars}sub build_deactivate_environment_vars_for {my$self=$_[0]->new->deactivate($_[1]);$self->build_environment_vars}sub build_deact_all_environment_vars_for {my$self=$_[0]->new->deactivate_all;$self->build_environment_vars}sub build_environment_vars {my$self=shift;(PATH=>join($_path_sep,_as_list($self->bins)),PERL5LIB=>join($_path_sep,_as_list($self->libs)),PERL_LOCAL_LIB_ROOT=>join($_path_sep,_as_list($self->roots)),%{$self->extra},)}sub setup_local_lib_for {my$self=$_[0]->new->activate($_[1]);$self->setup_local_lib}sub setup_local_lib {my$self=shift;require Carp::Heavy if$INC{'Carp.pm'};$self->setup_env_hash;@INC=@{$self->inc}}sub setup_env_hash_for {my$self=$_[0]->new->activate($_[1]);$self->setup_env_hash}sub setup_env_hash {my$self=shift;my%env=$self->build_environment_vars;for my$key (keys%env){if (defined$env{$key}){$ENV{$key}=$env{$key}}else {delete$ENV{$key}}}}sub print_environment_vars_for {print $_[0]->environment_vars_string_for(@_[1..$#_])}sub environment_vars_string_for {my$self=$_[0]->new->activate($_[1],{always=>1});$self->environment_vars_string}sub environment_vars_string {my ($self,$shelltype)=@_;$shelltype ||= $self->guess_shelltype;my$extra=$self->extra;my@envs=(PATH=>$self->bins,PERL5LIB=>$self->libs,PERL_LOCAL_LIB_ROOT=>$self->roots,map {$_=>$extra->{$_}}sort keys %$extra,);$self->_build_env_string($shelltype,\@envs)}sub _build_env_string {my ($self,$shelltype,$envs)=@_;my@envs=@$envs;my$build_method="build_${shelltype}_env_declaration";my$out='';while (@envs){my ($name,$value)=(shift(@envs),shift(@envs));if (ref$value && @$value==1 && ref$value->[0]&& ref$value->[0]eq 'SCALAR' && ${$value->[0]}eq $name){next}$out .= $self->$build_method($name,$value)}my$wrap_method="wrap_${shelltype}_output";if ($self->can($wrap_method)){return$self->$wrap_method($out)}return$out}sub build_bourne_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'${%s:-}',qr/["\\\$!`]/,'\\%s');if (!defined$value){return qq{unset $name;\n}}$value =~ s/(^|\G|$_path_sep)\$\{$name:-\}$_path_sep/$1\${$name}\${$name:+$_path_sep}/g;$value =~ s/$_path_sep\$\{$name:-\}$/\${$name:+$_path_sep\${$name}}/;qq{${name}="$value"; export ${name};\n}}sub build_csh_env_declaration {my ($class,$name,$args)=@_;my ($value,@vars)=$class->_interpolate($args,'${%s}',qr/["\$]/,'"\\%s"');if (!defined$value){return qq{unsetenv $name;\n}}my$out='';for my$var (@vars){$out .= qq{if ! \$?$name setenv $name '';\n}}my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$\{$name\}(?:$_path_sep|$)//g){$out .= qq{if "\${$name}" != '' setenv $name "$value";\n};$out .= qq{if "\${$name}" == '' }}$out .= qq{setenv $name "$value_without";\n};return$out}sub build_cmd_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'%%%s%%',qr(%),'%s');if (!$value){return qq{\@set $name=\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)%$name%(?:$_path_sep|$)//g){$out .= qq{\@if not "%$name%"=="" set "$name=$value"\n};$out .= qq{\@if "%$name%"=="" }}$out .= qq{\@set "$name=$value_without"\n};return$out}sub build_powershell_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$env:%s',qr/["\$]/,'`%s');if (!$value){return qq{Remove-Item -ErrorAction 0 Env:\\$name;\n}}my$maybe_path_sep=qq{\$(if("\$env:$name"-eq""){""}else{"$_path_sep"})};$value =~ s/(^|\G|$_path_sep)\$env:$name$_path_sep/$1\$env:$name"+$maybe_path_sep+"/g;$value =~ s/$_path_sep\$env:$name$/"+$maybe_path_sep+\$env:$name+"/;qq{\$env:$name = \$("$value");\n}}sub wrap_powershell_output {my ($class,$out)=@_;return$out || " \n"}sub build_fish_env_declaration {my ($class,$name,$args)=@_;my$value=$class->_interpolate($args,'$%s',qr/[\\"'$ ]/,'\\%s');if (!defined$value){return qq{set -e $name;\n}}if ($name =~ /^(?:CD|MAN)?PATH$/){$value =~ s/$_path_sep/ /g;my$silent=$name =~ /^(?:CD)?PATH$/ ? " 2>"._devnull : '';return qq{set -x $name $value$silent;\n}}my$out='';my$value_without=$value;if ($value_without =~ s/(?:^|$_path_sep)\$$name(?:$_path_sep|$)//g){$out .= qq{set -q $name; and set -x $name $value;\n};$out .= qq{set -q $name; or }}$out .= qq{set -x $name $value_without;\n};$out}sub _interpolate {my ($class,$args,$var_pat,$escape,$escape_pat)=@_;return unless defined$args;my@args=ref$args ? @$args : $args;return unless@args;my@vars=map {$$_}grep {ref $_ eq 'SCALAR'}@args;my$string=join$_path_sep,map {ref $_ eq 'SCALAR' ? sprintf($var_pat,$$_): do {s/($escape)/sprintf($escape_pat, $1)/ge;$_}}@args;return wantarray ? ($string,\@vars): $string}sub pipeline;sub pipeline {my@methods=@_;my$last=pop(@methods);if (@methods){\sub {my ($obj,@args)=@_;$obj->${pipeline@methods}($obj->$last(@args))}}else {\sub {shift->$last(@_)}}}sub resolve_path {my ($class,$path)=@_;$path=$class->${pipeline qw(resolve_relative_path resolve_home_path resolve_empty_path)}($path);$path}sub resolve_empty_path {my ($class,$path)=@_;if (defined$path){$path}else {'~/perl5'}}sub resolve_home_path {my ($class,$path)=@_;$path =~ /^~([^\/]*)/ or return$path;my$user=$1;my$homedir=do {if (!length($user)&& defined$ENV{HOME}){$ENV{HOME}}else {require File::Glob;File::Glob::bsd_glob("~$user",File::Glob::GLOB_TILDE())}};unless (defined$homedir){require Carp;require Carp::Heavy;Carp::croak("Couldn't resolve homedir for " .(defined$user ? $user : 'current user'))}$path =~ s/^~[^\/]*/$homedir/;$path}sub resolve_relative_path {my ($class,$path)=@_;_rel2abs($path)}sub ensure_dir_structure_for {my ($class,$path,$opts)=@_;$opts ||= {};my@dirs;for my$dir ($class->lib_paths_for($path),$class->install_base_bin_path($path),){my$d=$dir;while (!-d $d){push@dirs,$d;require File::Basename;$d=File::Basename::dirname($d)}}warn "Attempting to create directory ${path}\n" if!$opts->{quiet}&& @dirs;my%seen;for my$dir (reverse@dirs){next if$seen{$dir}++;mkdir$dir or -d $dir or die "Unable to create $dir: $!"}return}sub guess_shelltype {my$shellbin =defined$ENV{SHELL}&& length$ENV{SHELL}? ($ENV{SHELL}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' && exists$ENV{'!EXITCODE'})? 'bash' : ($^O eq 'MSWin32' && $ENV{PROMPT}&& $ENV{COMSPEC})? ($ENV{COMSPEC}=~ /([\w.]+)$/)[-1]: ($^O eq 'MSWin32' &&!$ENV{PROMPT})? 'powershell.exe' : 'sh';for ($shellbin){return /csh$/ ? 'csh' : /fish$/ ? 'fish' : /command(?:\.com)?$/i ? 'cmd' : /cmd(?:\.exe)?$/i ? 'cmd' : /4nt(?:\.exe)?$/i ? 'cmd' : /powershell(?:\.exe)?$/i ? 'powershell' : 'bourne'}}1;
  WHOA THERE! It looks like you've got some fancy dashes in your commandline!
  These are *not* the traditional -- dashes that software recognizes. You
  probably got these by copy-pasting from the perldoc for this module as
  rendered by a UTF8-capable formatter. This most typically happens on an OS X
  terminal, but can happen elsewhere too. Please try again after replacing the
  dashes with normal minus signs.
  DEATH
  FATAL: The local::lib --self-contained flag has never worked reliably and the
  original author, Mark Stosberg, was unable or unwilling to maintain it. As
  such, this flag has been removed from the local::lib codebase in order to
  prevent misunderstandings and potentially broken builds. The local::lib authors
  recommend that you look at the lib::core::only module shipped with this
  distribution in order to create a more robust environment that is equivalent to
  what --self-contained provided (although quite possibly not what you originally
  thought it provided due to the poor quality of the documentation, for which we
  apologise).
  DEATH
LOCAL_LIB

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;

use App::cpm::CLI;
exit App::cpm::CLI->new->run(@ARGV);

__END__

=head1 NAME

cpm - a fast CPAN module installer

=head1 SYNOPSIS

  # install modules into local/
  > cpm install Module1 Module2 ...

  # install modules with verbose messages
  > cpm install -v Module

  # from cpanfile (with cpanfile.snapshot if any)
  > cpm install

  # install module into current @INC instead of local/
  > cpm install -g Module

  # read modules from STDIN by specifying "-" as an argument
  > echo Module1 Module2 | cpm install -

  # prefer TRIAL release
  > cpm install --dev Moose

  # install modules as if version of your perl is 5.8.5
  # so that modules which are not core in 5.8.5 will be installed
  > cpm install --target-perl 5.8.5

  # resolve distribution names from DARKPAN/modules/02packages.details.txt.gz
  # and fetch distibutions from DARKPAN/authors/id/...
  > cpm install --resolver 02packages,http://example.com/darkpan Your::Module
  > cpm install --resolver 02packages,file:///path/to/darkpan    Your::Module

  # use darkpan first, and if it fails, use metadb and normal CPAN
  > cpm install --resolver 02packages,http://example.com/darkpan --resolver metadb Your::Module

  # specify types/phases in cpanfile by "--with-*" and "--without-*" options
  > cpm install --with-recommends --without-test

=head1 OPTIONS

  -w, --workers=N
        number of workers, default: 5
  -L, --local-lib-contained=DIR
        directory to install modules into, default: local/
  -g, --global
        install modules into current @INC instead of local/
  -v, --verbose
        verbose mode; you can see what is going on
      --prebuilt, --no-prebuilt
        save builds for CPAN distributions; and later, install the prebuilts if available
        default: on; you can also set $ENV{PERL_CPM_PREBUILT} false to disable this option
      --target-perl=VERSION  (EXPERIMENTAL)
        install modules as if verison is your perl is VERSION
      --mirror=URL
        base url for the CPAN mirror to use, cannot be used multiple times. Use --resolver instead.
        default: https://cpan.metacpan.org
      --pp, --pureperl-only
        prefer pureperl only build
      --static-install, --no-static-install
        enable/disable the static install, default: enable
  -r, --resolver=class,args (EXPERIMENTAL, will be removed or renamed)
        specify resolvers, you can use --resolver multiple times
        available classes: metadb/metacpan/02packages/snapshot
      --reinstall
        reinstall the distribution even if you already have the latest version installed
      --dev (EXPERIMENTAL)
        resolve TRIAL distributions too
      --color, --no-color
        turn on/off color output, default: on
      --test, --no-test
        run test cases, default: no
      --man-pages
        generate man pages
      --retry, --no-retry
        retry configure/build/test/install if fails, default: retry
      --show-build-log-on-failure
        show build.log on failure, default: off
      --configure-timeout=sec, --build-timeout=sec, --test-timeout=sec
        specify configure/build/test timeout second, default: 60sec, 3600sec, 1800sec
      --show-progress, --no-show-progress
        show progress, default: on
      --cpanfile=path
        specify cpanfile path, default: ./cpanfile
      --snapshot=path
        specify cpanfile.snapshot path, default: ./cpanfile.snapshot
  -V, --version
        show version
  -h, --help
        show this help
      --feature=identifier
        specify the feature to enable in cpanfile; you can use --feature multiple times
      --with-requires,   --without-requires   (default: with)
      --with-recommends, --without-recommends (default: without)
      --with-suggests,   --without-suggests   (default: without)
      --with-configure,  --without-configure  (default: without)
      --with-build,      --without-build      (default: with)
      --with-test,       --without-test       (default: with)
      --with-runtime,    --without-runtime    (default: with)
      --with-develop,    --without-develop    (default: without)
        specify types/phases of dependencies in cpanfile to be installed
      --with-all
        shortcut for --with-requires, --with-recommends, --with-suggests,
        --with-configure, --with-build, --with-test, --with-runtime and --with-develop

=head1 COPYRIGHT AND LICENSE

Copyright 2015 Shoichi Kaji E<lt>skaji@cpan.orgE<gt>

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
